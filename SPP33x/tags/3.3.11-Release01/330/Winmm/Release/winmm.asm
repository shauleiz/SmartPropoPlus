	TITLE	C:\Code\SmartPropoPlus\330\Winmm\winmm.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CP@KNHJ@Software?2Flying?9Model?9Simulator?2@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@JIDN@Debug?9Level?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@CECA@SmartPropoPlus?5Version?5?$CFx?6Debug?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@HBCE@?$CFs?6Modulation?3?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@IEIB@?$CFs?7Auto?9Detect?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@JFKH@?$CFs?7Positive?5Shift?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@EHBF@?$CFs?7Negative?5Shift?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04FEEL@TEMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@GEPJ@SPP_ctrl?4log?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KEJO@?$CFs?2?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01LLF@w?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EK@MKDA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DNIN@?$CFs?5?9?5?$CFs?6?$CFs?6?6?$CFs?6?6?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@NMI@?$CFs?6?6Control?9Flow?5logfile?3?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@IKMO@?$CFs?6?6Cannot?5open?5logfile?3?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@LNPD@SPP_data?4log?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@FELG@?$CFs?6?6Data?9Flow?5logfile?3?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@KJAH@SmartPropoPlus?5Debug?5Message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@MHKP@Former?5Modulation?3?7Mod?$DN?$CFd?$DL?5Auto?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@FEH@?$CFs?6New?5Modulation?3?7Mod?$DN?$CFd?$DL?5Auto?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EA@HNBK@?6?$CFs?5?9?5ProcessData?$CI?$CF7d?$CJ?5?$CIH?$CJ?$DL?5Min?1@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EA@DOJA@?6?$CFs?5?9?5ProcessData?$CI?$CF7d?$CJ?5?$CIL?$CJ?$DL?5Min?1@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DF@JMB@?7JoyStick?5channels?3?5Ch?$FL1?36?$FN?3?5?$CF4d@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@IKNH@?$CFs?6Error?3?5?$CFd?5?$CFs?6?$AN?$ANFile?3?5?$CFs?$CILine?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NKNB@?$CFs?6?$AN?$ANFile?3?5?$CFs?$CILine?5?$CFd?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IPMD@SmartPropoPlus?5Message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@OOJL@C?3?2Code?2SmartPropoPlus?2330?2Winmm@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@EIEO@LoadOrigDll?$CI?$CJ?3?5File?5to?5load?5is?5?$CI@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DB@EMCB@LoadOrigDll?$CI?$CJ?3?5Cannot?5get?5attrib@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CO@KOE@LoadOrigDll?$CI?$CFd?$CJ?3?6?$ANCannot?5load?5Fi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@IIHD@?6?$CFs?5?9?5ProcessPulseAirPcm1?$CI?$CFd?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CO@HFOB@?6?$CFs?5?9?5ProcessPulseAirPcm2?$CIWidth?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@PHFI@?6?$CFs?5?9?5ProcessPulseJrPcm?$CI?$CFd?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@PCLJ@?6?$CFs?5?9?5ProcessPulseFutabaPcm?$CI?$CFd?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@INEJ@?6?$CFs?5?9?5ProcessPulsePpm?$CIwidth?$DN?$CFd?0?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NFKC@?5data?$FL?$CFd?$FN?$DN?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@IBDB@?6?$CFs?5?9?5ProcessPulseFutabaPpm?$CIwidt@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CM@JGMD@?6?$CFs?5?9?5ProcessPulseJrPpm?$CIwidth?$DN?$CFd@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03JFHP@PPM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02GLDK@JR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03EDDN@FUT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IKIA@AIR1?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HFDJ@AIR2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03PNIK@WAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@FCGA@WINMM?5Dll?5is?5running?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@MMLM@SppConsole?4exe?5?9i?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@PNCM@Inter?5SPP?5Application?5Message?52?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@PJBN@?6?$CFs?5?9?5Closing?5WINMM?4DLL?6?6?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@JKLI@SmartPropoPlus?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@EJKD@LoadWinmm?$CI?$CFd?$CJ?3?5Cannot?5find?5path?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CM@MBL@LoadWinmm?$CI?$CFd?$CJ?3?5Cannot?5find?5path?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@MJGG@?2winmm?4dll?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@NHMO@JsChPostProc?4dll?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DC@DGNP@Joystick?5filter?5too?5old?5?9?5cannot@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@KNBM@GetDllVersion?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@DOIL@ProcessChannels?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@OKGG@GetNumberOfFilters?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@IBB@GetFilterNameByIndex?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IEFL@GetFilterIdByIndex?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DEON@SelectFilterByIndex?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@KJLB@GetIndexOfSelectedFilter?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HIAF@?$CIDefault?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@FGGD@CloseDriver?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@PEDJ@DefDriverProc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@GMDJ@DriverCallback?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@JLHO@DrvGetModuleHandle?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@EEHB@GetDriverModuleHandle?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@MFHB@MigrateAllDrivers?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KFIL@MigrateSoundEvents?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IALO@NotifyCallbackData?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@OOCK@OpenDriver?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09OHCJ@PlaySound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CELA@PlaySoundA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@HCLC@PlaySoundW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@EGH@SendDriverMessage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HCOI@WOW32DriverCallback?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@CCM@WOW32ResolveMultiMediaHandle?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@KFKN@WOWAppExit?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@IBFM@WinmmLogoff?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@FKIE@WinmmLogon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@LFH@aux32Message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@CIL@auxGetDevCapsA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@FEIJ@auxGetDevCapsW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@IJOA@auxGetNumDevs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@EKJK@auxGetVolume?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@FOOK@auxOutMessage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@GHDI@auxSetVolume?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@HEGD@joy32Message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DMC@joyConfigChanged?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@LCHD@joyGetDevCapsA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@OEHB@joyGetDevCapsW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@HBJP@joyGetNumDevs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09DPN@joyGetPos?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JKBD@joyGetThreshold?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@DMDH@joyReleaseCapture?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@KPDA@joySetCapture?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@PDBB@joySetThreshold?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@HHJD@mci32Message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FIAF@mciDriverNotify?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@KNAD@mciDriverYield?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@LOGF@mciExecute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@EHJF@mciFreeCommandResource?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@BBJL@mciGetCreatorTask?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@KIH@mciGetDeviceIDA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@MCHF@mciGetDeviceIDFromElementIDA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@JEHH@mciGetDeviceIDFromElementIDW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FMIF@mciGetDeviceIDW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DLAL@mciGetDriverData?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IDBJ@mciGetErrorStringA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@NFBL@mciGetErrorStringW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@LJKD@mciGetYieldProc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IJD@mciLoadCommandResource?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JKLO@mciSendCommandA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@MMLM@mciSendCommandW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@GAMF@mciSendStringA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@DGMH@mciSendStringW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@GIGC@mciSetDriverData?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@NAKB@mciSetYieldProc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@DICL@mid32Message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@CPPD@midiConnect?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@KHF@midiDisconnect?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@MNBE@midiInAddBuffer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@KBJH@midiInClose?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@NPDI@midiInGetDevCapsA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@IJDK@midiInGetDevCapsW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@OCKH@midiInGetErrorTextA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@LEKF@midiInGetErrorTextW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LGKJ@midiInGetID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DKPK@midiInGetNumDevs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@DNDL@midiInMessage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@FPCM@midiInOpen?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@PKDG@midiInPrepareHeader?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@OLBB@midiInReset?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LFPM@midiInStart?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GHDE@midiInStop?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@JPPA@midiInUnprepareHeader?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@NAJB@midiOutCacheDrumPatches?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CBNA@midiOutCachePatches?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@PCNN@midiOutClose?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@BA@midiOutGetDevCapsA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@FGBC@midiOutGetDevCapsW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@HLAE@midiOutGetErrorTextA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@CNAG@midiOutGetErrorTextW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@OFOD@midiOutGetID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@BCOH@midiOutGetNumDevs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@ENJA@midiOutGetVolume?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@KNDI@midiOutLongMsg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@BJFN@midiOutMessage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@BFFB@midiOutOpen?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@GDJF@midiOutPrepareHeader?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@LIFL@midiOutReset?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@GADC@midiOutSetVolume?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@ICEO@midiOutShortMsg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@MNAE@midiOutUnprepareHeader?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@PKJI@midiStreamClose?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@FAGH@midiStreamOpen?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@MCEN@midiStreamOut?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JHNK@midiStreamPause?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@CJJI@midiStreamPosition?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@NHF@midiStreamProperty?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LLAA@midiStreamRestart?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@GIHP@midiStreamStop?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@NGHK@mixerClose?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@KKIG@mixerGetControlDetailsA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@PMIE@mixerGetControlDetailsW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MMIF@mixerGetDevCapsA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@JKIH@mixerGetDevCapsW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@MBEE@mixerGetID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@GELF@mixerGetLineControlsA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@DCLH@mixerGetLineControlsW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LCF@mixerGetLineInfoA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@FNCH@mixerGetLineInfoW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@IHGE@mixerGetNumDevs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@LFII@mixerMessage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09LCEO@mixerOpen?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@EDCE@mixerSetControlDetails?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@DCIM@mmDrvInstall?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@NEHP@mmGetCurrentTask?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@CGD@mmTaskBlock?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@GAFI@mmTaskCreate?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@GFLM@mmTaskSignal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LAKN@mmTaskYield?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@IBMG@mmioAdvance?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@LHNO@mmioAscend?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JPN@mmioClose?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CDLD@mmioCreateChunk?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@NPPM@mmioDescend?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GIMM@mmioFlush?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@HOBF@mmioGetInfo?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KFBE@mmioInstallIOProcA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@PDBG@mmioInstallIOProcW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09DNGC@mmioOpenA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GLGA@mmioOpenW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JKLF@mmioRead?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@PEIF@mmioRenameA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@KCIH@mmioRenameW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OEBA@mmioSeek?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@PCED@mmioSendMessage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@OCHB@mmioSetBuffer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@CNBJ@mmioSetInfo?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CJEP@mmioStringToFOURCCA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HPEN@mmioStringToFOURCCW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KGEC@mmioWrite?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@BLEE@mmsystemGetVersion?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@EHAL@mod32Message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@HKFI@mxd32Message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@CLPB@sndPlaySoundA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@HNPD@sndPlaySoundW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@OEDN@tid32Message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CAIP@timeBeginPeriod?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@NIGI@timeEndPeriod?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@MAOL@timeGetDevCaps?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@HHNM@timeGetSystemTime?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@HBOP@timeGetTime?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@CIKN@timeKillEvent?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@JPEP@timeSetEvent?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@PGPH@waveInGetDevCapsA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KAPF@waveInGetDevCapsW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IDJN@waveInGetErrorTextA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@NFJP@waveInGetErrorTextW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@CAPK@waveInGetID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@PFCO@waveInGetNumDevs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@CLNA@waveInGetPosition?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@FBPN@waveInMessage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@HNEC@waveInReset?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@EJGO@waveOutBreakLoop?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@DEEL@waveOutClose?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DKDJ@waveOutGetDevCapsA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GMDL@waveOutGetDevCapsW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@CJGF@waveOutGetErrorTextA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@HPGH@waveOutGetErrorTextW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CDHF@waveOutGetID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@DLCI@waveOutGetNumDevs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@BMAE@waveOutGetPitch?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@PGGC@waveOutGetPlaybackRate?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@OHBO@waveOutGetPosition?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@ICEE@waveOutGetVolume?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@CODB@waveOutMessage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@IDAC@waveOutOpen?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@FJAJ@waveOutPause?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@DBPE@waveOutPrepareHeader?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@HOMN@waveOutReset?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@KFNO@waveOutRestart?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@LOFH@waveOutSetPitch?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NGOG@waveOutSetPlaybackRate?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@KPOG@waveOutSetVolume?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@DHFI@waveOutUnprepareHeader?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@JLPE@waveOutWrite?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@FCAC@wid32Message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LDOC@winmmDbgOut?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GICE@winmmSetDebugLevel?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CNCC@wod32Message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09OCCL@gfxAddGfx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@BJBG@gfxBatchChange?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@EBCG@gfxCreateGfxFactoriesLis?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@FFCF@gfxCreateZoneFactoriesList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@GJGP@gfxDestroyDeviceInterfaceList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LMEH@gfxEnumerateGfxs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@MLFB@_gfxLogoff?$EA0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@HNL@_gfxLogon?$EA4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@EEEC@gfxModifyGfx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@LNDM@gfxOpenGfx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CDAE@gfxRemoveGfx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@BJCD@waveInAddBuffer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@DHME@waveInClose?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@MJA@waveInOpen?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@JLAM@waveInPrepareHeader?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@CDKP@waveInStart?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DEII@waveInStop?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@MDKC@waveInUnprepareHeader?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@JMBN@joyGetPosEx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __ftol2
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GetDebugLevel
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __DebugWelcomePopUp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __DebugChangeModPopUp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __DebugProcessData
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __DebugJoyStickData
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Message
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _LoadOrigDll
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DllMain@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _smooth
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WalkeraConvert2Bin
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WalkeraConvert2Oct
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WalkeraElevator
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WalkeraAilerons
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WalkeraThrottle
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WalkeraRudder
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WalkeraGear
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WalkeraPitch
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ProcessPulseAirWal
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @Convert15bits@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ProcessPulseAirPcm1
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @Convert20bits@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ProcessPulseAirPcm2
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ProcessPulseJrPcm
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ProcessPulseFutabaPcm
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ProcessPulsePpm
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ProcessPulseFutabaPpm
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ProcessPulseJrPpm
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _LoadProcessPulseFunctions
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetActiveProcessPulseFunction
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SetActiveJsChPostProcFunction
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StartSppConsole
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @ProcessData@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInProc@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StartPropo
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StopPropo
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GetPosition
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _joyGetDevCapsA@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _joyGetNumDevs@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _joyGetPosEx@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _LoadWinmm
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _LoadJsChPostProc
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GetPointerToJsChPostProcOriginalFunc
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GetJsChPostProcInfo
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _RunJsFilter
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GetPointerToOriginalFunc
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _joyConfigChanged
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _joyGetThreshold
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _joyReleaseCapture
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _joySetCapture
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _joySetThreshold
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mci32Message
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciDriverNotify
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciDriverYield
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciExecute
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciFreeCommandResource
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciGetCreatorTask
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciGetDeviceIDA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciGetDeviceIDFromElementIDA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciGetDeviceIDFromElementIDW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciGetDeviceIDW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciGetDriverData
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciGetErrorStringA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciGetErrorStringW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciGetYieldProc
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciLoadCommandResource
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciSendCommandA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciSendCommandW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciSendStringA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciSendStringW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciSetDriverData
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mciSetYieldProc
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mid32Message
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiConnect
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiDisconnect
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInAddBuffer
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInClose
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInGetDevCapsA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInGetDevCapsW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInGetErrorTextA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInGetErrorTextW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInGetID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInGetNumDevs
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInMessage
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInOpen
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInPrepareHeader
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInReset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInStart
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInStop
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiInUnprepareHeader
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutCacheDrumPatches
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutCachePatches
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutClose
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutGetDevCapsA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutGetDevCapsW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutGetErrorTextA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutGetErrorTextW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutGetID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutGetNumDevs
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutGetVolume
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutLongMsg
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutMessage
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutOpen
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutPrepareHeader
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutReset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutSetVolume
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutShortMsg
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiOutUnprepareHeader
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiStreamClose
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiStreamOpen
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiStreamOut
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiStreamPause
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiStreamPosition
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiStreamProperty
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiStreamRestart
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _midiStreamStop
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerGetDevCapsA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerGetDevCapsW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerGetID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerGetNumDevs
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerMessage
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmDrvInstall
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmGetCurrentTask
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmTaskBlock
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmTaskCreate
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmTaskSignal
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmTaskYield
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioAdvance
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioAscend
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioClose
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioCreateChunk
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioDescend
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioFlush
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioGetInfo
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioInstallIOProcA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioInstallIOProcW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioOpenA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioOpenW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioRead
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioRenameA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioRenameW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioSeek
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioSendMessage
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioSetBuffer
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioSetInfo
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioStringToFOURCCA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioStringToFOURCCW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmioWrite
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mmsystemGetVersion
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mod32Message
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mxd32Message
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sndPlaySoundA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sndPlaySoundW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tid32Message
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _timeGetDevCaps
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _timeGetSystemTime
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _timeKillEvent
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _timeSetEvent
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInGetDevCapsA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInGetDevCapsW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInGetErrorTextA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInGetErrorTextW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInGetID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInGetNumDevs
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInMessage
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutBreakLoop
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutClose
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutGetDevCapsA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutGetDevCapsW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutGetErrorTextA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutGetErrorTextW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutGetID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutGetNumDevs
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutGetPitch
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutGetPlaybackRate
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutGetVolume
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutMessage
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutOpen
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutPause
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutReset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutRestart
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutSetPitch
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutSetPlaybackRate
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutSetVolume
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutWrite
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wid32Message
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _winmmDbgOut
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _winmmSetDebugLevel
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wod32Message
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInGetPosition
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _timeBeginPeriod
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _timeEndPeriod
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerSetControlDetails
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerOpen
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerClose
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerGetLineInfoA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerGetLineInfoW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerGetLineControlsA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerGetLineControlsW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerGetControlDetailsA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _mixerGetControlDetailsW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutGetPosition
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutPrepareHeader
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveOutUnprepareHeader
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _CloseDriver
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DefDriverProc
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DriverCallback
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DrvGetModuleHandle
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GetDriverModuleHandle
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _MigrateAllDrivers
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _MigrateSoundEvents
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _NotifyCallbackData
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _OpenDriver
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PlaySound
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PlaySoundA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PlaySoundW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SendDriverMessage
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WOW32DriverCallback
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WOW32ResolveMultiMediaHandle
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WOWAppExit
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WinmmLogoff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _WinmmLogon
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _aux32Message
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _auxGetDevCapsA
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _auxGetDevCapsW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _auxGetNumDevs
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _auxGetVolume
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _auxOutMessage
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _auxSetVolume
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _joy32Message
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _timeGetTime
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _joyGetDevCapsW
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _joyGetPos
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gfxAddGfx
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gfxBatchChange
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gfxCreateGfxFactoriesList
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gfxCreateZoneFactoriesList
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gfxDestroyDeviceInterfaceList
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gfxEnumerateGfxs
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __gfxLogoff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __gfxLogon
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gfxModifyGfx
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gfxOpenGfx
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gfxRemoveGfx
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInAddBuffer
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInClose
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInOpen
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInPrepareHeader
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInStart
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInStop
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInUnprepareHeader
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _waveInReset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pos@?1??_DebugChangeModPopUp@@9@9
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?mod@?1??_DebugChangeModPopUp@@9@9
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?detect@?1??_DebugChangeModPopUp@@9@9
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_hWinmm
PUBLIC	_hJschpostproc
PUBLIC	_js_data
PUBLIC	_JsChPostProc_selected
_BSS	SEGMENT
_hWinmm	DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_TlsIndex:DWORD
COMM	_DoStartPropo:DWORD
COMM	_path:BYTE:0400H
COMM	_ProcessPulse:DWORD
COMM	_gDebugLevel:DWORD
COMM	_gCtrlLogFile:DWORD
COMM	_gDataLogFile:DWORD
COMM	_gChnlLogFile:DWORD
COMM	_ListProcessPulseFunc:DWORD
_DATA	ENDS
_BSS	SEGMENT
_hJschpostproc DD 01H DUP (?)
_js_data DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pCloseDriver:DWORD
COMM	_pDefDriverProc:DWORD
COMM	_pDriverCallback:DWORD
COMM	_pDrvGetModuleHandle:DWORD
COMM	_pGetDriverModuleHandle:DWORD
COMM	_pMigrateAllDrivers:DWORD
COMM	_pMigrateMidiUser:DWORD
COMM	_pMigrateSoundEvents:DWORD
COMM	_pNotifyCallbackData:DWORD
COMM	_pOpenDriver:DWORD
COMM	_pPlaySound:DWORD
COMM	_pPlaySoundA:DWORD
COMM	_pPlaySoundW:DWORD
COMM	_pSendDriverMessage:DWORD
COMM	_pWOW32DriverCallback:DWORD
COMM	_pWOW32ResolveMultiMediaHandle:DWORD
COMM	_pWOWAppExit:DWORD
COMM	_pWinmmLogoff:DWORD
COMM	_pWinmmLogon:DWORD
COMM	_paux32Message:DWORD
COMM	_pauxGetDevCapsA:DWORD
COMM	_pauxGetDevCapsW:DWORD
COMM	_pauxGetNumDevs:DWORD
COMM	_pauxGetVolume:DWORD
COMM	_pauxOutMessage:DWORD
COMM	_pauxSetVolume:DWORD
COMM	_pjoy32Message:DWORD
COMM	_pjoyConfigChanged:DWORD
COMM	_pjoyGetDevCapsA:DWORD
COMM	_pjoyGetDevCapsW:DWORD
COMM	_pjoyGetNumDevs:DWORD
COMM	_pjoyGetPos:DWORD
COMM	_pjoyGetThreshold:DWORD
COMM	_pjoyReleaseCapture:DWORD
COMM	_pjoySetCapture:DWORD
COMM	_pjoySetThreshold:DWORD
COMM	_pmci32Message:DWORD
COMM	_pmciDriverNotify:DWORD
COMM	_pmciDriverYield:DWORD
COMM	_pmciExecute:DWORD
COMM	_pmciFreeCommandResource:DWORD
COMM	_pmciGetCreatorTask:DWORD
COMM	_pmciGetDeviceIDA:DWORD
COMM	_pmciGetDeviceIDFromElementIDA:DWORD
COMM	_pmciGetDeviceIDFromElementIDW:DWORD
COMM	_pmciGetDeviceIDW:DWORD
COMM	_pmciGetDriverData:DWORD
COMM	_pmciGetErrorStringA:DWORD
COMM	_pmciGetErrorStringW:DWORD
COMM	_pmciGetYieldProc:DWORD
COMM	_pmciLoadCommandResource:DWORD
COMM	_pmciSendCommandA:DWORD
COMM	_pmciSendCommandW:DWORD
COMM	_pmciSendStringA:DWORD
COMM	_pmciSendStringW:DWORD
COMM	_pmciSetDriverData:DWORD
COMM	_pmciSetYieldProc:DWORD
COMM	_pmid32Message:DWORD
COMM	_pmidiConnect:DWORD
COMM	_pmidiDisconnect:DWORD
COMM	_pmidiInAddBuffer:DWORD
COMM	_pmidiInClose:DWORD
COMM	_pmidiInGetDevCapsA:DWORD
COMM	_pmidiInGetDevCapsW:DWORD
COMM	_pmidiInGetErrorTextA:DWORD
COMM	_pmidiInGetErrorTextW:DWORD
COMM	_pmidiInGetID:DWORD
COMM	_pmidiInGetNumDevs:DWORD
COMM	_pmidiInMessage:DWORD
COMM	_pmidiInOpen:DWORD
COMM	_pmidiInPrepareHeader:DWORD
COMM	_pmidiInReset:DWORD
COMM	_pmidiInStart:DWORD
COMM	_pmidiInStop:DWORD
COMM	_pmidiInUnprepareHeader:DWORD
COMM	_pmidiOutCacheDrumPatches:DWORD
COMM	_pmidiOutCachePatches:DWORD
COMM	_pmidiOutClose:DWORD
COMM	_pmidiOutGetDevCapsA:DWORD
COMM	_pmidiOutGetDevCapsW:DWORD
COMM	_pmidiOutGetErrorTextA:DWORD
COMM	_pmidiOutGetErrorTextW:DWORD
COMM	_pmidiOutGetID:DWORD
COMM	_pmidiOutGetNumDevs:DWORD
COMM	_pmidiOutGetVolume:DWORD
COMM	_pmidiOutLongMsg:DWORD
COMM	_pmidiOutMessage:DWORD
COMM	_pmidiOutOpen:DWORD
COMM	_pmidiOutPrepareHeader:DWORD
COMM	_pmidiOutReset:DWORD
COMM	_pmidiOutSetVolume:DWORD
COMM	_pmidiOutShortMsg:DWORD
COMM	_pmidiOutUnprepareHeader:DWORD
COMM	_pmidiStreamClose:DWORD
COMM	_pmidiStreamOpen:DWORD
COMM	_pmidiStreamOut:DWORD
COMM	_pmidiStreamPause:DWORD
COMM	_pmidiStreamPosition:DWORD
COMM	_pmidiStreamProperty:DWORD
COMM	_pmidiStreamRestart:DWORD
COMM	_pmidiStreamStop:DWORD
COMM	_pmixerClose:DWORD
COMM	_pmixerGetNumDevs:DWORD
COMM	_pmixerGetControlDetailsA:DWORD
COMM	_pmixerGetControlDetailsW:DWORD
COMM	_pmixerGetDevCapsA:DWORD
COMM	_pmixerGetDevCapsW:DWORD
COMM	_pmixerGetID:DWORD
COMM	_pmixerGetLineControlsA:DWORD
COMM	_pmixerGetLineControlsW:DWORD
COMM	_pmixerGetLineInfoA:DWORD
COMM	_pmixerGetLineInfoW:DWORD
COMM	_pmixerMessage:DWORD
COMM	_pmixerOpen:DWORD
COMM	_pmixerSetControlDetails:DWORD
COMM	_pmmDrvInstall:DWORD
COMM	_pmmGetCurrentTask:DWORD
COMM	_pmmTaskBlock:DWORD
COMM	_pmmTaskCreate:DWORD
COMM	_pmmTaskSignal:DWORD
COMM	_pmmTaskYield:DWORD
COMM	_pmmioAdvance:DWORD
COMM	_pmmioAscend:DWORD
COMM	_pmmioClose:DWORD
COMM	_pmmioCreateChunk:DWORD
COMM	_pmmioDescend:DWORD
COMM	_pmmioFlush:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?datacount@?1??ProcessPulseAirPcm1@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pmmioGetInfo:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?bitcount@?1??ProcessPulseAirPcm1@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pmmioInstallIOProcA:DWORD
COMM	_pmmioInstallIOProcW:DWORD
COMM	_pmmioOpenA:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?bitstream@?1??ProcessPulseAirPcm1@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pmmioOpenW:DWORD
COMM	_pmmioRead:DWORD
COMM	_pmmioRenameA:DWORD
COMM	_pmmioRenameW:DWORD
COMM	_pmmioSeek:DWORD
COMM	_pmmioSendMessage:DWORD
COMM	_pmmioSetBuffer:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?i@?1??ProcessPulseAirPcm1@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pmmioSetInfo:DWORD
COMM	_pmmioStringToFOURCCA:DWORD
COMM	_pmmioStringToFOURCCW:DWORD
COMM	_pmmioWrite:DWORD
COMM	_pmmsystemGetVersion:DWORD
COMM	_pmod32Message:DWORD
COMM	_pmxd32Message:DWORD
COMM	_psndPlaySoundA:DWORD
COMM	_psndPlaySoundW:DWORD
COMM	_ptid32Message:DWORD
COMM	_ptimeBeginPeriod:DWORD
COMM	_ptimeEndPeriod:DWORD
COMM	_ptimeGetDevCaps:DWORD
COMM	_ptimeGetSystemTime:DWORD
COMM	_ptimeGetTime:DWORD
COMM	_ptimeKillEvent:DWORD
COMM	_ptimeSetEvent:DWORD
COMM	_pwaveInGetDevCapsA:DWORD
COMM	_pwaveInGetDevCapsW:DWORD
COMM	_pwaveInGetErrorTextA:DWORD
COMM	_pwaveInGetErrorTextW:DWORD
COMM	_pwaveInGetID:DWORD
COMM	_pwaveInGetNumDevs:DWORD
COMM	_pwaveInGetPosition:DWORD
COMM	_pwaveInMessage:DWORD
COMM	_pwaveOutBreakLoop:DWORD
COMM	_pwaveOutClose:DWORD
COMM	_pwaveOutGetDevCapsA:DWORD
COMM	_pwaveOutGetDevCapsW:DWORD
COMM	_pwaveOutGetErrorTextA:DWORD
COMM	_pwaveOutGetErrorTextW:DWORD
COMM	_pwaveOutGetID:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?datacount@?1??ProcessPulseAirPcm2@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pwaveOutGetNumDevs:DWORD
COMM	_pwaveOutGetPitch:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?bitcount@?1??ProcessPulseAirPcm2@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pwaveOutGetPlaybackRate:DWORD
COMM	_pwaveOutGetPosition:DWORD
COMM	_pwaveOutGetVolume:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?bitstream@?1??ProcessPulseAirPcm2@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pwaveOutMessage:DWORD
COMM	_pwaveOutOpen:DWORD
COMM	_pwaveOutPause:DWORD
COMM	_pwaveOutPrepareHeader:DWORD
COMM	_pwaveOutReset:DWORD
COMM	_pwaveOutRestart:DWORD
COMM	_pwaveOutSetPitch:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?i@?1??ProcessPulseAirPcm2@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pwaveOutSetPlaybackRate:DWORD
COMM	_pwaveOutSetVolume:DWORD
COMM	_pwaveOutUnprepareHeader:DWORD
COMM	_pwaveOutWrite:DWORD
COMM	_pwid32Message:DWORD
COMM	_pwinmmDbgOut:DWORD
COMM	_pwinmmSetDebugLevel:DWORD
COMM	_pwod32Message:DWORD
COMM	_pwaveInReset:DWORD
COMM	_ppogoff:DWORD
COMM	_ppogon:DWORD
COMM	_pgfxAddGfx:DWORD
COMM	_pgfxBatchChange:DWORD
COMM	_pgfxCreateGfxFactoriesList:DWORD
COMM	_pgfxCreateZoneFactoriesList:DWORD
COMM	_pgfxDestroyDeviceInterfaceList:DWORD
COMM	_pgfxEnumerateGfxs:DWORD
COMM	_p_gfxLogoff:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?sync@?1??ProcessPulseJrPcm@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_p_gfxLogon:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?bitcount@?1??ProcessPulseJrPcm@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pgfxModifyGfx:DWORD
COMM	_pgfxOpenGfx:DWORD
COMM	_pgfxRemoveGfx:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?bitstream@?1??ProcessPulseJrPcm@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pwaveInAddBuffer:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?datacount@?1??ProcessPulseJrPcm@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pwaveInClose:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?i@?1??ProcessPulseJrPcm@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pwaveInOpen:DWORD
COMM	_pwaveInPrepareHeader:DWORD
COMM	_pwaveInStart:DWORD
COMM	_pwaveInStop:DWORD
COMM	_pwaveInUnprepareHeader:DWORD
COMM	_pjoyGetPosEx:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?sync@?1??ProcessPulseFutabaPcm@@9@9 DD 01H DUP (?)
_?bit@?1??ProcessPulseFutabaPcm@@9@9 DD 01H DUP (?)
_?bitcount@?1??ProcessPulseFutabaPcm@@9@9 DD 01H DUP (?)
_?bitstream@?1??ProcessPulseFutabaPcm@@9@9 DD 01H DUP (?)
_?datacount@?1??ProcessPulseFutabaPcm@@9@9 DD 01H DUP (?)
_?i@?1??ProcessPulseFutabaPcm@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_gpSharedBlock:DWORD
COMM	_ghDataLock:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?sync@?1??ProcessPulsePpm@@9@9 DD 01H DUP (?)
_?datacount@?1??ProcessPulsePpm@@9@9 DD 01H DUP (?)
_?former_sync@?1??ProcessPulsePpm@@9@9 DD 01H DUP (?)
_?i@?1??ProcessPulsePpm@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_GetDllVersion:DWORD
COMM	_ProcessChannels:DWORD
COMM	_pGetNumberOfFilters:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?sync@?1??ProcessPulseFutabaPpm@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pGetFilterNameByIndex:DWORD
COMM	_pGetFilterIdByIndex:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?datacount@?1??ProcessPulseFutabaPpm@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pSelectFilterByIndex:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?former_sync@?1??ProcessPulseFutabaPpm@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pGetIndexOfSelectedFilter:DWORD
_DATA	ENDS
_BSS	SEGMENT
_?i@?1??ProcessPulseFutabaPpm@@9@9 DD 01H DUP (?)
_?sync@?1??ProcessPulseJrPpm@@9@9 DD 01H DUP (?)
_?datacount@?1??ProcessPulseJrPpm@@9@9 DD 01H DUP (?)
_?former_sync@?1??ProcessPulseJrPpm@@9@9 DD 01H DUP (?)
_?i@?1??ProcessPulseJrPpm@@9@9 DD 01H DUP (?)
_?min@?1??ProcessData@@9@9 DQ 01H DUP (?)
_?max@?1??ProcessData@@9@9 DQ 01H DUP (?)
_?high@?1??ProcessData@@9@9 DD 01H DUP (?)
_?low@?1??ProcessData@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_jr_symbol DD	0ffffffffH
	DD	00H
	DD	010H
	DD	0ffffffffH
	DD	011H
	DD	01aH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	015H
	DD	0aH
	DD	08H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	017H
	DD	0eH
	DD	0cH
	DD	0ffffffffH
	DD	04H
	DD	01bH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	013H
	DD	0fH
	DD	0dH
	DD	0ffffffffH
	DD	05H
	DD	019H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	07H
	DD	01dH
	DD	01fH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	012H
	DD	0bH
	DD	09H
	DD	0ffffffffH
	DD	01H
	DD	018H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	03H
	DD	01cH
	DD	01eH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02H
	DD	014H
	DD	016H
	DD	0ffffffffH
	DD	06H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
_futaba_symbol DD 0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	03fH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	03eH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	027H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	03cH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	03dH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	026H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	03aH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02bH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	03bH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	030H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0aH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	038H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02aH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	022H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	039H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	021H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	031H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	025H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	09H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	034H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	029H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	020H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	028H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	013H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	033H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	023H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	012H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	032H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	011H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	024H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	010H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	08H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	037H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02fH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01bH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02eH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0dH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02dH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01cH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0cH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02cH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	017H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01fH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	016H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0bH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	036H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01aH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0eH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01eH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	06H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01dH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	015H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	07H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	035H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0fH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	04H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	014H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	05H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	019H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	03H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	018H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
_air1_symbol DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02H
	DD	0aH
	DD	08H
	DD	0ffffffffH
	DD	06H
	DD	0eH
	DD	0cH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	05H
	DD	0dH
	DD	04H
	DD	0ffffffffH
	DD	03H
	DD	0bH
	DD	01H
	DD	0ffffffffH
	DD	07H
	DD	0fH
	DD	0ffffffffH
_air1_msb DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	02H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	02H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	03H
	DD	02H
	DD	0ffffffffH
	DD	03H
	DD	03H
	DD	02H
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	03H
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	0ffffffffH
_air2_symbol DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	02H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	0ffffffffH
	DD	03H
_DATA	ENDS
CONST	SEGMENT
_waveBufSize DD	0400H
CONST	ENDS
_DATA	SEGMENT
_JsChPostProc_selected DD 0ffffffffH
_?chunk@?1??ProcessPulseAirPcm1@@9@9 DD 0ffffffffH
_?chunk@?1??ProcessPulseAirPcm2@@9@9 DD 0ffffffffH
_DATA	ENDS
PUBLIC	__ftol2
EXTRN	__ftol:NEAR
EXTRN	__fltused:NEAR
;	COMDAT __ftol2
_TEXT	SEGMENT
_dblSource$ = 8
__ftol2	PROC NEAR					; COMDAT

; 23   : extern long _ftol2( double dblSource ) { return _ftol( dblSource ); }

	mov	eax, DWORD PTR _dblSource$[esp]
	mov	ecx, DWORD PTR _dblSource$[esp-4]
	push	eax
	push	ecx
	call	__ftol
	add	esp, 8
	ret	0
__ftol2	ENDP
_TEXT	ENDS
PUBLIC	__GetDebugLevel
PUBLIC	??_C@_0CP@KNHJ@Software?2Flying?9Model?9Simulator?2@ ; `string'
PUBLIC	??_C@_0M@JIDN@Debug?9Level?$AA@			; `string'
EXTRN	__imp__RegOpenKeyExA@20:NEAR
EXTRN	__imp__RegQueryValueExA@24:NEAR
;	COMDAT ??_C@_0CP@KNHJ@Software?2Flying?9Model?9Simulator?2@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0CP@KNHJ@Software?2Flying?9Model?9Simulator?2@ DB 'Software\Flying-'
	DB	'Model-Simulator\SmartPropoPlus', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@JIDN@Debug?9Level?$AA@
_DATA	SEGMENT
??_C@_0M@JIDN@Debug?9Level?$AA@ DB 'Debug-Level', 00H	; `string'
_DATA	ENDS
;	COMDAT __GetDebugLevel
_TEXT	SEGMENT
_hkSpp$ = -8
_ValueDataSize$ = -12
_level$ = -4
__GetDebugLevel PROC NEAR				; COMDAT

; 31   : {

	sub	esp, 12					; 0000000cH

; 32   : 	LONG res;
; 33   : 	HKEY  hkSpp;
; 34   : 	unsigned long	ValueDataSize;
; 35   : 	unsigned int i=0, index=0;
; 36   : 	int iActive = -1;
; 37   : 	char Active[MAX_VAL_NAME] = "";
; 38   : 	int  level;
; 39   : 
; 40   : 	/* Open SPP  key for data query */
; 41   : 	res = RegOpenKeyEx(HKEY_CURRENT_USER,REG_SPP, 0, KEY_QUERY_VALUE , &hkSpp);

	lea	eax, DWORD PTR _hkSpp$[esp+12]
	push	eax
	push	1
	push	0
	push	OFFSET FLAT:??_C@_0CP@KNHJ@Software?2Flying?9Model?9Simulator?2@ ; `string'
	push	-2147483647				; 80000001H
	call	DWORD PTR __imp__RegOpenKeyExA@20

; 42   : 	if (res != ERROR_SUCCESS)

	test	eax, eax
	je	SHORT $L26896

; 43   : 		return 0;

	xor	eax, eax

; 49   : 		return 0;
; 50   : 
; 51   : 	return level;
; 52   : }

	add	esp, 12					; 0000000cH
	ret	0
$L26896:

; 44   : 
; 45   : 	/* Get Shift data */	
; 46   : 	ValueDataSize = 4;
; 47   : 	res = RegQueryValueEx(hkSpp, DEBUG_LEVEL,  NULL, NULL, (unsigned char *)&level,  &ValueDataSize);

	mov	eax, DWORD PTR _hkSpp$[esp+12]
	lea	ecx, DWORD PTR _ValueDataSize$[esp+12]
	lea	edx, DWORD PTR _level$[esp+12]
	push	ecx
	push	edx
	push	0
	push	0
	push	OFFSET FLAT:??_C@_0M@JIDN@Debug?9Level?$AA@ ; `string'
	push	eax
	mov	DWORD PTR _ValueDataSize$[esp+36], 4
	call	DWORD PTR __imp__RegQueryValueExA@24

; 48   : 	if (res != ERROR_SUCCESS)

	mov	ecx, DWORD PTR _level$[esp+12]
	neg	eax
	sbb	eax, eax
	not	eax
	and	eax, ecx

; 49   : 		return 0;
; 50   : 
; 51   : 	return level;
; 52   : }

	add	esp, 12					; 0000000cH
	ret	0
__GetDebugLevel ENDP
_TEXT	ENDS
PUBLIC	__DebugWelcomePopUp
PUBLIC	??_C@_0CJ@CECA@SmartPropoPlus?5Version?5?$CFx?6Debug?5@ ; `string'
PUBLIC	??_C@_0BC@HBCE@?$CFs?6Modulation?3?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0P@IEIB@?$CFs?7Auto?9Detect?$AA@		; `string'
PUBLIC	??_C@_0BC@JFKH@?$CFs?7Positive?5Shift?$AA@	; `string'
PUBLIC	??_C@_0BC@EHBF@?$CFs?7Negative?5Shift?$AA@	; `string'
PUBLIC	??_C@_04FEEL@TEMP?$AA@				; `string'
PUBLIC	??_C@_0N@GEPJ@SPP_ctrl?4log?$AA@		; `string'
PUBLIC	??_C@_05KEJO@?$CFs?2?$CFs?$AA@			; `string'
PUBLIC	??_C@_01LLF@w?$AA@				; `string'
PUBLIC	??_C@_0EK@MKDA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ ; `string'
PUBLIC	??_C@_0BB@DNIN@?$CFs?5?9?5?$CFs?6?$CFs?6?6?$CFs?6?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@NMI@?$CFs?6?6Control?9Flow?5logfile?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BM@IKMO@?$CFs?6?6Cannot?5open?5logfile?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0N@LNPD@SPP_data?4log?$AA@		; `string'
PUBLIC	??_C@_0BK@FELG@?$CFs?6?6Data?9Flow?5logfile?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BN@KJAH@SmartPropoPlus?5Debug?5Message?$AA@ ; `string'
EXTRN	_getenv:NEAR
EXTRN	__imp__MessageBoxA@16:NEAR
EXTRN	__strdate:NEAR
EXTRN	__strtime:NEAR
EXTRN	__chkstk:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fprintf:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_0CJ@CECA@SmartPropoPlus?5Version?5?$CFx?6Debug?5@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0CJ@CECA@SmartPropoPlus?5Version?5?$CFx?6Debug?5@ DB 'SmartPropoPlu'
	DB	's Version %x', 0aH, 'Debug level %d', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@HBCE@?$CFs?6Modulation?3?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BC@HBCE@?$CFs?6Modulation?3?5?$CFs?$AA@ DB '%s', 0aH, 'Modulation:'
	DB	' %s', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@IEIB@?$CFs?7Auto?9Detect?$AA@
_DATA	SEGMENT
??_C@_0P@IEIB@?$CFs?7Auto?9Detect?$AA@ DB '%s', 09H, 'Auto-Detect', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@JFKH@?$CFs?7Positive?5Shift?$AA@
_DATA	SEGMENT
??_C@_0BC@JFKH@?$CFs?7Positive?5Shift?$AA@ DB '%s', 09H, 'Positive Shift', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@EHBF@?$CFs?7Negative?5Shift?$AA@
_DATA	SEGMENT
??_C@_0BC@EHBF@?$CFs?7Negative?5Shift?$AA@ DB '%s', 09H, 'Negative Shift', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04FEEL@TEMP?$AA@
_DATA	SEGMENT
??_C@_04FEEL@TEMP?$AA@ DB 'TEMP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@GEPJ@SPP_ctrl?4log?$AA@
_DATA	SEGMENT
??_C@_0N@GEPJ@SPP_ctrl?4log?$AA@ DB 'SPP_ctrl.log', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KEJO@?$CFs?2?$CFs?$AA@
_DATA	SEGMENT
??_C@_05KEJO@?$CFs?2?$CFs?$AA@ DB '%s\%s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01LLF@w?$AA@
_DATA	SEGMENT
??_C@_01LLF@w?$AA@ DB 'w', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EK@MKDA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@
_DATA	SEGMENT
??_C@_0EK@MKDA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ DB '*'
	DB	'*************************************************************'
	DB	'***********', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DNIN@?$CFs?5?9?5?$CFs?6?$CFs?6?6?$CFs?6?6?$AA@
_DATA	SEGMENT
??_C@_0BB@DNIN@?$CFs?5?9?5?$CFs?6?$CFs?6?6?$CFs?6?6?$AA@ DB '%s - %s', 0aH
	DB	'%s', 0aH, 0aH, '%s', 0aH, 0aH, 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@NMI@?$CFs?6?6Control?9Flow?5logfile?3?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BN@NMI@?$CFs?6?6Control?9Flow?5logfile?3?5?$CFs?$AA@ DB '%s', 0aH, 0aH
	DB	'Control-Flow logfile: %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@IKMO@?$CFs?6?6Cannot?5open?5logfile?3?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BM@IKMO@?$CFs?6?6Cannot?5open?5logfile?3?5?$CFs?$AA@ DB '%s', 0aH, 0aH
	DB	'Cannot open logfile: %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@LNPD@SPP_data?4log?$AA@
_DATA	SEGMENT
??_C@_0N@LNPD@SPP_data?4log?$AA@ DB 'SPP_data.log', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@FELG@?$CFs?6?6Data?9Flow?5logfile?3?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BK@FELG@?$CFs?6?6Data?9Flow?5logfile?3?5?$CFs?$AA@ DB '%s', 0aH, 0aH
	DB	'Data-Flow logfile: %s', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@KJAH@SmartPropoPlus?5Debug?5Message?$AA@
_DATA	SEGMENT
??_C@_0BN@KJAH@SmartPropoPlus?5Debug?5Message?$AA@ DB 'SmartPropoPlus Deb'
	DB	'ug Message', 00H				; `string'
_DATA	ENDS
;	COMDAT __DebugWelcomePopUp
_TEXT	SEGMENT
_Modulation$ = 8
_msg$ = -4000
_CtrlLogFileName$ = -4512
_DataLogFileName$ = -4256
_dbuffer$ = -4524
_tbuffer$ = -4536
__DebugWelcomePopUp PROC NEAR				; COMDAT

; 55   : {

	mov	eax, 4536				; 000011b8H
	call	__chkstk

; 56   : 
; 57   : 	char msg[4000];
; 58   : 	char CtrlLogFileName[255];
; 59   : 	char DataLogFileName[255];
; 60   :    char dbuffer [9];
; 61   :    char tbuffer [9];
; 62   : 
; 63   : 	if (!gDebugLevel)

	mov	eax, DWORD PTR _gDebugLevel
	test	eax, eax
	je	$L26905
	push	esi

; 64   : 		return;
; 65   : 
; 66   : 	sprintf(msg, "SmartPropoPlus Version %x\nDebug level %d",VER_DLL,gDebugLevel);

	push	eax
	push	197376					; 00030300H
	lea	eax, DWORD PTR _msg$[esp+4548]
	push	OFFSET FLAT:??_C@_0CJ@CECA@SmartPropoPlus?5Version?5?$CFx?6Debug?5@ ; `string'
	push	eax
	call	_sprintf

; 67   : 
; 68   : 	if (Modulation)

	mov	esi, DWORD PTR _Modulation$[esp+4552]
	add	esp, 16					; 00000010H
	test	esi, esi
	je	$L26921

; 69   : 		sprintf(msg, "%s\nModulation: %s", msg, Modulation->ModulationList[Modulation->Active]->ModTypeInternal);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+ecx*4]
	lea	edx, DWORD PTR _msg$[esp+4540]
	mov	ecx, DWORD PTR [eax]
	lea	eax, DWORD PTR _msg$[esp+4540]
	push	ecx
	push	edx
	push	OFFSET FLAT:??_C@_0BC@HBCE@?$CFs?6Modulation?3?5?$CFs?$AA@ ; `string'
	push	eax
	call	_sprintf

; 70   : 
; 71   : 	if (Modulation)
; 72   : 	{
; 73   : 		if (Modulation->ShiftAutoDetect)

	mov	eax, DWORD PTR [esi+12]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $L26916

; 74   : 			sprintf(msg, "%s\tAuto-Detect", msg);

	lea	ecx, DWORD PTR _msg$[esp+4540]
	lea	edx, DWORD PTR _msg$[esp+4540]
	push	ecx
	push	OFFSET FLAT:??_C@_0P@IEIB@?$CFs?7Auto?9Detect?$AA@ ; `string'
	push	edx

; 75   : 		else

	jmp	SHORT $L29271
$L26916:

; 76   : 		{
; 77   : 			if (Modulation->PositiveShift)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $L26919

; 78   : 				sprintf(msg, "%s\tPositive Shift", msg);

	lea	eax, DWORD PTR _msg$[esp+4540]
	lea	ecx, DWORD PTR _msg$[esp+4540]
	push	eax
	push	OFFSET FLAT:??_C@_0BC@JFKH@?$CFs?7Positive?5Shift?$AA@ ; `string'
	push	ecx

; 79   : 			else

	jmp	SHORT $L29271
$L26919:

; 80   : 				sprintf(msg, "%s\tNegative Shift", msg);

	lea	edx, DWORD PTR _msg$[esp+4540]
	lea	eax, DWORD PTR _msg$[esp+4540]
	push	edx
	push	OFFSET FLAT:??_C@_0BC@EHBF@?$CFs?7Negative?5Shift?$AA@ ; `string'
	push	eax
$L29271:
	call	_sprintf
	add	esp, 12					; 0000000cH
$L26921:

; 81   : 		};
; 82   : 	}
; 83   : 
; 84   : 	if (gDebugLevel>1 && getenv("TEMP"))

	mov	eax, DWORD PTR _gDebugLevel
	mov	esi, 1
	cmp	eax, esi
	jle	$L26932
	push	OFFSET FLAT:??_C@_04FEEL@TEMP?$AA@	; `string'
	call	_getenv
	add	esp, 4
	test	eax, eax
	je	$L26932

; 85   : 	{
; 86   : 		/* Create a Control-flow log file */
; 87   : 		sprintf(CtrlLogFileName,"%s\\%s", getenv("TEMP"), CTRL_LOG_FILE);

	push	OFFSET FLAT:??_C@_0N@GEPJ@SPP_ctrl?4log?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04FEEL@TEMP?$AA@	; `string'
	call	_getenv
	add	esp, 4
	lea	ecx, DWORD PTR _CtrlLogFileName$[esp+4544]
	push	eax
	push	OFFSET FLAT:??_C@_05KEJO@?$CFs?2?$CFs?$AA@ ; `string'
	push	ecx
	call	_sprintf

; 88   : 		gCtrlLogFile = fopen(CtrlLogFileName, "w");

	lea	edx, DWORD PTR _CtrlLogFileName$[esp+4556]
	push	OFFSET FLAT:??_C@_01LLF@w?$AA@		; `string'
	push	edx
	call	_fopen
	add	esp, 24					; 00000018H
	mov	DWORD PTR _gCtrlLogFile, eax

; 89   : 		if (gCtrlLogFile)

	test	eax, eax
	je	$L26928

; 90   : 		{
; 91   : 			fprintf(gCtrlLogFile, "%s - %s\n%s\n\n%s\n\n", _strdate( dbuffer ), _strtime( tbuffer ), msg, SEPARATOR);

	lea	eax, DWORD PTR _msg$[esp+4540]
	push	OFFSET FLAT:??_C@_0EK@MKDA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ ; `string'
	lea	ecx, DWORD PTR _tbuffer$[esp+4544]
	push	eax
	push	ecx
	call	__strtime
	add	esp, 4
	lea	edx, DWORD PTR _dbuffer$[esp+4548]
	push	eax
	push	edx
	call	__strdate
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _gCtrlLogFile
	push	OFFSET FLAT:??_C@_0BB@DNIN@?$CFs?5?9?5?$CFs?6?$CFs?6?6?$CFs?6?6?$AA@ ; `string'
	push	eax
	call	_fprintf

; 92   : 			sprintf(msg, "%s\n\nControl-Flow logfile: %s", msg,CtrlLogFileName);

	lea	ecx, DWORD PTR _CtrlLogFileName$[esp+4564]
	lea	edx, DWORD PTR _msg$[esp+4564]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _msg$[esp+4572]
	push	OFFSET FLAT:??_C@_0BN@NMI@?$CFs?6?6Control?9Flow?5logfile?3?5?$CFs?$AA@ ; `string'
	push	eax
	call	_sprintf
	add	esp, 40					; 00000028H
$L26932:

; 93   : 		}
; 94   : 		else
; 95   : 		{
; 96   : 			sprintf(msg, "%s\n\nCannot open logfile: %s", msg,CtrlLogFileName);
; 97   : 			gDebugLevel=1;
; 98   : 		}
; 99   : 	};
; 100  : 
; 101  : 	if (gDebugLevel>2 && getenv("TEMP"))

	cmp	DWORD PTR _gDebugLevel, 2
	jle	$L26938
	push	OFFSET FLAT:??_C@_04FEEL@TEMP?$AA@	; `string'
	call	_getenv
	add	esp, 4
	test	eax, eax
	je	$L26938

; 102  : 	{
; 103  : 		/* Create a Data-flow log file */
; 104  : 		sprintf(DataLogFileName,"%s\\%s", getenv("TEMP"), DATA_LOG_FILE);

	push	OFFSET FLAT:??_C@_0N@LNPD@SPP_data?4log?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04FEEL@TEMP?$AA@	; `string'
	call	_getenv
	add	esp, 4
	lea	ecx, DWORD PTR _DataLogFileName$[esp+4544]
	push	eax
	push	OFFSET FLAT:??_C@_05KEJO@?$CFs?2?$CFs?$AA@ ; `string'
	push	ecx
	call	_sprintf

; 105  : 		gDataLogFile = fopen(DataLogFileName, "w");

	lea	edx, DWORD PTR _DataLogFileName$[esp+4556]
	push	OFFSET FLAT:??_C@_01LLF@w?$AA@		; `string'
	push	edx
	call	_fopen
	add	esp, 24					; 00000018H
	mov	DWORD PTR _gDataLogFile, eax

; 106  : 		if (gDataLogFile)

	test	eax, eax
	je	SHORT $L26928

; 107  : 		{
; 108  : 			fprintf(gDataLogFile, "%s - %s\n%s\n\n%s\n\n", _strdate( dbuffer ), _strtime( tbuffer ), msg, SEPARATOR);

	lea	eax, DWORD PTR _msg$[esp+4540]
	push	OFFSET FLAT:??_C@_0EK@MKDA@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK@ ; `string'
	lea	ecx, DWORD PTR _tbuffer$[esp+4544]
	push	eax
	push	ecx
	call	__strtime
	add	esp, 4
	lea	edx, DWORD PTR _dbuffer$[esp+4548]
	push	eax
	push	edx
	call	__strdate
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _gDataLogFile
	push	OFFSET FLAT:??_C@_0BB@DNIN@?$CFs?5?9?5?$CFs?6?$CFs?6?6?$CFs?6?6?$AA@ ; `string'
	push	eax
	call	_fprintf

; 109  : 			sprintf(msg, "%s\n\nData-Flow logfile: %s", msg,DataLogFileName);

	lea	ecx, DWORD PTR _DataLogFileName$[esp+4564]
	lea	edx, DWORD PTR _msg$[esp+4564]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _msg$[esp+4572]
	push	OFFSET FLAT:??_C@_0BK@FELG@?$CFs?6?6Data?9Flow?5logfile?3?5?$CFs?$AA@ ; `string'
	push	eax
	call	_sprintf
	add	esp, 40					; 00000028H

; 110  : 		}		
; 111  : 		else

	jmp	SHORT $L26938
$L26928:

; 112  : 		{
; 113  : 			sprintf(msg, "%s\n\nCannot open logfile: %s", msg,CtrlLogFileName);

	lea	ecx, DWORD PTR _CtrlLogFileName$[esp+4540]
	lea	edx, DWORD PTR _msg$[esp+4540]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _msg$[esp+4548]
	push	OFFSET FLAT:??_C@_0BM@IKMO@?$CFs?6?6Cannot?5open?5logfile?3?5?$CFs?$AA@ ; `string'
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 114  : 			gDebugLevel=1;

	mov	DWORD PTR _gDebugLevel, esi
$L26938:

; 115  : 		}
; 116  : 
; 117  : 	};
; 118  : 
; 119  : 	MessageBox(NULL,msg, "SmartPropoPlus Debug Message" , MB_SYSTEMMODAL);

	push	4096					; 00001000H
	lea	ecx, DWORD PTR _msg$[esp+4544]
	push	OFFSET FLAT:??_C@_0BN@KJAH@SmartPropoPlus?5Debug?5Message?$AA@ ; `string'
	push	ecx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	pop	esi
$L26905:

; 120  : }

	add	esp, 4536				; 000011b8H
	ret	0
__DebugWelcomePopUp ENDP
_TEXT	ENDS
PUBLIC	_Message
PUBLIC	??_C@_0CE@IKNH@?$CFs?6Error?3?5?$CFd?5?$CFs?6?$AN?$ANFile?3?5?$CFs?$CILine?5@ ; `string'
PUBLIC	??_C@_0BH@NKNB@?$CFs?6?$AN?$ANFile?3?5?$CFs?$CILine?5?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BH@IPMD@SmartPropoPlus?5Message?$AA@	; `string'
EXTRN	__imp__FormatMessageA@28:NEAR
EXTRN	__imp__GetLastError@0:NEAR
;	COMDAT ??_C@_0CE@IKNH@?$CFs?6Error?3?5?$CFd?5?$CFs?6?$AN?$ANFile?3?5?$CFs?$CILine?5@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0CE@IKNH@?$CFs?6Error?3?5?$CFd?5?$CFs?6?$AN?$ANFile?3?5?$CFs?$CILine?5@ DB '%'
	DB	's', 0aH, 'Error: %d %s', 0aH, 0dH, 0dH, 'File: %s(Line %d)', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NKNB@?$CFs?6?$AN?$ANFile?3?5?$CFs?$CILine?5?$CFd?$CJ?$AA@
_DATA	SEGMENT
??_C@_0BH@NKNB@?$CFs?6?$AN?$ANFile?3?5?$CFs?$CILine?5?$CFd?$CJ?$AA@ DB '%'
	DB	's', 0aH, 0dH, 0dH, 'File: %s(Line %d)', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IPMD@SmartPropoPlus?5Message?$AA@
_DATA	SEGMENT
??_C@_0BH@IPMD@SmartPropoPlus?5Message?$AA@ DB 'SmartPropoPlus Message', 00H ; `string'
_DATA	ENDS
;	COMDAT _Message
_TEXT	SEGMENT
_in_msg$ = 8
_type$ = 12
_file_name$ = 16
_line_number$ = 20
_lpMsgBuf$ = -4004
_msg$ = -4000
_Message PROC NEAR					; COMDAT

; 175  : {

	sub	esp, 4004				; 00000fa4H
	push	esi

; 176  : 	int out, errNum;
; 177  : 	LPVOID lpMsgBuf;
; 178  : 	char msg[4000];
; 179  : 	
; 180  : 	errNum = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	esi, eax

; 181  : 	if (errNum)

	test	esi, esi
	je	SHORT $L27002

; 182  : 	{
; 183  : 		FormatMessage( 	FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
; 184  : 			NULL,errNum,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
; 185  : 			(LPTSTR) &lpMsgBuf,0,NULL );

	push	0
	lea	eax, DWORD PTR _lpMsgBuf$[esp+4012]
	push	0
	push	eax
	push	1024					; 00000400H
	push	esi
	push	0
	push	4864					; 00001300H
	call	DWORD PTR __imp__FormatMessageA@28

; 186  : 		sprintf(msg, "%s\nError: %d %s\n\r\rFile: %s(Line %d)", in_msg, errNum, lpMsgBuf, file_name, line_number);

	mov	ecx, DWORD PTR _line_number$[esp+4004]
	mov	edx, DWORD PTR _file_name$[esp+4004]
	mov	eax, DWORD PTR _lpMsgBuf$[esp+4008]
	push	ecx
	mov	ecx, DWORD PTR _in_msg$[esp+4008]
	push	edx
	push	eax
	push	esi
	push	ecx
	lea	edx, DWORD PTR _msg$[esp+4028]
	push	OFFSET FLAT:??_C@_0CE@IKNH@?$CFs?6Error?3?5?$CFd?5?$CFs?6?$AN?$ANFile?3?5?$CFs?$CILine?5@ ; `string'
	push	edx
	call	_sprintf
	add	esp, 28					; 0000001cH

; 187  : 	}
; 188  : 	else

	jmp	SHORT $L27009
$L27002:

; 189  : 		sprintf(msg, "%s\n\r\rFile: %s(Line %d)", in_msg, file_name, line_number);

	mov	eax, DWORD PTR _line_number$[esp+4004]
	mov	ecx, DWORD PTR _file_name$[esp+4004]
	mov	edx, DWORD PTR _in_msg$[esp+4004]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR _msg$[esp+4020]
	push	OFFSET FLAT:??_C@_0BH@NKNB@?$CFs?6?$AN?$ANFile?3?5?$CFs?$CILine?5?$CFd?$CJ?$AA@ ; `string'
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H
$L27009:

; 190  : 
; 191  : 	
; 192  : 	out = MessageBox(NULL,msg, "SmartPropoPlus Message" , MB_SYSTEMMODAL | type);

	mov	ecx, DWORD PTR _type$[esp+4004]
	lea	edx, DWORD PTR _msg$[esp+4008]
	or	ch, 16					; 00000010H
	push	ecx
	push	OFFSET FLAT:??_C@_0BH@IPMD@SmartPropoPlus?5Message?$AA@ ; `string'
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	pop	esi

; 193  : 	return out;
; 194  : }

	add	esp, 4004				; 00000fa4H
	ret	0
_Message ENDP
_TEXT	ENDS
PUBLIC	_LoadOrigDll
PUBLIC	??_C@_0CJ@OOJL@C?3?2Code?2SmartPropoPlus?2330?2Winmm@ ; `string'
PUBLIC	??_C@_0CG@EIEO@LoadOrigDll?$CI?$CJ?3?5File?5to?5load?5is?5?$CI@ ; `string'
PUBLIC	??_C@_0DB@EMCB@LoadOrigDll?$CI?$CJ?3?5Cannot?5get?5attrib@ ; `string'
PUBLIC	??_C@_0CO@KOE@LoadOrigDll?$CI?$CFd?$CJ?3?6?$ANCannot?5load?5Fi@ ; `string'
EXTRN	__imp__LoadLibraryA@4:NEAR
EXTRN	__imp__LoadLibraryExA@12:NEAR
EXTRN	__imp__GetFileAttributesExA@12:NEAR
;	COMDAT ??_C@_0CJ@OOJL@C?3?2Code?2SmartPropoPlus?2330?2Winmm@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0CJ@OOJL@C?3?2Code?2SmartPropoPlus?2330?2Winmm@ DB 'C:\Code\SmartPr'
	DB	'opoPlus\330\Winmm\winmm.c', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@EIEO@LoadOrigDll?$CI?$CJ?3?5File?5to?5load?5is?5?$CI@
_DATA	SEGMENT
??_C@_0CG@EIEO@LoadOrigDll?$CI?$CJ?3?5File?5to?5load?5is?5?$CI@ DB 'LoadO'
	DB	'rigDll(): File to load is (NULL)', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DB@EMCB@LoadOrigDll?$CI?$CJ?3?5Cannot?5get?5attrib@
_DATA	SEGMENT
??_C@_0DB@EMCB@LoadOrigDll?$CI?$CJ?3?5Cannot?5get?5attrib@ DB 'LoadOrigDl'
	DB	'l(): Cannot get attributes for File %s', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CO@KOE@LoadOrigDll?$CI?$CFd?$CJ?3?6?$ANCannot?5load?5Fi@
_DATA	SEGMENT
??_C@_0CO@KOE@LoadOrigDll?$CI?$CFd?$CJ?3?6?$ANCannot?5load?5Fi@ DB 'LoadO'
	DB	'rigDll(%d):', 0aH, 0dH, 'Cannot load File %s, Retry?', 00H ; `string'
_DATA	ENDS
;	COMDAT _LoadOrigDll
_TEXT	SEGMENT
_dll$ = 8
_line$ = 12
_Attribs$ = -4036
_msg$ = -4000
_LoadOrigDll PROC NEAR					; COMDAT

; 199  : {

	sub	esp, 4036				; 00000fc4H
	push	esi

; 200  : 	HINSTANCE h;
; 201  : 	BOOL attribsOK;
; 202  : 	WIN32_FILE_ATTRIBUTE_DATA Attribs;
; 203  : 	char msg[4000];
; 204  : 	int res;
; 205  : 	
; 206  : 	if (!dll)

	mov	esi, DWORD PTR _dll$[esp+4036]
	test	esi, esi
	jne	SHORT $L27024

; 207  : 	{
; 208  : 		MESSAGE("LoadOrigDll(): File to load is (NULL)", MB_ICONERROR);

	push	208					; 000000d0H
	push	OFFSET FLAT:??_C@_0CJ@OOJL@C?3?2Code?2SmartPropoPlus?2330?2Winmm@ ; `string'
	push	16					; 00000010H
	push	OFFSET FLAT:??_C@_0CG@EIEO@LoadOrigDll?$CI?$CJ?3?5File?5to?5load?5is?5?$CI@ ; `string'
	call	_Message
	add	esp, 16					; 00000010H

; 209  : 		return NULL;

	xor	eax, eax
	pop	esi

; 234  : }

	add	esp, 4036				; 00000fc4H
	ret	0
$L27024:

; 210  : 	};
; 211  : 
; 212  : 	attribsOK = GetFileAttributesEx(dll, GetFileExInfoStandard, &Attribs);

	lea	eax, DWORD PTR _Attribs$[esp+4040]
	push	eax
	push	0
	push	esi
	call	DWORD PTR __imp__GetFileAttributesExA@12

; 213  : 	if (!attribsOK)

	test	eax, eax
	jne	SHORT $L27028

; 214  : 	{
; 215  : 		sprintf(msg, "LoadOrigDll(): Cannot get attributes for File %s", dll);

	push	esi
	lea	ecx, DWORD PTR _msg$[esp+4044]
	push	OFFSET FLAT:??_C@_0DB@EMCB@LoadOrigDll?$CI?$CJ?3?5Cannot?5get?5attrib@ ; `string'
	push	ecx
	call	_sprintf

; 216  : 		MESSAGE(msg, MB_ICONERROR);

	push	216					; 000000d8H
	push	OFFSET FLAT:??_C@_0CJ@OOJL@C?3?2Code?2SmartPropoPlus?2330?2Winmm@ ; `string'
	lea	edx, DWORD PTR _msg$[esp+4060]
	push	16					; 00000010H
	push	edx
	call	_Message
	add	esp, 28					; 0000001cH
$L27028:
	push	ebx
	push	ebp
	push	edi

; 217  : 	};
; 218  : 
; 219  : 	h = LoadLibrary(dll);

	push	esi
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	edi, eax

; 220  : 	while (!h)

	test	edi, edi
	jne	SHORT $L29277
	mov	ebx, DWORD PTR _line$[esp+4048]
	mov	ebp, DWORD PTR __imp__LoadLibraryExA@12
$L27031:

; 221  : 	{
; 222  : 		h = LoadLibraryEx(dll, NULL, 0);

	push	0
	push	0
	push	esi
	call	ebp
	mov	edi, eax

; 223  : 		if (!h)

	test	edi, edi
	jne	SHORT $L29277

; 224  : 		{
; 225  : 
; 226  : 			sprintf(msg, "LoadOrigDll(%d):\n\rCannot load File %s, Retry?", line, dll);

	push	esi
	push	ebx
	lea	eax, DWORD PTR _msg$[esp+4060]
	push	OFFSET FLAT:??_C@_0CO@KOE@LoadOrigDll?$CI?$CFd?$CJ?3?6?$ANCannot?5load?5Fi@ ; `string'
	push	eax
	call	_sprintf

; 227  : 			res = MESSAGE(msg, MB_YESNO | MB_ICONQUESTION );

	push	227					; 000000e3H
	push	OFFSET FLAT:??_C@_0CJ@OOJL@C?3?2Code?2SmartPropoPlus?2330?2Winmm@ ; `string'
	lea	ecx, DWORD PTR _msg$[esp+4076]
	push	36					; 00000024H
	push	ecx
	call	_Message
	add	esp, 32					; 00000020H

; 228  : 			if (res != IDYES)

	cmp	eax, 6
	je	SHORT $L27031
$L29277:

; 229  : 				break;
; 230  : 		};
; 231  : 	};
; 232  : 
; 233  : 	return h;

	mov	eax, edi
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 234  : }

	add	esp, 4036				; 00000fc4H
	ret	0
_LoadOrigDll ENDP
_TEXT	ENDS
PUBLIC	_StopPropo
PUBLIC	_DllMain@12
EXTRN	__imp__FreeLibrary@4:NEAR
EXTRN	__imp__TlsAlloc@0:NEAR
EXTRN	__imp__TlsGetValue@4:NEAR
;	COMDAT _DllMain@12
_TEXT	SEGMENT
_ul_reason_for_call$ = 12
_DllMain@12 PROC NEAR					; COMDAT

; 242  : 
; 243  :     switch (ul_reason_for_call)
; 244  : 	{

	mov	eax, DWORD PTR _ul_reason_for_call$[esp-4]
	cmp	eax, 3
	ja	SHORT $L27046
	jmp	DWORD PTR $L29280[eax*4]
$L27049:

; 245  : 		case DLL_PROCESS_ATTACH:
; 246  : 			TlsIndex = TlsAlloc();

	call	DWORD PTR __imp__TlsAlloc@0
	mov	DWORD PTR _TlsIndex, eax

; 247  : 			DoStartPropo = TRUE;

	mov	DWORD PTR _DoStartPropo, 1

; 261  :             break;
; 262  :     }
; 263  : 			
; 264  :    return 1;

	mov	eax, 1

; 265  : }

	ret	12					; 0000000cH
$L27050:

; 248  : 			break;
; 249  : 
; 250  :         case DLL_THREAD_ATTACH:
; 251  : 			DoStartPropo = FALSE;

	mov	DWORD PTR _DoStartPropo, 0

; 261  :             break;
; 262  :     }
; 263  : 			
; 264  :    return 1;

	mov	eax, 1

; 265  : }

	ret	12					; 0000000cH
$L27051:

; 252  :             break;
; 253  : 
; 254  :         case DLL_THREAD_DETACH:
; 255  :             FreeLibrary((HINSTANCE)TlsGetValue(TlsIndex));

	mov	eax, DWORD PTR _TlsIndex
	push	eax
	call	DWORD PTR __imp__TlsGetValue@4
	push	eax
	call	DWORD PTR __imp__FreeLibrary@4

; 261  :             break;
; 262  :     }
; 263  : 			
; 264  :    return 1;

	mov	eax, 1

; 265  : }

	ret	12					; 0000000cH
$L27053:

; 256  :             break;
; 257  : 
; 258  :         case DLL_PROCESS_DETACH:
; 259  :             FreeLibrary(hWinmm);

	mov	ecx, DWORD PTR _hWinmm
	push	ecx
	call	DWORD PTR __imp__FreeLibrary@4

; 260  : 			StopPropo();

	call	_StopPropo
$L27046:

; 261  :             break;
; 262  :     }
; 263  : 			
; 264  :    return 1;

	mov	eax, 1

; 265  : }

	ret	12					; 0000000cH
$L29280:
	DD	$L27053
	DD	$L27049
	DD	$L27050
	DD	$L27051
_DllMain@12 ENDP
_TEXT	ENDS
PUBLIC	_WalkeraConvert2Bin
;	COMDAT _WalkeraConvert2Bin
_TEXT	SEGMENT
_width$ = 8
_WalkeraConvert2Bin PROC NEAR				; COMDAT

; 293  : 	switch (width)
; 294  : 	{

	mov	eax, DWORD PTR _width$[esp-4]
	add	eax, -11				; fffffff5H
	cmp	eax, 10					; 0000000aH
	ja	SHORT $L27071
	xor	ecx, ecx
	mov	cl, BYTE PTR $L29283[eax]
	jmp	DWORD PTR $L29284[ecx*4]
$L27072:

; 295  : 		case 11:
; 296  : 		case 12:
; 297  : 		case 13:
; 298  : 		case 14: return 0;
; 299  : 		break;
; 300  : 
; 301  : 
; 302  : 		case 19:
; 303  : 		case 20:
; 304  : 		case 21: return 1;

	mov	al, 1

; 309  : 	}
; 310  : };

	ret	0
$L27071:

; 305  : 		break;
; 306  : 
; 307  : 		default:
; 308  : 			return 0;

	xor	al, al

; 309  : 	}
; 310  : };

	ret	0
	npad	3
$L29284:
	DD	$L27071
	DD	$L27072
	DD	$L27071
$L29283:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
	DB	1
_WalkeraConvert2Bin ENDP
_TEXT	ENDS
PUBLIC	_WalkeraConvert2Oct
;	COMDAT _WalkeraConvert2Oct
_TEXT	SEGMENT
_width$ = 8
_WalkeraConvert2Oct PROC NEAR				; COMDAT

; 315  : 	switch (width)
; 316  : 	{

	mov	eax, DWORD PTR _width$[esp-4]
	add	eax, -11				; fffffff5H
	cmp	eax, 28					; 0000001cH
	ja	SHORT $L27090
	xor	ecx, ecx
	mov	cl, BYTE PTR $L29287[eax]
	jmp	DWORD PTR $L29288[ecx*4]
$L27082:

; 317  : 		case 11:
; 318  : 		case 12:
; 319  : 		case 13:
; 320  : 		case 14: return 0;

	xor	al, al

; 357  : 	};	
; 358  : };

	ret	0
$L27083:

; 321  : 		break;
; 322  : 
; 323  : 		case 17:
; 324  : 		case 18: return 1;

	mov	al, 1

; 357  : 	};	
; 358  : };

	ret	0
$L27084:

; 325  : 		break;
; 326  : 
; 327  : 		case 19:
; 328  : 		case 20:
; 329  : 		case 21: return 2;

	mov	al, 2

; 357  : 	};	
; 358  : };

	ret	0
$L27085:

; 330  : 		break;
; 331  : 
; 332  : 		case 24:
; 333  : 		case 25: return 3;

	mov	al, 3

; 357  : 	};	
; 358  : };

	ret	0
$L27086:

; 334  : 		break;
; 335  : 
; 336  : 		case 27:
; 337  : 		case 28:
; 338  : 		case 29: return 4;

	mov	al, 4

; 357  : 	};	
; 358  : };

	ret	0
$L27087:

; 339  : 		break;
; 340  : 
; 341  : 		case 30:
; 342  : 		case 31:
; 343  : 		case 32: return 5;

	mov	al, 5

; 357  : 	};	
; 358  : };

	ret	0
$L27088:

; 344  : 		break;
; 345  : 
; 346  : 		case 34:
; 347  : 		case 35:
; 348  : 		case 36: return 6;

	mov	al, 6

; 357  : 	};	
; 358  : };

	ret	0
$L27089:

; 349  : 		break;
; 350  : 
; 351  : 		case 38:
; 352  : 		case 39: return 7;

	mov	al, 7

; 357  : 	};	
; 358  : };

	ret	0
$L27090:

; 353  : 		break;
; 354  : 
; 355  : 		default:
; 356  : 			return 8; /* Illegal value */

	mov	al, 8

; 357  : 	};	
; 358  : };

	ret	0
	npad	2
$L29288:
	DD	$L27082
	DD	$L27083
	DD	$L27084
	DD	$L27085
	DD	$L27086
	DD	$L27087
	DD	$L27088
	DD	$L27089
	DD	$L27090
$L29287:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	8
	DB	8
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	8
	DB	8
	DB	3
	DB	3
	DB	8
	DB	4
	DB	4
	DB	4
	DB	5
	DB	5
	DB	5
	DB	8
	DB	6
	DB	6
	DB	6
	DB	8
	DB	7
	DB	7
_WalkeraConvert2Oct ENDP
_TEXT	ENDS
PUBLIC	_WalkeraElevator
;	COMDAT _WalkeraElevator
_TEXT	SEGMENT
_cycle$ = 8
_WalkeraElevator PROC NEAR				; COMDAT

; 370  : 	int value;
; 371  : 
; 372  : 	value = cycle[2]*32+cycle[3]*16+cycle[4]*2+cycle[5];

	mov	ecx, DWORD PTR _cycle$[esp-4]
	xor	eax, eax
	xor	edx, edx
	mov	al, BYTE PTR [ecx+2]
	mov	dl, BYTE PTR [ecx+3]
	lea	eax, DWORD PTR [edx+eax*2]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax*8]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+5]
	lea	edx, DWORD PTR [edx+eax*2]

; 373  : 
; 374  : 	/* Mid-point is 255 */
; 375  : 	if(cycle[1])

	mov	al, BYTE PTR [ecx+1]
	test	al, al
	je	SHORT $L27096

; 376  : 		value = 255-value; /* Below */

	mov	eax, 255				; 000000ffH
	sub	eax, edx

; 381  : };

	ret	0
$L27096:

; 377  : 	else
; 378  : 		value = 255+value; /* Above */

	add	edx, 255				; 000000ffH

; 379  : 
; 380  : 	return value;

	mov	eax, edx

; 381  : };

	ret	0
_WalkeraElevator ENDP
_TEXT	ENDS
PUBLIC	_WalkeraAilerons
;	COMDAT _WalkeraAilerons
_TEXT	SEGMENT
_cycle$ = 8
_WalkeraAilerons PROC NEAR				; COMDAT

; 394  : 	int value, left, msb;
; 395  : 
; 396  : 	msb = cycle[6];

	mov	ecx, DWORD PTR _cycle$[esp-4]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+6]

; 397  : 
; 398  : 	/* 
; 399  : 		Strange enough, four ranges mapped by all 8 values 
; 400  : 		Near left:	0 or 4
; 401  : 		Far left:	1 or 5
; 402  : 		Near right:	2 or 6
; 403  : 		Far right:	3 or 7
; 404  : 	*/
; 405  : 
; 406  : 	/* Remove the high numbers */
; 407  : 	if (msb > 3)

	cmp	eax, 3
	jle	SHORT $L27105

; 408  : 		msb-=4;

	sub	eax, 4
$L27105:

; 409  : 
; 410  : 	/* Left or right */
; 411  : 	if (msb <= 1)

	xor	edx, edx
	cmp	eax, 1
	setle	dl
	push	esi

; 412  : 		left = 1;
; 413  : 	else
; 414  : 		left = 0;
; 415  : 
; 416  : 	/* Near or far */
; 417  : 	if (msb > 1)

	cmp	eax, 1
	mov	esi, edx
	jle	SHORT $L27108

; 418  : 		msb-=2;

	sub	eax, 2
$L27108:

; 419  : 
; 420  : 	/* Offset from mid-point */
; 421  : 	value = msb*256+cycle[7]*128+cycle[8]*16+cycle[9]*8+cycle[10];

	xor	edx, edx
	mov	dl, BYTE PTR [ecx+7]
	lea	eax, DWORD PTR [edx+eax*2]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax*8]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+9]
	lea	eax, DWORD PTR [edx+eax*2]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+10]

; 422  : 
; 423  : 	/* Mid-point is 511 */
; 424  : 	if(left)

	test	esi, esi
	lea	eax, DWORD PTR [edx+eax*8]
	pop	esi
	je	SHORT $L27109

; 425  : 		value = 511-value; /* Left */

	mov	ecx, 511				; 000001ffH
	sub	ecx, eax

; 428  : 
; 429  : 	return value;

	mov	eax, ecx

; 430  : };

	ret	0
$L27109:

; 426  : 	else
; 427  : 		value = 511+value; /* Right */

	add	eax, 511				; 000001ffH

; 430  : };

	ret	0
_WalkeraAilerons ENDP
_TEXT	ENDS
PUBLIC	_WalkeraThrottle
;	COMDAT _WalkeraThrottle
_TEXT	SEGMENT
_cycle$ = 8
_WalkeraThrottle PROC NEAR				; COMDAT

; 442  : 	int value;
; 443  : 
; 444  : 	value = cycle[12]*32+cycle[13]*16+cycle[14]*2+cycle[15];

	mov	ecx, DWORD PTR _cycle$[esp-4]
	xor	eax, eax
	xor	edx, edx
	mov	al, BYTE PTR [ecx+12]
	mov	dl, BYTE PTR [ecx+13]
	lea	eax, DWORD PTR [edx+eax*2]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+14]
	lea	eax, DWORD PTR [edx+eax*8]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+15]
	lea	edx, DWORD PTR [edx+eax*2]

; 445  : 
; 446  : 	/* Mid-point is 255 */
; 447  : 	if(cycle[11])

	mov	al, BYTE PTR [ecx+11]
	test	al, al
	je	SHORT $L27116

; 448  : 		value = 255-value; /* Below */

	mov	eax, 255				; 000000ffH
	sub	eax, edx

; 453  : };

	ret	0
$L27116:

; 449  : 	else
; 450  : 		value = 255+value; /* Above */

	add	edx, 255				; 000000ffH

; 451  : 
; 452  : 	return value;

	mov	eax, edx

; 453  : };

	ret	0
_WalkeraThrottle ENDP
_TEXT	ENDS
PUBLIC	_WalkeraRudder
;	COMDAT _WalkeraRudder
_TEXT	SEGMENT
_cycle$ = 8
_WalkeraRudder PROC NEAR				; COMDAT

; 466  : 	int value, left, msb;
; 467  : 
; 468  : 	msb = cycle[16];

	mov	ecx, DWORD PTR _cycle$[esp-4]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+16]

; 469  : 
; 470  : 	/* 
; 471  : 		Strange enough, four ranges mapped by all 8 values 
; 472  : 		Near left:	0 or 4
; 473  : 		Far left:	1 or 5
; 474  : 		Near right:	2 or 6
; 475  : 		Far right:	3 or 7
; 476  : 	*/
; 477  : 
; 478  : 	/* Remove the high numbers */
; 479  : 	if (msb > 3)

	cmp	eax, 3
	jle	SHORT $L27125

; 480  : 		msb-=4;

	sub	eax, 4
$L27125:

; 481  : 
; 482  : 	/* Left or right */
; 483  : 	if (msb <= 1)

	xor	edx, edx
	cmp	eax, 1
	setle	dl
	push	esi

; 484  : 		left = 1;
; 485  : 	else
; 486  : 		left = 0;
; 487  : 
; 488  : 	/* Near or far */
; 489  : 	if (msb > 1)

	cmp	eax, 1
	mov	esi, edx
	jle	SHORT $L27128

; 490  : 		msb-=2;

	sub	eax, 2
$L27128:

; 491  : 
; 492  : 	/* Offset from mid-point */
; 493  : 	value = msb*256+cycle[17]*128+cycle[18]*16+cycle[19]*8+cycle[20];

	xor	edx, edx
	mov	dl, BYTE PTR [ecx+17]
	lea	eax, DWORD PTR [edx+eax*2]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+18]
	lea	eax, DWORD PTR [edx+eax*8]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+19]
	lea	eax, DWORD PTR [edx+eax*2]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+20]

; 494  : 
; 495  : 	/* Mid-point is 511 */
; 496  : 	if(left)

	test	esi, esi
	lea	eax, DWORD PTR [edx+eax*8]
	pop	esi
	je	SHORT $L27129

; 497  : 		value = 511-value; /* Left */

	mov	ecx, 511				; 000001ffH
	sub	ecx, eax

; 500  : 
; 501  : 	return value;

	mov	eax, ecx

; 502  : };

	ret	0
$L27129:

; 498  : 	else
; 499  : 		value = 511+value; /* Right */

	add	eax, 511				; 000001ffH

; 502  : };

	ret	0
_WalkeraRudder ENDP
_TEXT	ENDS
PUBLIC	_WalkeraGear
;	COMDAT _WalkeraGear
_TEXT	SEGMENT
_cycle$ = 8
_WalkeraGear PROC NEAR					; COMDAT

; 511  : 	return cycle[23];

	mov	ecx, DWORD PTR _cycle$[esp-4]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+23]

; 512  : };

	ret	0
_WalkeraGear ENDP
_TEXT	ENDS
PUBLIC	_WalkeraPitch
;	COMDAT _WalkeraPitch
_TEXT	SEGMENT
_cycle$ = 8
_WalkeraPitch PROC NEAR					; COMDAT

; 525  : 	int value, left, msb;
; 526  : 
; 527  : 	msb = cycle[28];

	mov	ecx, DWORD PTR _cycle$[esp-4]
	xor	eax, eax
	mov	al, BYTE PTR [ecx+28]

; 528  : 
; 529  : 	/* 
; 530  : 		Strange enough, four ranges mapped by all 8 values 
; 531  : 		Near left:	0 or 4
; 532  : 		Far left:	1 or 5
; 533  : 		Near right:	2 or 6
; 534  : 		Far right:	3 or 7
; 535  : 	*/
; 536  : 
; 537  : 	/* Remove the high numbers */
; 538  : 	if (msb > 3)

	cmp	eax, 3
	jle	SHORT $L27142

; 539  : 		msb-=4;

	sub	eax, 4
$L27142:

; 540  : 
; 541  : 	/* Left or right */
; 542  : 	if (msb <= 1)

	xor	edx, edx
	cmp	eax, 1
	setle	dl
	push	esi

; 543  : 		left = 1;
; 544  : 	else
; 545  : 		left = 0;
; 546  : 
; 547  : 	/* Near or far */
; 548  : 	if (msb > 1)

	cmp	eax, 1
	mov	esi, edx
	jle	SHORT $L27145

; 549  : 		msb-=2;

	sub	eax, 2
$L27145:

; 550  : 
; 551  : 	/* Offset from mid-point */
; 552  : 	value = msb*256+cycle[29]*128+cycle[30]*16+cycle[31]*8+cycle[32];

	xor	edx, edx
	mov	dl, BYTE PTR [ecx+29]
	lea	eax, DWORD PTR [edx+eax*2]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+30]
	lea	eax, DWORD PTR [edx+eax*8]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+31]
	lea	eax, DWORD PTR [edx+eax*2]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+32]

; 553  : 
; 554  : 	/* Mid-point is 511 */
; 555  : 	if(left)

	test	esi, esi
	lea	ecx, DWORD PTR [edx+eax*8]
	pop	esi
	je	SHORT $L27146

; 556  : 		value = 511+value; /* Left */

	add	ecx, 511				; 000001ffH

; 559  : 
; 560  : 	return value;

	mov	eax, ecx

; 561  : };

	ret	0
$L27146:

; 557  : 	else
; 558  : 		value = 511-value; /* Right */

	mov	eax, 511				; 000001ffH
	sub	eax, ecx

; 561  : };

	ret	0
_WalkeraPitch ENDP
_TEXT	ENDS
PUBLIC	_LoadProcessPulseFunctions
PUBLIC	??_C@_03JFHP@PPM?$AA@				; `string'
PUBLIC	??_C@_02GLDK@JR?$AA@				; `string'
PUBLIC	??_C@_03EDDN@FUT?$AA@				; `string'
PUBLIC	??_C@_04IKIA@AIR1?$AA@				; `string'
PUBLIC	??_C@_04HFDJ@AIR2?$AA@				; `string'
PUBLIC	??_C@_03PNIK@WAL?$AA@				; `string'
EXTRN	_calloc:NEAR
;	COMDAT ??_C@_03JFHP@PPM?$AA@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_03JFHP@PPM?$AA@ DB 'PPM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02GLDK@JR?$AA@
_DATA	SEGMENT
??_C@_02GLDK@JR?$AA@ DB 'JR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03EDDN@FUT?$AA@
_DATA	SEGMENT
??_C@_03EDDN@FUT?$AA@ DB 'FUT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04IKIA@AIR1?$AA@
_DATA	SEGMENT
??_C@_04IKIA@AIR1?$AA@ DB 'AIR1', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HFDJ@AIR2?$AA@
_DATA	SEGMENT
??_C@_04HFDJ@AIR2?$AA@ DB 'AIR2', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03PNIK@WAL?$AA@
_DATA	SEGMENT
??_C@_03PNIK@WAL?$AA@ DB 'WAL', 00H			; `string'
_DATA	ENDS
;	COMDAT _LoadProcessPulseFunctions
_TEXT	SEGMENT
_target$ = 8
_tmp$ = -256
_LoadProcessPulseFunctions PROC NEAR			; COMDAT

; 1277 : {

	sub	esp, 264				; 00000108H
	push	ebx
	push	ebp
	push	esi

; 1278 : 	int index=0;
; 1279 : 	char tmp[MAX_VAL_NAME];
; 1280 : 	int nMod;
; 1281 : 
; 1282 : 
; 1283 : 	nMod = target->nModulations;

	mov	esi, DWORD PTR _target$[esp+272]
	push	edi

; 1284 : 	ListProcessPulseFunc = (far void **)calloc(3*nMod+1, sizeof(far void *));

	push	4
	mov	ebx, DWORD PTR [esi+148]
	xor	ebp, ebp
	lea	eax, DWORD PTR [ebx+ebx*2+1]
	push	eax
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _ListProcessPulseFunc, eax

; 1285 : 
; 1286 : 	/* Loop on list of modulation types */
; 1287 : 	while(index < nMod && index<MAX_MODS)

	test	ebx, ebx
	jle	$L27531
	lea	ecx, DWORD PTR [ebx*4]
	add	esi, 152				; 00000098H
	mov	DWORD PTR -264+[esp+280], ecx
	mov	DWORD PTR -260+[esp+280], esi
$L27530:
	cmp	ebp, 127				; 0000007fH
	jge	$L27531

; 1288 : 	{
; 1289 : 		/* Get the internal name of the modulation */
; 1290 : 		strcpy(tmp, (char *)target->pInternalModName[index]);

	mov	edi, DWORD PTR _gpSharedBlock
	mov	ecx, DWORD PTR [esi]
	add	edi, ecx
	or	ecx, -1
	xor	eax, eax
	lea	edx, DWORD PTR _tmp$[esp+280]
	repne scasb
	not	ecx
	sub	edi, ecx
	mov	eax, ecx
	mov	esi, edi
	mov	edi, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, eax

; 1291 : 
; 1292 : 		if (!strcmp(tmp, MOD_TYPE_PPM))

	lea	eax, DWORD PTR _tmp$[esp+280]
	and	ecx, 3
	rep movsb
	mov	esi, OFFSET FLAT:??_C@_03JFHP@PPM?$AA@	; `string'
$L29305:
	mov	dl, BYTE PTR [eax]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi]
	jne	SHORT $L29306
	test	cl, cl
	je	SHORT $L29307
	mov	dl, BYTE PTR [eax+1]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi+1]
	jne	SHORT $L29306
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L29305
$L29307:
	xor	eax, eax
	jmp	SHORT $L29308
$L29306:
	sbb	eax, eax
	sbb	eax, -1
$L29308:
	test	eax, eax
	jne	SHORT $L27533

; 1293 : 		{	
; 1294 : 			ListProcessPulseFunc[0*nMod+index] = (void *)ProcessPulsePpm;		/* Auto  Detect*/

	mov	eax, DWORD PTR _ListProcessPulseFunc

; 1295 : 			ListProcessPulseFunc[1*nMod+index] = (void *)ProcessPulseFutabaPpm;	/* Negative  Detect*/

	mov	edx, DWORD PTR -264+[esp+280]
	mov	DWORD PTR [eax+ebp*4], OFFSET FLAT:_ProcessPulsePpm
	mov	ecx, DWORD PTR _ListProcessPulseFunc

; 1296 : 			ListProcessPulseFunc[2*nMod+index] = (void *)ProcessPulseJrPpm;		/* Positive  Detect*/

	lea	eax, DWORD PTR [ebp+ebx*2]
	mov	DWORD PTR [edx+ecx], OFFSET FLAT:_ProcessPulseFutabaPpm
	mov	ecx, DWORD PTR _ListProcessPulseFunc
	mov	DWORD PTR [ecx+eax*4], OFFSET FLAT:_ProcessPulseJrPpm

; 1297 : 		}
; 1298 : 		else if (!strcmp(tmp, MOD_TYPE_JR))

	jmp	$L27563
$L27533:
	mov	esi, OFFSET FLAT:??_C@_02GLDK@JR?$AA@	; `string'
	lea	eax, DWORD PTR _tmp$[esp+280]
$L29309:
	mov	dl, BYTE PTR [eax]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi]
	jne	SHORT $L29310
	test	cl, cl
	je	SHORT $L29311
	mov	dl, BYTE PTR [eax+1]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi+1]
	jne	SHORT $L29310
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L29309
$L29311:
	xor	eax, eax
	jmp	SHORT $L29312
$L29310:
	sbb	eax, eax
	sbb	eax, -1
$L29312:
	test	eax, eax
	jne	SHORT $L27539

; 1299 : 		{
; 1300 : 			ListProcessPulseFunc[0*nMod+index] = (void **)ProcessPulseJrPcm;

	mov	eax, DWORD PTR _ListProcessPulseFunc

; 1301 : 			ListProcessPulseFunc[1*nMod+index] = (void **)ProcessPulseJrPcm;

	mov	edx, DWORD PTR -264+[esp+280]
	mov	DWORD PTR [eax+ebp*4], OFFSET FLAT:_ProcessPulseJrPcm
	mov	ecx, DWORD PTR _ListProcessPulseFunc

; 1302 : 			ListProcessPulseFunc[2*nMod+index] = (void **)ProcessPulseJrPcm;

	lea	eax, DWORD PTR [ebp+ebx*2]
	mov	DWORD PTR [edx+ecx], OFFSET FLAT:_ProcessPulseJrPcm
	mov	ecx, DWORD PTR _ListProcessPulseFunc
	mov	DWORD PTR [ecx+eax*4], OFFSET FLAT:_ProcessPulseJrPcm

; 1303 : 		}
; 1304 : 		else if (!strcmp(tmp, MOD_TYPE_FUT))

	jmp	$L27563
$L27539:
	mov	esi, OFFSET FLAT:??_C@_03EDDN@FUT?$AA@	; `string'
	lea	eax, DWORD PTR _tmp$[esp+280]
$L29313:
	mov	dl, BYTE PTR [eax]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi]
	jne	SHORT $L29314
	test	cl, cl
	je	SHORT $L29315
	mov	dl, BYTE PTR [eax+1]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi+1]
	jne	SHORT $L29314
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L29313
$L29315:
	xor	eax, eax
	jmp	SHORT $L29316
$L29314:
	sbb	eax, eax
	sbb	eax, -1
$L29316:
	test	eax, eax
	jne	SHORT $L27545

; 1305 : 		{
; 1306 : 			ListProcessPulseFunc[0*nMod+index] = (void **)ProcessPulseFutabaPcm;

	mov	eax, DWORD PTR _ListProcessPulseFunc

; 1307 : 			ListProcessPulseFunc[1*nMod+index] = (void **)ProcessPulseFutabaPcm;

	mov	edx, DWORD PTR -264+[esp+280]
	mov	DWORD PTR [eax+ebp*4], OFFSET FLAT:_ProcessPulseFutabaPcm
	mov	ecx, DWORD PTR _ListProcessPulseFunc

; 1308 : 			ListProcessPulseFunc[2*nMod+index] = (void **)ProcessPulseFutabaPcm;

	lea	eax, DWORD PTR [ebp+ebx*2]
	mov	DWORD PTR [edx+ecx], OFFSET FLAT:_ProcessPulseFutabaPcm
	mov	ecx, DWORD PTR _ListProcessPulseFunc
	mov	DWORD PTR [ecx+eax*4], OFFSET FLAT:_ProcessPulseFutabaPcm

; 1309 : 		}
; 1310 : 		else if (!strcmp(tmp, MOD_TYPE_AIR1))

	jmp	$L27563
$L27545:
	mov	esi, OFFSET FLAT:??_C@_04IKIA@AIR1?$AA@	; `string'
	lea	eax, DWORD PTR _tmp$[esp+280]
$L29317:
	mov	dl, BYTE PTR [eax]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi]
	jne	SHORT $L29318
	test	cl, cl
	je	SHORT $L29319
	mov	dl, BYTE PTR [eax+1]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi+1]
	jne	SHORT $L29318
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L29317
$L29319:
	xor	eax, eax
	jmp	SHORT $L29320
$L29318:
	sbb	eax, eax
	sbb	eax, -1
$L29320:
	test	eax, eax
	jne	SHORT $L27551

; 1311 : 		{
; 1312 : 			ListProcessPulseFunc[0*nMod+index] = (void **)ProcessPulseAirPcm1;

	mov	eax, DWORD PTR _ListProcessPulseFunc

; 1313 : 			ListProcessPulseFunc[1*nMod+index] = (void **)ProcessPulseAirPcm1;

	mov	edx, DWORD PTR -264+[esp+280]
	mov	DWORD PTR [eax+ebp*4], OFFSET FLAT:_ProcessPulseAirPcm1
	mov	ecx, DWORD PTR _ListProcessPulseFunc

; 1314 : 			ListProcessPulseFunc[2*nMod+index] = (void **)ProcessPulseAirPcm1;

	lea	eax, DWORD PTR [ebp+ebx*2]
	mov	DWORD PTR [edx+ecx], OFFSET FLAT:_ProcessPulseAirPcm1
	mov	ecx, DWORD PTR _ListProcessPulseFunc
	mov	DWORD PTR [ecx+eax*4], OFFSET FLAT:_ProcessPulseAirPcm1

; 1315 : 		}
; 1316 : 		else if (!strcmp(tmp, MOD_TYPE_AIR2))

	jmp	$L27563
$L27551:
	mov	esi, OFFSET FLAT:??_C@_04HFDJ@AIR2?$AA@	; `string'
	lea	eax, DWORD PTR _tmp$[esp+280]
$L29321:
	mov	dl, BYTE PTR [eax]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi]
	jne	SHORT $L29322
	test	cl, cl
	je	SHORT $L29323
	mov	dl, BYTE PTR [eax+1]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi+1]
	jne	SHORT $L29322
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L29321
$L29323:
	xor	eax, eax
	jmp	SHORT $L29324
$L29322:
	sbb	eax, eax
	sbb	eax, -1
$L29324:
	test	eax, eax
	jne	SHORT $L27557

; 1317 : 		{
; 1318 : 			ListProcessPulseFunc[0*nMod+index] = (void **)ProcessPulseAirPcm2;

	mov	eax, DWORD PTR _ListProcessPulseFunc

; 1319 : 			ListProcessPulseFunc[1*nMod+index] = (void **)ProcessPulseAirPcm2;

	mov	edx, DWORD PTR -264+[esp+280]
	mov	DWORD PTR [eax+ebp*4], OFFSET FLAT:_ProcessPulseAirPcm2
	mov	ecx, DWORD PTR _ListProcessPulseFunc

; 1320 : 			ListProcessPulseFunc[2*nMod+index] = (void **)ProcessPulseAirPcm2;

	lea	eax, DWORD PTR [ebp+ebx*2]
	mov	DWORD PTR [edx+ecx], OFFSET FLAT:_ProcessPulseAirPcm2
	mov	ecx, DWORD PTR _ListProcessPulseFunc
	mov	DWORD PTR [ecx+eax*4], OFFSET FLAT:_ProcessPulseAirPcm2

; 1321 : 		}
; 1322 : 		else if (!strcmp(tmp, MOD_TYPE_WAL))

	jmp	SHORT $L27563
$L27557:
	mov	esi, OFFSET FLAT:??_C@_03PNIK@WAL?$AA@	; `string'
	lea	eax, DWORD PTR _tmp$[esp+280]
$L29325:
	mov	dl, BYTE PTR [eax]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi]
	jne	SHORT $L29326
	test	cl, cl
	je	SHORT $L29327
	mov	dl, BYTE PTR [eax+1]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi+1]
	jne	SHORT $L29326
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L29325
$L29327:
	xor	eax, eax
	jmp	SHORT $L29328
$L29326:
	sbb	eax, eax
	sbb	eax, -1
$L29328:
	test	eax, eax
	jne	SHORT $L27563

; 1323 : 		{
; 1324 : 			ListProcessPulseFunc[0*nMod+index] = (void **)ProcessPulseAirWal;

	mov	eax, DWORD PTR _ListProcessPulseFunc

; 1325 : 			ListProcessPulseFunc[1*nMod+index] = (void **)ProcessPulseAirWal;

	mov	edx, DWORD PTR -264+[esp+280]
	mov	DWORD PTR [eax+ebp*4], OFFSET FLAT:_ProcessPulseAirWal
	mov	ecx, DWORD PTR _ListProcessPulseFunc

; 1326 : 			ListProcessPulseFunc[2*nMod+index] = (void **)ProcessPulseAirWal;

	lea	eax, DWORD PTR [ebp+ebx*2]
	mov	DWORD PTR [edx+ecx], OFFSET FLAT:_ProcessPulseAirWal
	mov	ecx, DWORD PTR _ListProcessPulseFunc
	mov	DWORD PTR [ecx+eax*4], OFFSET FLAT:_ProcessPulseAirWal
$L27563:

; 1327 : 		}
; 1328 : 		index++;

	mov	esi, DWORD PTR -260+[esp+280]
	mov	ecx, DWORD PTR -264+[esp+280]
	inc	ebp
	add	esi, 4
	add	ecx, 4
	cmp	ebp, ebx
	mov	DWORD PTR -260+[esp+280], esi
	mov	DWORD PTR -264+[esp+280], ecx
	jl	$L27530
$L27531:

; 1329 : 	};
; 1330 : 
; 1331 : 
; 1332 : 	ListProcessPulseFunc[2*nMod+index] = (void **)NULL;

	mov	eax, DWORD PTR _ListProcessPulseFunc
	lea	edx, DWORD PTR [ebp+ebx*2]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+edx*4], 0

; 1333 : 	return index;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 1334 : }

	add	esp, 264				; 00000108H
	ret	0
_LoadProcessPulseFunctions ENDP
_TEXT	ENDS
_BSS	SEGMENT
_Position DD	0cH DUP (?)
_?nPulse@?1??ProcessPulseAirWal@@9@9 DD 01H DUP (?)
_?cycle@?1??ProcessPulseAirWal@@9@9 DB 032H DUP (?)
_BSS	ENDS
;	COMDAT _ProcessPulseAirWal
_TEXT	SEGMENT
_width$ = 8
_Rudder$ = 8
_ProcessPulseAirWal PROC NEAR				; COMDAT

; 597  : 	static int nPulse;
; 598  : 	static unsigned char cycle[50];
; 599  : 	int Elevator=0, Ailerons=0,Throttle=0,Rudder=0,Gear=0, Pitch=0;
; 600  : 	const int fixed_n_channel = 7;
; 601  : 	int vPulse;
; 602  : 
; 603  : 
; 604  : 	/* Detect Sync pulse - if detected then reset pulse counter and return */
; 605  : 	if (width>56)

	mov	eax, DWORD PTR _width$[esp-4]
	cmp	eax, 56					; 00000038H
	jle	SHORT $L27166

; 606  : 	{
; 607  : 		nPulse = 1;

	mov	DWORD PTR _?nPulse@?1??ProcessPulseAirWal@@9@9, 1

; 642  : 
; 643  : #ifdef PPJOY
; 644  : 				SendPPJoy(fixed_n_channel-1, Position);
; 645  : #endif
; 646  : 	};
; 647  : 	return 0;

	xor	eax, eax

; 648  : }

	ret	0
$L27166:

; 608  : 		return 0;
; 609  : 	};
; 610  : 
; 611  : 
; 612  : 	/* Even pulses are binary, Odd pulses are Octal */
; 613  : 	if ((nPulse&1))

	mov	cl, BYTE PTR _?nPulse@?1??ProcessPulseAirWal@@9@9

; 614  : 		vPulse = WalkeraConvert2Bin(width);

	push	eax
	test	cl, 1
	je	SHORT $L27167
	call	_WalkeraConvert2Bin

; 615  : 	else

	jmp	SHORT $L29375
$L27167:

; 616  : 		vPulse = WalkeraConvert2Oct(width);

	call	_WalkeraConvert2Oct
$L29375:

; 617  : 	if (vPulse<8)

	mov	ecx, DWORD PTR _?nPulse@?1??ProcessPulseAirWal@@9@9
	and	eax, 255				; 000000ffH
	add	esp, 4
	cmp	eax, 8
	jge	SHORT $L27169

; 618  : 		cycle[nPulse] = vPulse;

	mov	BYTE PTR _?cycle@?1??ProcessPulseAirWal@@9@9[ecx], al
$L27169:

; 619  : 
; 620  : 	nPulse++;

	inc	ecx

; 621  : 
; 622  : 	/* At the end of the 50-pulse cycle - calculate the channels */
; 623  : 	if (nPulse==50)

	cmp	ecx, 50					; 00000032H
	mov	DWORD PTR _?nPulse@?1??ProcessPulseAirWal@@9@9, ecx
	jne	$L27170
	push	ebx
	push	ebp
	push	esi
	push	edi

; 624  : 	{
; 625  : 		/* Channels */
; 626  : 		Elevator = WalkeraElevator(cycle);	/* Ch1: Elevator */		

	push	OFFSET FLAT:_?cycle@?1??ProcessPulseAirWal@@9@9
	call	_WalkeraElevator

; 627  : 		Ailerons = WalkeraAilerons(cycle);	/* Ch2: Ailerons */		

	push	OFFSET FLAT:_?cycle@?1??ProcessPulseAirWal@@9@9
	mov	esi, eax
	call	_WalkeraAilerons

; 628  : 		Throttle = WalkeraThrottle(cycle);	/* Ch3: Throttle */		

	push	OFFSET FLAT:_?cycle@?1??ProcessPulseAirWal@@9@9
	mov	edi, eax
	call	_WalkeraThrottle

; 629  : 		Rudder = WalkeraRudder(cycle);		/* Ch4: Rudder   */		

	push	OFFSET FLAT:_?cycle@?1??ProcessPulseAirWal@@9@9
	mov	ebp, eax
	call	_WalkeraRudder

; 630  : 		Gear = 100*WalkeraGear(cycle);		/* Ch5: Gear     */

	push	OFFSET FLAT:_?cycle@?1??ProcessPulseAirWal@@9@9
	mov	DWORD PTR _Rudder$[esp+32], eax
	call	_WalkeraGear
	lea	eax, DWORD PTR [eax+eax*4]

; 631  : 		Pitch = WalkeraPitch(cycle);		/* Ch6: Pitch    */		

	push	OFFSET FLAT:_?cycle@?1??ProcessPulseAirWal@@9@9
	lea	ebx, DWORD PTR [eax+eax*4]
	shl	ebx, 2
	call	_WalkeraPitch
	add	esp, 24					; 00000018H
	mov	ecx, eax

; 632  : 		
; 633  : 		/* Copy data to joystick positions*/
; 634  : 		Position[0] = smooth(Position[0], Elevator);

	mov	eax, DWORD PTR _Position
	test	esi, esi
	jl	SHORT $L29334
	mov	edx, eax
	sub	edx, esi
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29337
	mov	edx, esi
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29337
	mov	eax, esi
	jmp	SHORT $L29334
$L29337:
	add	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
$L29334:
	mov	DWORD PTR _Position, eax

; 635  : 		Position[1] = smooth(Position[1], Ailerons);

	mov	eax, DWORD PTR _Position+4
	test	edi, edi
	jl	SHORT $L29341
	mov	edx, eax
	sub	edx, edi
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29344
	mov	edx, edi
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29344
	mov	eax, edi
	jmp	SHORT $L29341
$L29344:
	add	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
$L29341:
	mov	DWORD PTR _Position+4, eax

; 636  : 		Position[2] = smooth(Position[2], Throttle);

	mov	eax, DWORD PTR _Position+8
	test	ebp, ebp
	jl	SHORT $L29348
	mov	edx, eax
	sub	edx, ebp
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29351
	mov	edx, ebp
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29351
	mov	eax, ebp
	jmp	SHORT $L29348
$L29351:
	add	eax, ebp
	cdq
	sub	eax, edx
	sar	eax, 1
$L29348:
	mov	DWORD PTR _Position+8, eax

; 637  : 		Position[3] = smooth(Position[3], Rudder);

	mov	eax, DWORD PTR _Rudder$[esp+12]
	test	eax, eax
	jge	SHORT $L29356
	mov	eax, DWORD PTR _Position+12
	jmp	SHORT $L29355
$L29356:
	mov	edx, DWORD PTR _Position+12
	mov	esi, edx
	sub	esi, eax
	cmp	esi, 100				; 00000064H
	jg	SHORT $L29358
	mov	esi, eax
	sub	esi, edx
	cmp	esi, 100				; 00000064H
	jle	SHORT $L29355
$L29358:
	add	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29355:
	mov	DWORD PTR _Position+12, eax

; 638  : 		Position[4] = smooth(Position[4], Gear);

	mov	eax, DWORD PTR _Position+16
	test	ebx, ebx
	jl	SHORT $L29362
	mov	edx, eax
	sub	edx, ebx
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29365
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29365
	mov	eax, ebx
	jmp	SHORT $L29362
$L29365:
	add	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29362:
	pop	edi
	pop	esi
	mov	DWORD PTR _Position+16, eax

; 639  : 		Position[5] = smooth(Position[5], Pitch);

	mov	eax, DWORD PTR _Position+20
	pop	ebp
	pop	ebx
	test	ecx, ecx
	jl	SHORT $L29369
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29372
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29372
	mov	eax, ecx

; 640  : 		
; 641  : 		nPulse = 0;

	mov	DWORD PTR _?nPulse@?1??ProcessPulseAirWal@@9@9, 0
	mov	DWORD PTR _Position+20, eax

; 642  : 
; 643  : #ifdef PPJOY
; 644  : 				SendPPJoy(fixed_n_channel-1, Position);
; 645  : #endif
; 646  : 	};
; 647  : 	return 0;

	xor	eax, eax

; 648  : }

	ret	0

; 639  : 		Position[5] = smooth(Position[5], Pitch);

$L29372:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29369:
	mov	DWORD PTR _Position+20, eax

; 640  : 		
; 641  : 		nPulse = 0;

	mov	DWORD PTR _?nPulse@?1??ProcessPulseAirWal@@9@9, 0
$L27170:

; 642  : 
; 643  : #ifdef PPJOY
; 644  : 				SendPPJoy(fixed_n_channel-1, Position);
; 645  : #endif
; 646  : 	};
; 647  : 	return 0;

	xor	eax, eax

; 648  : }

	ret	0
_ProcessPulseAirWal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@IIHD@?6?$CFs?5?9?5ProcessPulseAirPcm1?$CI?$CFd?$CJ?$AA@ ; `string'
_BSS	SEGMENT
	ALIGN	4

_?sync@?1??ProcessPulseAirPcm1@@9@9 DD 01H DUP (?)
_?data@?1??ProcessPulseAirPcm1@@9@9 DD 0aH DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BO@IIHD@?6?$CFs?5?9?5ProcessPulseAirPcm1?$CI?$CFd?$CJ?$AA@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0BO@IIHD@?6?$CFs?5?9?5ProcessPulseAirPcm1?$CI?$CFd?$CJ?$AA@ DB 0aH, '%'
	DB	's - ProcessPulseAirPcm1(%d)', 00H		; `string'
_DATA	ENDS
;	COMDAT _ProcessPulseAirPcm1
_TEXT	SEGMENT
_width$ = 8
_input$ = 12
_tbuffer$ = -12
_ProcessPulseAirPcm1 PROC NEAR				; COMDAT

; 689  : 	int pulse;
; 690  : 	static int sync;
; 691  : 	static int datacount = 0;
; 692  :     static unsigned int bitcount = 0;
; 693  :     static unsigned int bitstream = 0;
; 694  : 	static chunk = -1;
; 695  : 	unsigned int		shift;
; 696  :     static unsigned int data[10];
; 697  : 	char tbuffer [9];
; 698  : 	static int i = 0;
; 699  : 	const int fixed_n_channel = 8;
; 700  : 
; 701  : 	if (gDebugLevel>=2 && gCtrlLogFile && i++%10)

	mov	eax, DWORD PTR _gDebugLevel
	sub	esp, 12					; 0000000cH
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	esi, DWORD PTR _width$[esp+16]
	cmp	eax, 2
	push	edi
	jl	SHORT $L27203
	cmp	DWORD PTR _gCtrlLogFile, ebx
	je	SHORT $L27203
	mov	ecx, DWORD PTR _?i@?1??ProcessPulseAirPcm1@@9@9
	mov	edi, 10					; 0000000aH
	mov	eax, ecx
	cdq
	idiv	edi
	inc	ecx
	mov	DWORD PTR _?i@?1??ProcessPulseAirPcm1@@9@9, ecx
	test	edx, edx
	je	SHORT $L27203

; 702  : 		fprintf(gCtrlLogFile,"\n%s - ProcessPulseAirPcm1(%d)", _strtime( tbuffer ), width);

	lea	eax, DWORD PTR _tbuffer$[esp+24]
	push	esi
	push	eax
	call	__strtime
	mov	ecx, DWORD PTR _gCtrlLogFile
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BO@IIHD@?6?$CFs?5?9?5ProcessPulseAirPcm1?$CI?$CFd?$CJ?$AA@ ; `string'
	push	ecx
	call	_fprintf
	add	esp, 16					; 00000010H
$L27203:

; 703  : 
; 704  : 		pulse = width/8; // Width to bits

	mov	eax, esi
	cdq
	and	edx, 7
	add	eax, edx
	mov	edi, eax
	sar	edi, 3

; 705  : 		if (pulse == 4)  // 4-bit pulse marks a bigining of a data chunk

	cmp	edi, 4
	jne	$L27205

; 706  : 		{
; 707  : 			if (!input)

	mov	esi, DWORD PTR _input$[esp+20]
	cmp	esi, ebx
	jne	SHORT $L27206

; 708  : 			{
; 709  : 				// First data chunk - clear chunnel counter
; 710  : 				datacount = 0;

	mov	DWORD PTR _?datacount@?1??ProcessPulseAirPcm1@@9@9, ebx

; 711  : 			}
; 712  : 			else

	jmp	$L27207
$L27206:

; 713  : 			{	// Second data chunk - get joystick position from channel data
; 714  : 				Position[0] = smooth(Position[0], Convert15bits(data[1]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm1@@9@9+4
	call	@Convert15bits@4
	cmp	eax, ebx
	jge	SHORT $L29380
	mov	eax, DWORD PTR _Position
	jmp	SHORT $L29379
$L29380:
	mov	ecx, DWORD PTR _Position
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29382
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29379
$L29382:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29379:

; 715  : 				Position[1] = smooth(Position[1], Convert15bits(data[2]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm1@@9@9+8
	mov	DWORD PTR _Position, eax
	call	@Convert15bits@4
	cmp	eax, ebx
	jge	SHORT $L29388
	mov	eax, DWORD PTR _Position+4
	jmp	SHORT $L29387
$L29388:
	mov	ecx, DWORD PTR _Position+4
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29390
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29387
$L29390:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29387:

; 716  : 				Position[2] = smooth(Position[2], Convert15bits(data[3]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm1@@9@9+12
	mov	DWORD PTR _Position+4, eax
	call	@Convert15bits@4
	cmp	eax, ebx
	jge	SHORT $L29396
	mov	eax, DWORD PTR _Position+8
	jmp	SHORT $L29395
$L29396:
	mov	ecx, DWORD PTR _Position+8
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29398
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29395
$L29398:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29395:

; 717  : 				Position[3] = smooth(Position[3], Convert15bits(data[4]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm1@@9@9+16
	mov	DWORD PTR _Position+8, eax
	call	@Convert15bits@4
	cmp	eax, ebx
	jge	SHORT $L29404
	mov	eax, DWORD PTR _Position+12
	jmp	SHORT $L29403
$L29404:
	mov	ecx, DWORD PTR _Position+12
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29406
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29403
$L29406:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29403:

; 718  : 				Position[4] = smooth(Position[4], Convert15bits(data[6]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm1@@9@9+24
	mov	DWORD PTR _Position+12, eax
	call	@Convert15bits@4
	cmp	eax, ebx
	jge	SHORT $L29412
	mov	eax, DWORD PTR _Position+16
	jmp	SHORT $L29411
$L29412:
	mov	ecx, DWORD PTR _Position+16
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29414
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29411
$L29414:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29411:

; 719  : 				Position[5] = smooth(Position[5], Convert15bits(data[7]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm1@@9@9+28
	mov	DWORD PTR _Position+16, eax
	call	@Convert15bits@4
	cmp	eax, ebx
	jge	SHORT $L29420
	mov	eax, DWORD PTR _Position+20
	jmp	SHORT $L29419
$L29420:
	mov	ecx, DWORD PTR _Position+20
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29422
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29419
$L29422:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29419:

; 720  : 				Position[6] = smooth(Position[6], Convert15bits(data[8]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm1@@9@9+32
	mov	DWORD PTR _Position+20, eax
	call	@Convert15bits@4
	cmp	eax, ebx
	jge	SHORT $L29428
	mov	eax, DWORD PTR _Position+24
	jmp	SHORT $L29427
$L29428:
	mov	ecx, DWORD PTR _Position+24
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29430
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29427
$L29430:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29427:

; 721  : 				Position[7] = smooth(Position[7], Convert15bits(data[9]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm1@@9@9+36
	mov	DWORD PTR _Position+24, eax
	call	@Convert15bits@4
	cmp	eax, ebx
	jge	SHORT $L29436
	mov	eax, DWORD PTR _Position+28
	jmp	SHORT $L29435
$L29436:
	mov	ecx, DWORD PTR _Position+28
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29438
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29435
$L29438:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29435:
	mov	DWORD PTR _Position+28, eax
$L27207:

; 722  : #ifdef PPJOY
; 723  : 				SendPPJoy(fixed_n_channel-1, Position);
; 724  : #endif
; 725  : 			};
; 726  : 			sync = 1;		// Sync bit is set for the first 10 bits of the chunk (No channel data here)
; 727  : 			bitstream = 0;
; 728  : 			bitcount = -1;
; 729  : 			chunk = input;	// Mark chunk polarity - 0: Low channels, 1: High channels

	mov	DWORD PTR _?chunk@?1??ProcessPulseAirPcm1@@9@9, esi
	mov	DWORD PTR _?sync@?1??ProcessPulseAirPcm1@@9@9, 1
	mov	DWORD PTR _?bitstream@?1??ProcessPulseAirPcm1@@9@9, ebx
	or	edx, -1

; 734  : 		{
; 735  : 			shift = 9;	// Read the first 10 bits

	mov	esi, 9

; 736  : 		}
; 737  : 		else

	jmp	SHORT $L27209
$L27205:

; 730  : 			//return 0;
; 731  : 		};
; 732  : 		
; 733  : 		if (sync) 

	cmp	DWORD PTR _?sync@?1??ProcessPulseAirPcm1@@9@9, ebx
	je	SHORT $L27208
	mov	edx, DWORD PTR _?bitcount@?1??ProcessPulseAirPcm1@@9@9

; 734  : 		{
; 735  : 			shift = 9;	// Read the first 10 bits

	mov	esi, 9

; 736  : 		}
; 737  : 		else

	jmp	SHORT $L27209
$L27208:

; 738  : 		{
; 739  : 			shift =15; // Read a channel data

	mov	edx, DWORD PTR _?bitcount@?1??ProcessPulseAirPcm1@@9@9
	mov	esi, 15					; 0000000fH
$L27209:

; 740  : 		};
; 741  : 
; 742  : 		bitstream = ((bitstream << 1) + 1) << (pulse - 1);

	mov	eax, DWORD PTR _?bitstream@?1??ProcessPulseAirPcm1@@9@9
	lea	ecx, DWORD PTR [edi-1]

; 743  : 		bitcount += pulse;

	add	edx, edi
	lea	eax, DWORD PTR [eax+eax+1]
	mov	DWORD PTR _?bitcount@?1??ProcessPulseAirPcm1@@9@9, edx
	shl	eax, cl

; 744  : 		
; 745  : 		if (bitcount >=shift) 

	cmp	edx, esi
	mov	DWORD PTR _?bitstream@?1??ProcessPulseAirPcm1@@9@9, eax
	jb	SHORT $L29443

; 746  : 		{
; 747  : 			bitcount -= shift;

	sub	edx, esi

; 748  : 			data[datacount] = (bitstream >> bitcount) & 0x7FFF; // Put raw 15-bit channel data
; 749  : 			datacount++;
; 750  : 			sync = 0;

	mov	DWORD PTR _?sync@?1??ProcessPulseAirPcm1@@9@9, ebx
	mov	ecx, edx
	mov	DWORD PTR _?bitcount@?1??ProcessPulseAirPcm1@@9@9, edx
	shr	eax, cl
	mov	ecx, DWORD PTR _?datacount@?1??ProcessPulseAirPcm1@@9@9
	and	eax, 32767				; 00007fffH
	mov	DWORD PTR _?data@?1??ProcessPulseAirPcm1@@9@9[ecx*4], eax
	inc	ecx

; 751  : 			if (datacount>=fixed_n_channel+2)

	cmp	ecx, 10					; 0000000aH
	mov	DWORD PTR _?datacount@?1??ProcessPulseAirPcm1@@9@9, ecx
	jl	SHORT $L29443

; 752  : 				datacount = 0;

	mov	DWORD PTR _?datacount@?1??ProcessPulseAirPcm1@@9@9, ebx
$L29443:
	pop	edi
	pop	esi

; 753  : 		};
; 754  : 		return 0;

	xor	eax, eax
	pop	ebx

; 755  : }

	add	esp, 12					; 0000000cH
	ret	0
_ProcessPulseAirPcm1 ENDP
_TEXT	ENDS
;	COMDAT @Convert15bits@4
_TEXT	SEGMENT
@Convert15bits@4 PROC NEAR				; COMDAT

; 653  : 	int quintet[3];
; 654  : 
; 655  : 	/* Convert the upper 5-bits to value 0-3 */
; 656  : 	quintet[2] = air1_msb[((in>>10)&0x1F)];

	mov	eax, ecx
	shr	eax, 10					; 0000000aH
	and	eax, 31					; 0000001fH
	mov	eax, DWORD PTR _air1_msb[eax*4]

; 657  : 	if (quintet[2]<0)

	test	eax, eax
	jge	SHORT $L27176

; 658  : 		return -1;

	or	eax, -1

; 672  : 
; 673  : }

	ret	0
$L27176:

; 659  : 
; 660  : 	/* Convert the mid 5-bits to value 0-15 */
; 661  : 	quintet[1] = air1_symbol[((in>>5)&0x1F)];

	mov	edx, ecx
	shr	edx, 5
	and	edx, 31					; 0000001fH
	mov	edx, DWORD PTR _air1_symbol[edx*4]

; 662  : 	if (quintet[1]<0)

	test	edx, edx
	jge	SHORT $L27177

; 663  : 		return -1;

	or	eax, -1

; 672  : 
; 673  : }

	ret	0
$L27177:

; 664  : 
; 665  : 	/* Convert the low 5-bits to value 0-15 */
; 666  : 	quintet[0] = air1_symbol[(in&0x1F)];

	and	ecx, 31					; 0000001fH
	mov	ecx, DWORD PTR _air1_symbol[ecx*4]

; 667  : 	if (quintet[0]<0)

	test	ecx, ecx
	jge	SHORT $L27178

; 668  : 		return -1;

	or	eax, -1

; 672  : 
; 673  : }

	ret	0
$L27178:

; 669  : 
; 670  : 	/* Return the calculated (inverted) channel value of 0-1023 */
; 671  : 	return 1023-(quintet[2]*256+quintet[1]*16+quintet[0]);

	shl	eax, 4
	add	eax, edx
	shl	eax, 4
	mov	edx, eax
	mov	eax, 1023				; 000003ffH
	sub	eax, edx
	sub	eax, ecx

; 672  : 
; 673  : }

	ret	0
@Convert15bits@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@HFOB@?6?$CFs?5?9?5ProcessPulseAirPcm2?$CIWidth?$DN@ ; `string'
_BSS	SEGMENT
_?sync@?1??ProcessPulseAirPcm2@@9@9 DD 01H DUP (?)
_?data@?1??ProcessPulseAirPcm2@@9@9 DD 0aH DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CO@HFOB@?6?$CFs?5?9?5ProcessPulseAirPcm2?$CIWidth?$DN@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0CO@HFOB@?6?$CFs?5?9?5ProcessPulseAirPcm2?$CIWidth?$DN@ DB 0aH, '%s'
	DB	' - ProcessPulseAirPcm2(Width=%d, input=%d)', 00H ; `string'
_DATA	ENDS
;	COMDAT _ProcessPulseAirPcm2
_TEXT	SEGMENT
_width$ = 8
_input$ = 12
_tbuffer$ = -12
_ProcessPulseAirPcm2 PROC NEAR				; COMDAT

; 802  : 	int pulse;
; 803  : 	static int sync;
; 804  : 	static int datacount = 0;
; 805  :     static unsigned int bitcount = 0;
; 806  :     static unsigned int bitstream = 0;
; 807  : 	static chunk = -1;
; 808  : 	unsigned int		shift;
; 809  :     static unsigned int data[10];
; 810  : 	char tbuffer [9];
; 811  : 	static int i = 0;
; 812  : 
; 813  : 	if (gDebugLevel>=2 && gCtrlLogFile && !(i++%50))

	mov	eax, DWORD PTR _gDebugLevel
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, DWORD PTR _input$[esp+12]
	push	ebp
	xor	ebp, ebp
	push	esi
	mov	esi, DWORD PTR _width$[esp+20]
	cmp	eax, 2
	push	edi
	jl	SHORT $L27246
	cmp	DWORD PTR _gCtrlLogFile, ebp
	je	SHORT $L27246
	mov	ecx, DWORD PTR _?i@?1??ProcessPulseAirPcm2@@9@9
	mov	edi, 50					; 00000032H
	mov	eax, ecx
	cdq
	idiv	edi
	inc	ecx
	mov	DWORD PTR _?i@?1??ProcessPulseAirPcm2@@9@9, ecx
	test	edx, edx
	jne	SHORT $L27246

; 814  : 		fprintf(gCtrlLogFile,"\n%s - ProcessPulseAirPcm2(Width=%d, input=%d)", _strtime( tbuffer ), width, input);

	push	ebx
	lea	eax, DWORD PTR _tbuffer$[esp+32]
	push	esi
	push	eax
	call	__strtime
	mov	ecx, DWORD PTR _gCtrlLogFile
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CO@HFOB@?6?$CFs?5?9?5ProcessPulseAirPcm2?$CIWidth?$DN@ ; `string'
	push	ecx
	call	_fprintf
	add	esp, 20					; 00000014H
$L27246:

; 815  : 
; 816  : 		pulse = width/12; // Width to bits

	mov	eax, 715827883				; 2aaaaaabH
	imul	esi
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax
	mov	edi, edx

; 817  : 		if (pulse == 7)  // 4-bit pulse marks a biginind of a data chunk

	cmp	edi, 7
	jne	$L27248

; 818  : 		{
; 819  : 			if (!input)

	cmp	ebx, ebp
	jne	SHORT $L27249

; 820  : 			{
; 821  : 				// First data chunk - clear chunnel counter
; 822  : 				datacount = 0;

	mov	DWORD PTR _?datacount@?1??ProcessPulseAirPcm2@@9@9, ebp

; 823  : 			}
; 824  : 			else

	jmp	$L27250
$L27249:

; 825  : 			{	// Second data chunk - get joystick position from channel data
; 826  : 				Position[0] = smooth(Position[0], Convert20bits(data[2]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm2@@9@9+8
	call	@Convert20bits@4
	cmp	eax, ebp
	jge	SHORT $L29451
	mov	eax, DWORD PTR _Position
	jmp	SHORT $L29450
$L29451:
	mov	ecx, DWORD PTR _Position
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29453
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29450
$L29453:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29450:

; 827  : 				Position[1] = smooth(Position[1], Convert20bits(data[7]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm2@@9@9+28
	mov	DWORD PTR _Position, eax
	call	@Convert20bits@4
	cmp	eax, ebp
	jge	SHORT $L29459
	mov	eax, DWORD PTR _Position+4
	jmp	SHORT $L29458
$L29459:
	mov	ecx, DWORD PTR _Position+4
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29461
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29458
$L29461:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29458:

; 828  : 				Position[2] = smooth(Position[2], Convert20bits(data[6]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm2@@9@9+24
	mov	DWORD PTR _Position+4, eax
	call	@Convert20bits@4
	cmp	eax, ebp
	jge	SHORT $L29467
	mov	eax, DWORD PTR _Position+8
	jmp	SHORT $L29466
$L29467:
	mov	ecx, DWORD PTR _Position+8
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29469
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29466
$L29469:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29466:

; 829  : 				Position[3] = smooth(Position[3], Convert20bits(data[3]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm2@@9@9+12
	mov	DWORD PTR _Position+8, eax
	call	@Convert20bits@4
	cmp	eax, ebp
	jge	SHORT $L29475
	mov	eax, DWORD PTR _Position+12
	jmp	SHORT $L29474
$L29475:
	mov	ecx, DWORD PTR _Position+12
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29477
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29474
$L29477:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29474:

; 830  : 				Position[4] = smooth(Position[4], Convert20bits(data[1]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm2@@9@9+4
	mov	DWORD PTR _Position+12, eax
	call	@Convert20bits@4
	cmp	eax, ebp
	jge	SHORT $L29483
	mov	eax, DWORD PTR _Position+16
	jmp	SHORT $L29482
$L29483:
	mov	ecx, DWORD PTR _Position+16
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29485
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29482
$L29485:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29482:

; 831  : 				Position[5] = smooth(Position[5], Convert20bits(data[5]));

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseAirPcm2@@9@9+20
	mov	DWORD PTR _Position+16, eax
	call	@Convert20bits@4
	cmp	eax, ebp
	jge	SHORT $L29491
	mov	eax, DWORD PTR _Position+20
	jmp	SHORT $L29490
$L29491:
	mov	ecx, DWORD PTR _Position+20
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jg	SHORT $L29493
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L29490
$L29493:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
$L29490:
	mov	DWORD PTR _Position+20, eax
$L27250:

; 832  : #ifdef PPJOY
; 833  : 				SendPPJoy(6, Position);
; 834  : #endif
; 835  : 			};
; 836  : 			sync = 1;		// Sync bit is set for the first 10 bits of the chunk (No channel data here)

	mov	DWORD PTR _?sync@?1??ProcessPulseAirPcm2@@9@9, 1

; 837  : 			bitstream = 0;

	mov	DWORD PTR _?bitstream@?1??ProcessPulseAirPcm2@@9@9, ebp

; 838  : 			bitcount = -1;

	or	edx, -1

; 839  : 			chunk = input;	// Mark chunk polarity - 0: Low channels, 1: High channels

	mov	DWORD PTR _?chunk@?1??ProcessPulseAirPcm2@@9@9, ebx

; 844  : 		{
; 845  : 			shift = 7;	// Read the first 10 bits

	mov	esi, 7

; 846  : 		}
; 847  : 		else

	jmp	SHORT $L27252
$L27248:

; 840  : 			//return 0;
; 841  : 		};
; 842  : 		
; 843  : 		if (sync) 

	cmp	DWORD PTR _?sync@?1??ProcessPulseAirPcm2@@9@9, ebp
	je	SHORT $L27251
	mov	edx, DWORD PTR _?bitcount@?1??ProcessPulseAirPcm2@@9@9

; 844  : 		{
; 845  : 			shift = 7;	// Read the first 10 bits

	mov	esi, 7

; 846  : 		}
; 847  : 		else

	jmp	SHORT $L27252
$L27251:

; 848  : 		{
; 849  : 			shift =20; // Read a channel data

	mov	edx, DWORD PTR _?bitcount@?1??ProcessPulseAirPcm2@@9@9
	mov	esi, 20					; 00000014H
$L27252:

; 850  : 		};
; 851  : 
; 852  : 		bitstream = ((bitstream << 1) + 1) << (pulse - 1);

	mov	eax, DWORD PTR _?bitstream@?1??ProcessPulseAirPcm2@@9@9
	lea	ecx, DWORD PTR [edi-1]

; 853  : 		bitcount += pulse;

	add	edx, edi
	lea	eax, DWORD PTR [eax+eax+1]
	mov	DWORD PTR _?bitcount@?1??ProcessPulseAirPcm2@@9@9, edx
	shl	eax, cl

; 854  : 		
; 855  : 		if (bitcount >=shift) 

	cmp	edx, esi
	mov	DWORD PTR _?bitstream@?1??ProcessPulseAirPcm2@@9@9, eax
	jb	SHORT $L29498

; 856  : 		{
; 857  : 			bitcount -= shift;

	sub	edx, esi

; 858  : 			data[datacount] = (bitstream >> bitcount) & 0xFFFFF; // Put raw 20-bit channel data
; 859  : 			datacount++;
; 860  : 			sync = 0;

	mov	DWORD PTR _?sync@?1??ProcessPulseAirPcm2@@9@9, ebp
	mov	ecx, edx
	mov	DWORD PTR _?bitcount@?1??ProcessPulseAirPcm2@@9@9, edx
	shr	eax, cl
	mov	ecx, DWORD PTR _?datacount@?1??ProcessPulseAirPcm2@@9@9
	and	eax, 1048575				; 000fffffH
	mov	DWORD PTR _?data@?1??ProcessPulseAirPcm2@@9@9[ecx*4], eax
	inc	ecx

; 861  : 			if (datacount>=8)

	cmp	ecx, 8
	mov	DWORD PTR _?datacount@?1??ProcessPulseAirPcm2@@9@9, ecx
	jl	SHORT $L29498

; 862  : 				datacount = 0;

	mov	DWORD PTR _?datacount@?1??ProcessPulseAirPcm2@@9@9, ebp
$L29498:
	pop	edi
	pop	esi
	pop	ebp

; 863  : 		};
; 864  : 
; 865  : 		return 0;

	xor	eax, eax
	pop	ebx

; 866  : }

	add	esp, 12					; 0000000cH
	ret	0
_ProcessPulseAirPcm2 ENDP
_TEXT	ENDS
;	COMDAT @Convert20bits@4
_TEXT	SEGMENT
@Convert20bits@4 PROC NEAR				; COMDAT

; 761  : 	int quartet[5];
; 762  : 	int value;
; 763  : 
; 764  : 	quartet[4] = air2_symbol[((in>>16)&0xF)];

	mov	eax, ecx
	push	edi
	sar	eax, 16					; 00000010H
	and	eax, 15					; 0000000fH
	mov	edi, DWORD PTR _air2_symbol[eax*4]

; 765  : 	if (quartet[4]<0)

	test	edi, edi
	jge	SHORT $L27218

; 766  : 		return -1;

	or	eax, -1
	pop	edi

; 786  : }

	ret	0
$L27218:

; 767  : 
; 768  : 	quartet[3] = air2_symbol[((in>>12)&0xF)];

	mov	edx, ecx
	push	esi
	sar	edx, 12					; 0000000cH
	and	edx, 15					; 0000000fH

; 769  : 	if (quartet[4]<0)
; 770  : 		return -1;
; 771  : 
; 772  : 	quartet[2] = air2_symbol[((in>>8 )&0xF)];
; 773  : 	if (quartet[4]<0)
; 774  : 		return -1;
; 775  : 
; 776  : 	quartet[1] = air2_symbol[((in>>4 )&0xF)];

	mov	esi, ecx
	sar	esi, 4
	mov	eax, DWORD PTR _air2_symbol[edx*4]
	mov	edx, ecx
	and	esi, 15					; 0000000fH

; 777  : 	if (quartet[4]<0)
; 778  : 		return -1;
; 779  : 
; 780  : 	quartet[0] = air2_symbol[((in>>0 )&0xC)];

	and	ecx, 12					; 0000000cH
	sar	edx, 8
	mov	esi, DWORD PTR _air2_symbol[esi*4]
	mov	ecx, DWORD PTR _air2_symbol[ecx*4]
	and	edx, 15					; 0000000fH

; 781  : 	if (quartet[4]<0)
; 782  : 		return -1;
; 783  : 
; 784  : 	value = quartet[4] + (quartet[3]<<2) + (quartet[2]<<4) + (quartet[1]<<6) + (quartet[0]<<8);
; 785  : 	return 1023-2*value;

	lea	ecx, DWORD PTR [esi+ecx*4]
	pop	esi
	mov	edx, DWORD PTR _air2_symbol[edx*4]
	lea	edx, DWORD PTR [edx+ecx*4]
	lea	eax, DWORD PTR [eax+edx*4]
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	eax, 1023				; 000003ffH
	shl	ecx, 1
	sub	eax, ecx
	pop	edi

; 786  : }

	ret	0
@Convert20bits@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@PHFI@?6?$CFs?5?9?5ProcessPulseJrPcm?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	__real@8@3ffd8b827100b2928000
PUBLIC	__real@8@3ffe8000000000000000
PUBLIC	__real@8@3ffc8b827100b2928000
EXTRN	_floor:NEAR
EXTRN	__ftol:NEAR
_BSS	SEGMENT
_?data@?1??ProcessPulseJrPcm@@9@9 DD 01eH DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BM@PHFI@?6?$CFs?5?9?5ProcessPulseJrPcm?$CI?$CFd?$CJ?$AA@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0BM@PHFI@?6?$CFs?5?9?5ProcessPulseJrPcm?$CI?$CFd?$CJ?$AA@ DB 0aH, '%'
	DB	's - ProcessPulseJrPcm(%d)', 00H		; `string'
_DATA	ENDS
;	COMDAT __real@8@3ffd8b827100b2928000
CONST	SEGMENT
__real@8@3ffd8b827100b2928000 DQ 03fd1704e20165250r ; 0.27248
CONST	ENDS
;	COMDAT __real@8@3ffe8000000000000000
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT __real@8@3ffc8b827100b2928000
CONST	SEGMENT
__real@8@3ffc8b827100b2928000 DQ 03fc1704e20165250r ; 0.13624
CONST	ENDS
;	COMDAT _ProcessPulseJrPcm
_TEXT	SEGMENT
_width$ = 8
_tbuffer$ = -12
_ProcessPulseJrPcm PROC NEAR				; COMDAT

; 873  :     static int sync = 0;
; 874  : 
; 875  :     static unsigned int bitcount = 0;
; 876  :     static unsigned int bitstream = 0;
; 877  :     static int data[30];
; 878  :     static int datacount = 0;
; 879  : 	char tbuffer [9];
; 880  : 	static int i = 0;
; 881  : 
; 882  : 	if (gDebugLevel>=2 && gCtrlLogFile && !(i++%50))

	mov	eax, DWORD PTR _gDebugLevel
	sub	esp, 12					; 0000000cH
	push	esi
	xor	esi, esi
	cmp	eax, 2
	jl	SHORT $L27274
	cmp	DWORD PTR _gCtrlLogFile, esi
	je	SHORT $L27274
	mov	ecx, DWORD PTR _?i@?1??ProcessPulseJrPcm@@9@9
	push	edi
	mov	eax, ecx
	mov	edi, 50					; 00000032H
	cdq
	idiv	edi
	inc	ecx
	pop	edi
	mov	DWORD PTR _?i@?1??ProcessPulseJrPcm@@9@9, ecx
	test	edx, edx
	jne	SHORT $L27274

; 883  : 		fprintf(gCtrlLogFile,"\n%s - ProcessPulseJrPcm(%d)", _strtime( tbuffer ), width);

	mov	eax, DWORD PTR _width$[esp+12]
	lea	ecx, DWORD PTR _tbuffer$[esp+16]
	push	eax
	push	ecx
	call	__strtime
	mov	edx, DWORD PTR _gCtrlLogFile
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BM@PHFI@?6?$CFs?5?9?5ProcessPulseJrPcm?$CI?$CFd?$CJ?$AA@ ; `string'
	push	edx
	call	_fprintf
	add	esp, 16					; 00000010H
$L27274:

; 884  : 
; 885  : 
; 886  :     if (sync == 0 && (int)floor(2.0 * width / PW_JR + 0.5) == 5) {

	cmp	DWORD PTR _?sync@?1??ProcessPulseJrPcm@@9@9, esi
	jne	SHORT $L27278
	fild	DWORD PTR _width$[esp+12]
	sub	esp, 8
	fmul	QWORD PTR __real@8@3ffd8b827100b2928000
	fadd	QWORD PTR __real@8@3ffe8000000000000000
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol
	cmp	eax, 5
	jne	SHORT $L27277

; 887  :         sync = 1;
; 888  :         bitstream = 0;

	mov	DWORD PTR _?bitstream@?1??ProcessPulseJrPcm@@9@9, esi

; 889  :         bitcount = -1;
; 890  :         datacount = 0;

	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPcm@@9@9, esi
	mov	DWORD PTR _?sync@?1??ProcessPulseJrPcm@@9@9, 1
	mov	DWORD PTR _?bitcount@?1??ProcessPulseJrPcm@@9@9, -1

; 918  : #ifdef PPJOY
; 919  : 				SendPPJoy(8, Position);
; 920  : #endif
; 921  :     };
; 922  : 
; 923  : 	 return 0;

	xor	eax, eax
	pop	esi

; 924  : }

	add	esp, 12					; 0000000cH
	ret	0
$L27277:

; 891  :         return 0;
; 892  :     }
; 893  : 
; 894  :     if (!sync) return 0;

	cmp	DWORD PTR _?sync@?1??ProcessPulseJrPcm@@9@9, esi
	je	$L27284
$L27278:

; 895  : 
; 896  :     width = (int)floor((double)width / PW_JR + 0.5);

	fild	DWORD PTR _width$[esp+12]
	sub	esp, 8
	fmul	QWORD PTR __real@8@3ffc8b827100b2928000
	fadd	QWORD PTR __real@8@3ffe8000000000000000
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol

; 897  :     bitstream = ((bitstream << 1) + 1) << (width - 1);

	mov	ecx, DWORD PTR _?bitstream@?1??ProcessPulseJrPcm@@9@9
	lea	edx, DWORD PTR [ecx+ecx+1]
	lea	ecx, DWORD PTR [eax-1]
	shl	edx, cl

; 898  :     bitcount += width;

	mov	ecx, DWORD PTR _?bitcount@?1??ProcessPulseJrPcm@@9@9
	add	ecx, eax

; 899  : 
; 900  :     if (bitcount >= 8) {

	cmp	ecx, 8
	mov	DWORD PTR _?bitcount@?1??ProcessPulseJrPcm@@9@9, ecx
	mov	DWORD PTR _?bitstream@?1??ProcessPulseJrPcm@@9@9, edx
	jb	SHORT $L27282

; 901  :         bitcount -= 8;

	sub	ecx, 8

; 902  :         if ((data[datacount++] = jr_symbol[(bitstream >> bitcount) & 0xFF]) < 0) {

	mov	eax, DWORD PTR _?datacount@?1??ProcessPulseJrPcm@@9@9
	shr	edx, cl
	mov	DWORD PTR _?bitcount@?1??ProcessPulseJrPcm@@9@9, ecx
	and	edx, 255				; 000000ffH
	inc	eax
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPcm@@9@9, eax
	mov	edx, DWORD PTR _jr_symbol[edx*4]
	mov	DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9[eax*4-4], edx
	cmp	edx, esi

; 903  :             sync = 0;
; 904  :             return 0;

	jl	$L27295
$L27282:

; 905  :         }
; 906  :     }
; 907  : 
; 908  :     switch (datacount) {

	mov	edx, DWORD PTR _?datacount@?1??ProcessPulseJrPcm@@9@9
	lea	eax, DWORD PTR [edx-3]
	cmp	eax, 27					; 0000001bH
	ja	$L27284
	xor	ecx, ecx
	mov	cl, BYTE PTR $L29513[eax]
	jmp	DWORD PTR $L29514[ecx*4]
$L27287:

; 909  :         case 3:  Position[2] = 1023 - ((data[1] << 5) | data[2]); break;

	mov	edx, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+4
	mov	esi, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+8
	shl	edx, 5
	or	edx, esi
	mov	eax, 1023				; 000003ffH
	sub	eax, edx
	pop	esi
	mov	DWORD PTR _Position+8, eax

; 918  : #ifdef PPJOY
; 919  : 				SendPPJoy(8, Position);
; 920  : #endif
; 921  :     };
; 922  : 
; 923  : 	 return 0;

	xor	eax, eax

; 924  : }

	add	esp, 12					; 0000000cH
	ret	0
$L27288:

; 910  :         case 6:  Position[0] = 1023 - ((data[4] << 5) | data[5]); break;

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+16
	mov	edx, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+20
	shl	ecx, 5
	or	ecx, edx
	mov	edx, 1023				; 000003ffH
	sub	edx, ecx

; 918  : #ifdef PPJOY
; 919  : 				SendPPJoy(8, Position);
; 920  : #endif
; 921  :     };
; 922  : 
; 923  : 	 return 0;

	xor	eax, eax
	mov	DWORD PTR _Position, edx
	pop	esi

; 924  : }

	add	esp, 12					; 0000000cH
	ret	0
$L27289:

; 911  :         case 11: Position[5] = 1023 - ((data[9] << 5) | data[10]); break;

	mov	eax, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+36
	mov	esi, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+40
	shl	eax, 5
	or	eax, esi
	mov	ecx, 1023				; 000003ffH
	sub	ecx, eax

; 918  : #ifdef PPJOY
; 919  : 				SendPPJoy(8, Position);
; 920  : #endif
; 921  :     };
; 922  : 
; 923  : 	 return 0;

	xor	eax, eax
	mov	DWORD PTR _Position+20, ecx
	pop	esi

; 924  : }

	add	esp, 12					; 0000000cH
	ret	0
$L27290:

; 912  :         case 14: Position[7] = 1023 - ((data[12] << 5) | data[13]); break;

	mov	edx, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+48
	mov	esi, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+52
	shl	edx, 5
	or	edx, esi
	mov	eax, 1023				; 000003ffH
	sub	eax, edx
	pop	esi
	mov	DWORD PTR _Position+28, eax

; 918  : #ifdef PPJOY
; 919  : 				SendPPJoy(8, Position);
; 920  : #endif
; 921  :     };
; 922  : 
; 923  : 	 return 0;

	xor	eax, eax

; 924  : }

	add	esp, 12					; 0000000cH
	ret	0
$L27291:

; 913  :         case 18: Position[3] = 1023 - ((data[16] << 5) | data[17]); break;

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+64
	mov	edx, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+68
	shl	ecx, 5
	or	ecx, edx
	mov	edx, 1023				; 000003ffH
	sub	edx, ecx

; 918  : #ifdef PPJOY
; 919  : 				SendPPJoy(8, Position);
; 920  : #endif
; 921  :     };
; 922  : 
; 923  : 	 return 0;

	xor	eax, eax
	mov	DWORD PTR _Position+12, edx
	pop	esi

; 924  : }

	add	esp, 12					; 0000000cH
	ret	0
$L27292:

; 914  :         case 21: Position[1] = 1023 - ((data[19] << 5) | data[20]); break;

	mov	eax, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+76
	mov	esi, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+80
	shl	eax, 5
	or	eax, esi
	mov	ecx, 1023				; 000003ffH
	sub	ecx, eax

; 918  : #ifdef PPJOY
; 919  : 				SendPPJoy(8, Position);
; 920  : #endif
; 921  :     };
; 922  : 
; 923  : 	 return 0;

	xor	eax, eax
	mov	DWORD PTR _Position+4, ecx
	pop	esi

; 924  : }

	add	esp, 12					; 0000000cH
	ret	0
$L27293:

; 915  :         case 26: Position[4] = 1023 - ((data[24] << 5) | data[25]); break;

	mov	edx, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+96
	mov	esi, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+100
	shl	edx, 5
	or	edx, esi
	mov	eax, 1023				; 000003ffH
	sub	eax, edx
	pop	esi
	mov	DWORD PTR _Position+16, eax

; 918  : #ifdef PPJOY
; 919  : 				SendPPJoy(8, Position);
; 920  : #endif
; 921  :     };
; 922  : 
; 923  : 	 return 0;

	xor	eax, eax

; 924  : }

	add	esp, 12					; 0000000cH
	ret	0
$L27294:

; 916  :         case 29: Position[6] = 1023 - ((data[27] << 5) | data[28]); break;

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+108
	mov	edx, DWORD PTR _?data@?1??ProcessPulseJrPcm@@9@9+112
	shl	ecx, 5
	or	ecx, edx
	mov	edx, 1023				; 000003ffH
	sub	edx, ecx

; 918  : #ifdef PPJOY
; 919  : 				SendPPJoy(8, Position);
; 920  : #endif
; 921  :     };
; 922  : 
; 923  : 	 return 0;

	xor	eax, eax
	mov	DWORD PTR _Position+24, edx
	pop	esi

; 924  : }

	add	esp, 12					; 0000000cH
	ret	0
$L27295:

; 917  :         case 30: sync = 0;

	mov	DWORD PTR _?sync@?1??ProcessPulseJrPcm@@9@9, esi
$L27284:

; 918  : #ifdef PPJOY
; 919  : 				SendPPJoy(8, Position);
; 920  : #endif
; 921  :     };
; 922  : 
; 923  : 	 return 0;

	xor	eax, eax
	pop	esi

; 924  : }

	add	esp, 12					; 0000000cH
	ret	0
	npad	3
$L29514:
	DD	$L27287
	DD	$L27288
	DD	$L27289
	DD	$L27290
	DD	$L27291
	DD	$L27292
	DD	$L27293
	DD	$L27294
	DD	$L27295
	DD	$L27284
$L29513:
	DB	0
	DB	9
	DB	9
	DB	1
	DB	9
	DB	9
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	7
	DB	8
_ProcessPulseJrPcm ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@PCLJ@?6?$CFs?5?9?5ProcessPulseFutabaPcm?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	__real@8@3ffc9a9cdac6e8c4f800
_BSS	SEGMENT
_?data@?1??ProcessPulseFutabaPcm@@9@9 DD 020H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CA@PCLJ@?6?$CFs?5?9?5ProcessPulseFutabaPcm?$CI?$CFd?$CJ?$AA@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0CA@PCLJ@?6?$CFs?5?9?5ProcessPulseFutabaPcm?$CI?$CFd?$CJ?$AA@ DB 0aH
	DB	'%s - ProcessPulseFutabaPcm(%d)', 00H	; `string'
_DATA	ENDS
;	COMDAT __real@8@3ffc9a9cdac6e8c4f800
CONST	SEGMENT
__real@8@3ffc9a9cdac6e8c4f800 DQ 03fc3539b58dd189fr ; 0.150989
CONST	ENDS
;	COMDAT _ProcessPulseFutabaPcm
_TEXT	SEGMENT
_width$ = 8
_tbuffer$ = -12
_ProcessPulseFutabaPcm PROC NEAR			; COMDAT

; 932  :     static int sync = 0;
; 933  : 
; 934  :     static unsigned int bit = 0;
; 935  :     static unsigned int bitcount = 0;
; 936  :     static unsigned int bitstream = 0;
; 937  : 
; 938  :     static int data[32];
; 939  :     static int datacount = 0;
; 940  : 	char tbuffer [9];
; 941  : 	static int i = 0;
; 942  : 
; 943  : 	if (gDebugLevel>=2 && gCtrlLogFile && !(i++%50))

	mov	eax, DWORD PTR _gDebugLevel
	sub	esp, 12					; 0000000cH
	push	ebx
	xor	ebx, ebx
	push	esi
	cmp	eax, 2
	push	edi
	jl	SHORT $L27317
	cmp	DWORD PTR _gCtrlLogFile, ebx
	je	SHORT $L27317
	mov	ecx, DWORD PTR _?i@?1??ProcessPulseFutabaPcm@@9@9
	mov	esi, 50					; 00000032H
	mov	eax, ecx
	cdq
	idiv	esi
	inc	ecx
	mov	DWORD PTR _?i@?1??ProcessPulseFutabaPcm@@9@9, ecx
	test	edx, edx
	jne	SHORT $L27317

; 944  : 		fprintf(gCtrlLogFile,"\n%s - ProcessPulseFutabaPcm(%d)", _strtime( tbuffer ), width);

	mov	eax, DWORD PTR _width$[esp+20]
	lea	ecx, DWORD PTR _tbuffer$[esp+24]
	push	eax
	push	ecx
	call	__strtime
	mov	edx, DWORD PTR _gCtrlLogFile
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CA@PCLJ@?6?$CFs?5?9?5ProcessPulseFutabaPcm?$CI?$CFd?$CJ?$AA@ ; `string'
	push	edx
	call	_fprintf
	add	esp, 16					; 00000010H
$L27317:

; 945  : 
; 946  :     width = (int)floor(width / PW_FUTABA + 0.5);

	fild	DWORD PTR _width$[esp+20]
	sub	esp, 8
	fmul	QWORD PTR __real@8@3ffc9a9cdac6e8c4f800
	fadd	QWORD PTR __real@8@3ffe8000000000000000
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol

; 947  : 
; 948  :     if (sync == 0 && width == 18) {

	mov	edi, DWORD PTR _?sync@?1??ProcessPulseFutabaPcm@@9@9
	cmp	edi, ebx
	jne	SHORT $L27321
	cmp	eax, 18					; 00000012H
	jne	$L29517
	pop	edi

; 949  :         sync = 1;
; 950  :         bit = 0;

	mov	DWORD PTR _?bit@?1??ProcessPulseFutabaPcm@@9@9, ebx

; 951  :         bitstream = 0;

	mov	DWORD PTR _?bitstream@?1??ProcessPulseFutabaPcm@@9@9, ebx

; 952  :         bitcount = 0;

	mov	DWORD PTR _?bitcount@?1??ProcessPulseFutabaPcm@@9@9, ebx

; 953  :         datacount = 0;

	mov	DWORD PTR _?datacount@?1??ProcessPulseFutabaPcm@@9@9, ebx
	pop	esi
	mov	DWORD PTR _?sync@?1??ProcessPulseFutabaPcm@@9@9, 1

; 998  : #ifdef PPJOY
; 999  : 				SendPPJoy(8, Position);
; 1000 : #endif
; 1001 :     };
; 1002 : 
; 1003 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1004 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27321:

; 954  :         return 0;
; 955  :     }
; 956  : 
; 957  :     if (!sync) return 0;
; 958  : 
; 959  :     bitstream = (bitstream << width) | (bit >> (32 - width));

	mov	esi, DWORD PTR _?bit@?1??ProcessPulseFutabaPcm@@9@9
	mov	ecx, 32					; 00000020H
	sub	ecx, eax
	mov	edx, esi
	push	ebp
	mov	ebp, DWORD PTR _?bitstream@?1??ProcessPulseFutabaPcm@@9@9
	shr	edx, cl
	mov	ecx, eax
	shl	ebp, cl

; 960  :     bit ^= 0xFFFFFFFF;
; 961  :     bitcount += width;

	mov	ecx, DWORD PTR _?bitcount@?1??ProcessPulseFutabaPcm@@9@9
	not	esi
	add	ecx, eax
	mov	DWORD PTR _?bit@?1??ProcessPulseFutabaPcm@@9@9, esi
	or	edx, ebp

; 962  : 
; 963  :     if (sync == 1) {

	cmp	edi, 1
	mov	DWORD PTR _?bitstream@?1??ProcessPulseFutabaPcm@@9@9, edx
	mov	DWORD PTR _?bitcount@?1??ProcessPulseFutabaPcm@@9@9, ecx
	pop	ebp
	jne	SHORT $L27322

; 964  :         if (bitcount >= 6) {

	cmp	ecx, 6
	jb	$L29517

; 965  :             bitcount -= 6;

	sub	ecx, 6

; 966  :             if (((bitstream >> bitcount) & 0x3F) == 0x03) {

	shr	edx, cl
	mov	DWORD PTR _?bitcount@?1??ProcessPulseFutabaPcm@@9@9, ecx
	and	edx, 63					; 0000003fH
	cmp	edx, 3
	jne	SHORT $L27324
	pop	edi

; 967  :                 sync = 2;
; 968  :                 datacount = 0;

	mov	DWORD PTR _?datacount@?1??ProcessPulseFutabaPcm@@9@9, ebx
	pop	esi
	mov	DWORD PTR _?sync@?1??ProcessPulseFutabaPcm@@9@9, 2

; 998  : #ifdef PPJOY
; 999  : 				SendPPJoy(8, Position);
; 1000 : #endif
; 1001 :     };
; 1002 : 
; 1003 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1004 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27324:

; 969  :             } else if (((bitstream >> bitcount) & 0x3F) == 0x00) {

	cmp	edx, ebx
	jne	$L27326

; 970  :                 sync = 2;
; 971  :                 datacount = 16;
; 972  :                 bitcount -= 2;

	sub	ecx, 2
	pop	edi
	pop	esi
	mov	DWORD PTR _?sync@?1??ProcessPulseFutabaPcm@@9@9, 2
	mov	DWORD PTR _?datacount@?1??ProcessPulseFutabaPcm@@9@9, 16 ; 00000010H
	mov	DWORD PTR _?bitcount@?1??ProcessPulseFutabaPcm@@9@9, ecx

; 998  : #ifdef PPJOY
; 999  : 				SendPPJoy(8, Position);
; 1000 : #endif
; 1001 :     };
; 1002 : 
; 1003 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1004 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27322:

; 973  :             } else {
; 974  :                 sync = 0;
; 975  :             }
; 976  :         }
; 977  :         return 0;
; 978  :     }
; 979  : 
; 980  :     if (bitcount >= 10) {

	cmp	ecx, 10					; 0000000aH
	jb	SHORT $L27329

; 981  :         bitcount -= 10;

	sub	ecx, 10					; 0000000aH

; 982  :         if ((data[datacount++] = futaba_symbol[(bitstream >> bitcount) & 0x3FF]) < 0) {

	mov	eax, DWORD PTR _?datacount@?1??ProcessPulseFutabaPcm@@9@9
	shr	edx, cl
	mov	DWORD PTR _?bitcount@?1??ProcessPulseFutabaPcm@@9@9, ecx
	and	edx, 1023				; 000003ffH
	inc	eax
	mov	DWORD PTR _?datacount@?1??ProcessPulseFutabaPcm@@9@9, eax
	mov	edx, DWORD PTR _futaba_symbol[edx*4]
	mov	DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9[eax*4-4], edx
	cmp	edx, ebx

; 983  :             sync = 0;
; 984  :             return 0;

	jl	$L27326
$L27329:

; 985  :         }
; 986  :     }
; 987  : 
; 988  :     switch (datacount) {

	mov	eax, DWORD PTR _?datacount@?1??ProcessPulseFutabaPcm@@9@9
	add	eax, -3					; fffffffdH
	cmp	eax, 29					; 0000001dH
	ja	$L29517
	xor	ecx, ecx
	mov	cl, BYTE PTR $L29521[eax]
	jmp	DWORD PTR $L29522[ecx*4]
$L27334:

; 989  :         case 3:  if ((data[0] >> 4) != 0)  Position[2] = (data[1] << 4) | (data[2] >> 2); break;

	test	DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9, -16 ; fffffff0H
	je	$L29517
	mov	edx, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+8
	mov	eax, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+4
	sar	edx, 2
	shl	eax, 4
	or	edx, eax
	pop	edi
	pop	esi
	mov	DWORD PTR _Position+8, edx

; 998  : #ifdef PPJOY
; 999  : 				SendPPJoy(8, Position);
; 1000 : #endif
; 1001 :     };
; 1002 : 
; 1003 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1004 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27336:

; 990  :         case 7:                            Position[3] = (data[5] << 4) | (data[6] >> 2); break;

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+24
	mov	edx, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+20
	sar	ecx, 2
	shl	edx, 4
	or	ecx, edx
	pop	edi
	pop	esi
	mov	DWORD PTR _Position+12, ecx

; 998  : #ifdef PPJOY
; 999  : 				SendPPJoy(8, Position);
; 1000 : #endif
; 1001 :     };
; 1002 : 
; 1003 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1004 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27337:

; 991  :         case 11: if ((data[0] >> 4) != 0)  Position[4] = (data[9] << 4) | (data[10] >> 2); break;

	test	DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9, -16 ; fffffff0H
	je	$L29517
	mov	eax, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+40
	mov	ecx, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+36
	sar	eax, 2
	shl	ecx, 4
	or	eax, ecx
	pop	edi
	mov	DWORD PTR _Position+16, eax
	pop	esi

; 998  : #ifdef PPJOY
; 999  : 				SendPPJoy(8, Position);
; 1000 : #endif
; 1001 :     };
; 1002 : 
; 1003 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1004 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27339:

; 992  :         case 15: sync = 0;

	mov	DWORD PTR _?sync@?1??ProcessPulseFutabaPcm@@9@9, ebx
$L27340:

; 993  :         case 19:                           Position[1] = (data[17] << 4) | (data[18] >> 2); break;

	mov	edx, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+72
	mov	eax, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+68
	sar	edx, 2
	shl	eax, 4
	or	edx, eax
	pop	edi
	pop	esi
	mov	DWORD PTR _Position+4, edx

; 998  : #ifdef PPJOY
; 999  : 				SendPPJoy(8, Position);
; 1000 : #endif
; 1001 :     };
; 1002 : 
; 1003 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1004 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27341:

; 994  :         case 23: if ((data[16] >> 4) != 1) Position[0] = (data[21] << 4) | (data[22] >> 2); break;

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+64
	and	ecx, -16				; fffffff0H
	cmp	ecx, 16					; 00000010H
	je	SHORT $L29517
	mov	edx, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+88
	mov	eax, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+84
	sar	edx, 2
	shl	eax, 4
	or	edx, eax
	pop	edi
	pop	esi
	mov	DWORD PTR _Position, edx

; 998  : #ifdef PPJOY
; 999  : 				SendPPJoy(8, Position);
; 1000 : #endif
; 1001 :     };
; 1002 : 
; 1003 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1004 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27343:

; 995  :         case 27:                           Position[5] = (data[25] << 4) | (data[26] >> 2); break;

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+104
	mov	edx, DWORD PTR _?data@?1??ProcessPulseFutabaPcm@@9@9+100
	sar	ecx, 2
	shl	edx, 4
	or	ecx, edx
	pop	edi
	pop	esi
	mov	DWORD PTR _Position+20, ecx

; 998  : #ifdef PPJOY
; 999  : 				SendPPJoy(8, Position);
; 1000 : #endif
; 1001 :     };
; 1002 : 
; 1003 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1004 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27326:

; 996  :         case 31: break;
; 997  :         case 32: sync = 0;

	mov	DWORD PTR _?sync@?1??ProcessPulseFutabaPcm@@9@9, ebx
$L29517:
	pop	edi
	pop	esi

; 998  : #ifdef PPJOY
; 999  : 				SendPPJoy(8, Position);
; 1000 : #endif
; 1001 :     };
; 1002 : 
; 1003 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1004 : }

	add	esp, 12					; 0000000cH
	ret	0
	npad	1
$L29522:
	DD	$L27334
	DD	$L27336
	DD	$L27337
	DD	$L27339
	DD	$L27340
	DD	$L27341
	DD	$L27343
	DD	$L27326
	DD	$L29517
$L29521:
	DB	0
	DB	8
	DB	8
	DB	8
	DB	1
	DB	8
	DB	8
	DB	8
	DB	2
	DB	8
	DB	8
	DB	8
	DB	3
	DB	8
	DB	8
	DB	8
	DB	4
	DB	8
	DB	8
	DB	8
	DB	5
	DB	8
	DB	8
	DB	8
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
_ProcessPulseFutabaPcm ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@INEJ@?6?$CFs?5?9?5ProcessPulsePpm?$CIwidth?$DN?$CFd?0?5@ ; `string'
PUBLIC	??_C@_0N@NFKC@?5data?$FL?$CFd?$FN?$DN?$CFd?$AA@	; `string'
PUBLIC	__real@8@4003b000000000000000
PUBLIC	__real@8@4003f000000000000000
PUBLIC	__real@8@4003a3d70a3d70a3d800
PUBLIC	__real@8@40098000000000000000
_BSS	SEGMENT
_?data@?1??ProcessPulsePpm@@9@9 DD 0eH DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CK@INEJ@?6?$CFs?5?9?5ProcessPulsePpm?$CIwidth?$DN?$CFd?0?5@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0CK@INEJ@?6?$CFs?5?9?5ProcessPulsePpm?$CIwidth?$DN?$CFd?0?5@ DB 0aH
	DB	'%s - ProcessPulsePpm(width=%d, input=%d)', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NFKC@?5data?$FL?$CFd?$FN?$DN?$CFd?$AA@
_DATA	SEGMENT
??_C@_0N@NFKC@?5data?$FL?$CFd?$FN?$DN?$CFd?$AA@ DB ' data[%d]=%d', 00H ; `string'
_DATA	ENDS
;	COMDAT __real@8@4003b000000000000000
CONST	SEGMENT
__real@8@4003b000000000000000 DQ 04036000000000000r ; 22
CONST	ENDS
;	COMDAT __real@8@4003f000000000000000
CONST	SEGMENT
__real@8@4003f000000000000000 DQ 0403e000000000000r ; 30
CONST	ENDS
;	COMDAT __real@8@4003a3d70a3d70a3d800
CONST	SEGMENT
__real@8@4003a3d70a3d70a3d800 DQ 040347ae147ae147br ; 20.48
CONST	ENDS
;	COMDAT __real@8@40098000000000000000
CONST	SEGMENT
__real@8@40098000000000000000 DQ 04090000000000000r ; 1024
CONST	ENDS
;	COMDAT _ProcessPulsePpm
_TEXT	SEGMENT
_width$ = 8
_input$ = 12
_tbuffer$ = -12
_ProcessPulsePpm PROC NEAR				; COMDAT

; 1016 : {

	sub	esp, 12					; 0000000cH
	push	esi

; 1017 :     static int sync = 0;
; 1018 : 
; 1019 :     int newdata;				/* Current width in joystick values */
; 1020 :     static int data[14];		/* Array of pulse widthes in joystick values */
; 1021 :     static int datacount = 0;	/* pulse index (corresponds to channel index) */
; 1022 : 	static int former_sync = 0;
; 1023 : 	char tbuffer [9];
; 1024 : 	static int i = 0;
; 1025 : 
; 1026 : 	if (width < 5)

	mov	esi, DWORD PTR _width$[esp+12]
	cmp	esi, 5
	push	edi

; 1027 : 		return 0;

	jl	$L29536

; 1028 : 
; 1029 : 	if (gDebugLevel>=2 && gCtrlLogFile /*&& !(i++%50)*/)

	mov	eax, DWORD PTR _gDebugLevel
	mov	edi, DWORD PTR _input$[esp+16]
	cmp	eax, 2
	jl	SHORT $L27365
	mov	eax, DWORD PTR _gCtrlLogFile
	test	eax, eax
	je	SHORT $L27365

; 1030 : 		fprintf(gCtrlLogFile,"\n%s - ProcessPulsePpm(width=%d, input=%d)", _strtime( tbuffer ), width, input);

	push	edi
	lea	eax, DWORD PTR _tbuffer$[esp+24]
	push	esi
	push	eax
	call	__strtime
	mov	ecx, DWORD PTR _gCtrlLogFile
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CK@INEJ@?6?$CFs?5?9?5ProcessPulsePpm?$CIwidth?$DN?$CFd?0?5@ ; `string'
	push	ecx
	call	_fprintf
	add	esp, 20					; 00000014H
$L27365:

; 1031 : 
; 1032 : 	/* If pulse is a separator then go to the next one */
; 1033 : 	if (width < PPM_SEP+7 || former_sync)

	fild	DWORD PTR _width$[esp+16]
	fcom	QWORD PTR __real@8@4003b000000000000000
	fnstsw	ax
	test	ah, 1
	jne	$L29534
	mov	eax, DWORD PTR _?former_sync@?1??ProcessPulsePpm@@9@9
	test	eax, eax
	jne	$L29534

; 1037 : 	};
; 1038 : 
; 1039 : 	/* sync is detected at the end of a very long pulse (over 200 samples = 4.5mSec) */
; 1040 :     if (/*sync == 0 && */width > PPM_TRIG) {

	cmp	esi, 200				; 000000c8H
	jle	SHORT $L27369

; 1041 :         sync = 1;

	mov	eax, 1
	pop	edi
	mov	DWORD PTR _?sync@?1??ProcessPulsePpm@@9@9, eax

; 1042 :         datacount = 0;
; 1043 : 		former_sync = 1;

	mov	DWORD PTR _?former_sync@?1??ProcessPulsePpm@@9@9, eax
	fstp	ST(0)
	mov	DWORD PTR _?datacount@?1??ProcessPulsePpm@@9@9, 0
	xor	eax, eax
	pop	esi

; 1097 : 	return 0;
; 1098 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27369:

; 1044 : 		return 0;
; 1045 :     }
; 1046 : 
; 1047 :     if (!sync) 

	mov	eax, DWORD PTR _?sync@?1??ProcessPulsePpm@@9@9
	test	eax, eax
	jne	SHORT $L27370
	pop	edi
	xor	eax, eax
	fstp	ST(0)
	pop	esi

; 1097 : 	return 0;
; 1098 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27370:
	push	ebx

; 1048 : 		return 0; /* still waiting for sync */
; 1049 : 
; 1050 : 
; 1051 : 	/* convert pulse width in samples to joystick position values (newdata)
; 1052 : 	joystick position of 0 correspond to width over 100 samples (2.25mSec)
; 1053 : 	joystick position of 1023 correspond to width under 30 samples (0.68mSec)*/
; 1054 : 	if (input|| JsChPostProc_selected!=-1)

	mov	ebx, DWORD PTR _JsChPostProc_selected
	test	edi, edi
	jne	SHORT $L27372
	cmp	ebx, -1
	jne	SHORT $L27372

; 1056 : 	else
; 1057 : 		newdata = (int)((width - PPM_MIN) / (PPM_MAX - PPM_MIN) * 1024);		/* Futaba */

	fsub	QWORD PTR __real@8@4003f000000000000000
	fmul	QWORD PTR __real@8@4003a3d70a3d70a3d800
	jmp	SHORT $L29537
$L27372:

; 1055 : 		newdata = (int)(1024 - (width - PPM_MIN) / (PPM_MAX - PPM_MIN) * 1024); /* JR */

	fsub	QWORD PTR __real@8@4003f000000000000000
	fmul	QWORD PTR __real@8@4003a3d70a3d70a3d800
	fsubr	QWORD PTR __real@8@40098000000000000000
$L29537:
	call	__ftol

; 1058 : 
; 1059 : 	/* Trim values into 0-1023 boundries */
; 1060 :     if (newdata < 0) newdata = 0;

	test	eax, eax
	jge	SHORT $L27376
	xor	eax, eax

; 1061 :     else if (newdata > 1023) newdata = 1023;

	jmp	SHORT $L27378
$L27376:
	cmp	eax, 1023				; 000003ffH
	jle	SHORT $L27378
	mov	eax, 1023				; 000003ffH
$L27378:

; 1062 : 
; 1063 : 	/* Update data - do not allow abrupt change */
; 1064 :     if (data[datacount] - newdata > 100) data[datacount] -= 100;

	mov	esi, DWORD PTR _?datacount@?1??ProcessPulsePpm@@9@9
	mov	ecx, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jle	SHORT $L27379
	add	ecx, -100				; ffffff9cH
	mov	DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4], ecx

; 1065 :     else if (newdata - data[datacount] > 100) data[datacount] += 100;

	jmp	SHORT $L27382
$L27379:
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L27381
	add	ecx, 100				; 00000064H
	mov	DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4], ecx

; 1066 :     else data[datacount] = (data[datacount] + newdata) / 2;

	jmp	SHORT $L27382
$L27381:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4], eax
$L27382:

; 1067 : 
; 1068 : 	
; 1069 : 	if (input|| JsChPostProc_selected!=-1)

	test	edi, edi
	jne	$L27384
	cmp	ebx, -1
	jne	$L27384

; 1071 : 	else
; 1072 : 		switch (datacount)
; 1073 : 	{ // Futaba

	cmp	esi, 11					; 0000000bH
	ja	$L27387
	jmp	DWORD PTR $L29538[esi*4]
$L27390:

; 1074 : 	case 0: 	Position[1]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	eax, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position+4, eax
	jmp	$L27387
$L27391:

; 1075 : 	case 1: 	Position[2]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	ecx, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position+8, ecx
	jmp	$L27387
$L27392:

; 1076 : 	case 2: 	Position[0]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	edx, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position, edx
	jmp	$L27387
$L27393:

; 1077 : 	case 3: 	Position[3]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	eax, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position+12, eax
	jmp	$L27387
$L27394:

; 1078 : 	case 4: 	Position[4]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	ecx, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position+16, ecx
	jmp	SHORT $L27387
$L27395:

; 1079 : 	case 5: 	Position[5]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	edx, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position+20, edx
	jmp	SHORT $L27387
$L27396:

; 1080 : 	case 6: 	Position[6]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	eax, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position+24, eax
	jmp	SHORT $L27387
$L27397:

; 1081 : 	case 7: 	Position[7]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	ecx, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position+28, ecx
	jmp	SHORT $L27387
$L27398:

; 1082 : 	case 8: 	Position[8]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	edx, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position+32, edx
	jmp	SHORT $L27387
$L27399:

; 1083 : 	case 9: 	Position[9]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	eax, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position+36, eax
	jmp	SHORT $L27387
$L27400:

; 1084 : 	case 10: 	Position[10] = data[datacount];	break;/* Assign data to joystick channels */

	mov	ecx, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position+40, ecx
	jmp	SHORT $L27387
$L27401:

; 1085 : 	case 11: 	Position[11] = data[datacount];	break;/* Assign data to joystick channels */

	mov	edx, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position+44, edx
	jmp	SHORT $L27387
$L27384:

; 1070 : 		Position[datacount] = data[datacount];	/* JR - Assign data to joystick channels */

	mov	eax, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	mov	DWORD PTR _Position[esi*4], eax
$L27387:

; 1086 : 	};
; 1087 : #ifdef PPJOY
; 1088 : 				SendPPJoy(datacount, Position);
; 1089 : #endif
; 1090 : 
; 1091 : 	if (gDebugLevel>=3 && gCtrlLogFile /*&& !(i++%50)*/)

	mov	eax, DWORD PTR _gDebugLevel
	pop	ebx
	cmp	eax, 3
	jl	SHORT $L27402
	mov	eax, DWORD PTR _gCtrlLogFile
	test	eax, eax
	je	SHORT $L27402

; 1092 : 		fprintf(gCtrlLogFile," data[%d]=%d", datacount, data[datacount]);

	mov	ecx, DWORD PTR _?data@?1??ProcessPulsePpm@@9@9[esi*4]
	push	ecx
	push	esi
	push	OFFSET FLAT:??_C@_0N@NFKC@?5data?$FL?$CFd?$FN?$DN?$CFd?$AA@ ; `string'
	push	eax
	call	_fprintf
	mov	esi, DWORD PTR _?datacount@?1??ProcessPulsePpm@@9@9
	add	esp, 16					; 00000010H
$L27402:

; 1093 : 
; 1094 : 	if (datacount == 11)	sync = 0;			/* Reset sync after channel 12 */

	cmp	esi, 11					; 0000000bH
	jne	SHORT $L27404
	mov	DWORD PTR _?sync@?1??ProcessPulsePpm@@9@9, 0
$L27404:

; 1095 : 
; 1096 :     datacount++;

	inc	esi
	pop	edi
	mov	DWORD PTR _?datacount@?1??ProcessPulsePpm@@9@9, esi
	xor	eax, eax
	pop	esi

; 1097 : 	return 0;
; 1098 : }

	add	esp, 12					; 0000000cH
	ret	0
$L29534:

; 1031 : 
; 1032 : 	/* If pulse is a separator then go to the next one */
; 1033 : 	if (width < PPM_SEP+7 || former_sync)

	fstp	ST(0)

; 1034 : 	{
; 1035 : 		former_sync = 0;

	mov	DWORD PTR _?former_sync@?1??ProcessPulsePpm@@9@9, 0
$L29536:
	pop	edi

; 1036 : 		return 0;

	xor	eax, eax
	pop	esi

; 1097 : 	return 0;
; 1098 : }

	add	esp, 12					; 0000000cH
	ret	0
	npad	3
$L29538:
	DD	$L27390
	DD	$L27391
	DD	$L27392
	DD	$L27393
	DD	$L27394
	DD	$L27395
	DD	$L27396
	DD	$L27397
	DD	$L27398
	DD	$L27399
	DD	$L27400
	DD	$L27401
_ProcessPulsePpm ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@IBDB@?6?$CFs?5?9?5ProcessPulseFutabaPpm?$CIwidt@ ; `string'
_BSS	SEGMENT
_?data@?1??ProcessPulseFutabaPpm@@9@9 DD 0eH DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DA@IBDB@?6?$CFs?5?9?5ProcessPulseFutabaPpm?$CIwidt@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0DA@IBDB@?6?$CFs?5?9?5ProcessPulseFutabaPpm?$CIwidt@ DB 0aH, '%s - '
	DB	'ProcessPulseFutabaPpm(width=%d, input=%d)', 00H ; `string'
_DATA	ENDS
;	COMDAT _ProcessPulseFutabaPpm
_TEXT	SEGMENT
_width$ = 8
_input$ = 12
_tbuffer$ = -12
_ProcessPulseFutabaPpm PROC NEAR			; COMDAT

; 1102 : {

	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 1103 :     static int sync = 0;
; 1104 : 
; 1105 :     int newdata;				/* Current width in joystick values */
; 1106 :     static int data[14];		/* Array of pulse widthes in joystick values */
; 1107 :     static int datacount = 0;	/* pulse index (corresponds to channel index) */
; 1108 : 	static int former_sync = 0;
; 1109 : 	char tbuffer [9];
; 1110 : 	static int i = 0;
; 1111 : 
; 1112 : 
; 1113 : 	if (width < 5)

	mov	edi, DWORD PTR _width$[esp+16]
	cmp	edi, 5

; 1114 : 		return 0;

	jl	$L29543

; 1115 : 
; 1116 : 	if (gDebugLevel>=2 /*&& gCtrlLogFile && !(i++%50)*/)

	mov	eax, DWORD PTR _gDebugLevel
	mov	esi, DWORD PTR _input$[esp+16]
	cmp	eax, 2
	jl	SHORT $L27424

; 1117 : 		fprintf(gCtrlLogFile,"\n%s - ProcessPulseFutabaPpm(width=%d, input=%d)", _strtime( tbuffer ), width, input);

	push	esi
	lea	eax, DWORD PTR _tbuffer$[esp+24]
	push	edi
	push	eax
	call	__strtime
	mov	ecx, DWORD PTR _gCtrlLogFile
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0DA@IBDB@?6?$CFs?5?9?5ProcessPulseFutabaPpm?$CIwidt@ ; `string'
	push	ecx
	call	_fprintf
	add	esp, 20					; 00000014H
$L27424:

; 1118 : 
; 1119 : 	/* If pulse is a separator then go to the next one */
; 1120 : 	if (!input || width < PPM_SEP+7 || former_sync)

	test	esi, esi
	je	$L27427
	fild	DWORD PTR _width$[esp+16]
	fcom	QWORD PTR __real@8@4003b000000000000000
	fnstsw	ax
	test	ah, 1
	jne	$L29541
	mov	eax, DWORD PTR _?former_sync@?1??ProcessPulseFutabaPpm@@9@9
	test	eax, eax
	jne	$L29541

; 1124 : 	};
; 1125 : 
; 1126 : 	/* sync is detected at the end of a very long pulse (over 200 samples = 4.5mSec) */
; 1127 :     if (input &&  width > PPM_TRIG) {

	cmp	edi, 200				; 000000c8H
	jle	SHORT $L27428

; 1128 :         sync = 1;

	mov	eax, 1
	pop	edi
	mov	DWORD PTR _?sync@?1??ProcessPulseFutabaPpm@@9@9, eax

; 1129 :         datacount = 0;
; 1130 : 		former_sync = 1;

	mov	DWORD PTR _?former_sync@?1??ProcessPulseFutabaPpm@@9@9, eax
	fstp	ST(0)
	mov	DWORD PTR _?datacount@?1??ProcessPulseFutabaPpm@@9@9, 0
	xor	eax, eax
	pop	esi

; 1182 : 	return 0;
; 1183 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27428:

; 1131 : 		return 0;
; 1132 :     }
; 1133 : 
; 1134 :     if (!sync) return 0; /* still waiting for sync */

	mov	eax, DWORD PTR _?sync@?1??ProcessPulseFutabaPpm@@9@9
	test	eax, eax
	jne	SHORT $L27429
	pop	edi
	xor	eax, eax
	fstp	ST(0)
	pop	esi

; 1182 : 	return 0;
; 1183 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27429:

; 1135 : 
; 1136 : 
; 1137 : 	/* convert pulse width in samples to joystick position values (newdata)
; 1138 : 	joystick position of 0 correspond to width over 100 samples (2.25mSec)
; 1139 : 	joystick position of 1023 correspond to width under 30 samples (0.68mSec)*/
; 1140 : 	if (input|| JsChPostProc_selected!=-1)
; 1141 : 		newdata = (int)(1024 - (width - PPM_MIN) / (PPM_MAX - PPM_MIN) * 1024); /* JR */

	fsub	QWORD PTR __real@8@4003f000000000000000
	fmul	QWORD PTR __real@8@4003a3d70a3d70a3d800
	fsubr	QWORD PTR __real@8@40098000000000000000
	call	__ftol

; 1142 : 	else
; 1143 : 		newdata = (int)((width - PPM_MIN) / (PPM_MAX - PPM_MIN) * 1024);		/* Futaba */
; 1144 : 
; 1145 : 	/* Trim values into 0-1023 boundries */
; 1146 :     if (newdata < 0) newdata = 0;

	test	eax, eax
	jge	SHORT $L27435
	xor	eax, eax

; 1147 :     else if (newdata > 1023) newdata = 1023;

	jmp	SHORT $L27437
$L27435:
	cmp	eax, 1023				; 000003ffH
	jle	SHORT $L27437
	mov	eax, 1023				; 000003ffH
$L27437:

; 1148 : 
; 1149 : 	/* Update data - do not allow abrupt change */
; 1150 :     if (data[datacount] - newdata > 100) data[datacount] -= 100;

	mov	esi, DWORD PTR _?datacount@?1??ProcessPulseFutabaPpm@@9@9
	mov	ecx, DWORD PTR _?data@?1??ProcessPulseFutabaPpm@@9@9[esi*4]
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jle	SHORT $L27438
	add	ecx, -100				; ffffff9cH
	mov	DWORD PTR _?data@?1??ProcessPulseFutabaPpm@@9@9[esi*4], ecx

; 1151 :     else if (newdata - data[datacount] > 100) data[datacount] += 100;

	jmp	SHORT $L27441
$L27438:
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L27440
	add	ecx, 100				; 00000064H
	mov	DWORD PTR _?data@?1??ProcessPulseFutabaPpm@@9@9[esi*4], ecx

; 1152 :     else data[datacount] = (data[datacount] + newdata) / 2;

	jmp	SHORT $L27441
$L27440:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _?data@?1??ProcessPulseFutabaPpm@@9@9[esi*4], eax
$L27441:

; 1153 : 
; 1154 : 	
; 1155 : 	if (input|| JsChPostProc_selected!=-1)
; 1156 : 		Position[datacount] = data[datacount];	/* JR - Assign data to joystick channels */
; 1157 : 	else
; 1158 : 		switch (datacount)
; 1159 : 	{ // Futaba
; 1160 : 	case 0: 	Position[1]  = data[datacount];	break;/* Assign data to joystick channels */
; 1161 : 	case 1: 	Position[2]  = data[datacount];	break;/* Assign data to joystick channels */
; 1162 : 	case 2: 	Position[0]  = data[datacount];	break;/* Assign data to joystick channels */
; 1163 : 	case 3: 	Position[3]  = data[datacount];	break;/* Assign data to joystick channels */
; 1164 : 	case 4: 	Position[4]  = data[datacount];	break;/* Assign data to joystick channels */
; 1165 : 	case 5: 	Position[5]  = data[datacount];	break;/* Assign data to joystick channels */
; 1166 : 	case 6: 	Position[6]  = data[datacount];	break;/* Assign data to joystick channels */
; 1167 : 	case 7: 	Position[7]  = data[datacount];	break;/* Assign data to joystick channels */
; 1168 : 	case 8: 	Position[8]  = data[datacount];	break;/* Assign data to joystick channels */
; 1169 : 	case 9: 	Position[9]  = data[datacount];	break;/* Assign data to joystick channels */
; 1170 : 	case 10: 	Position[10] = data[datacount];	break;/* Assign data to joystick channels */
; 1171 : 	case 11: 	Position[11] = data[datacount];	break;/* Assign data to joystick channels */
; 1172 : 	};
; 1173 : 
; 1174 : #ifdef PPJOY
; 1175 : 				SendPPJoy(datacount, Position);
; 1176 : #endif
; 1177 : 	if (gDebugLevel>=3 && gCtrlLogFile /*&& !(i++%50)*/)

	mov	ecx, DWORD PTR _gDebugLevel
	mov	eax, DWORD PTR _?data@?1??ProcessPulseFutabaPpm@@9@9[esi*4]
	cmp	ecx, 3
	mov	DWORD PTR _Position[esi*4], eax
	jl	SHORT $L27461
	mov	ecx, DWORD PTR _gCtrlLogFile
	test	ecx, ecx
	je	SHORT $L27461

; 1178 : 		fprintf(gCtrlLogFile," data[%d]=%d", datacount, data[datacount]);

	push	eax
	push	esi
	push	OFFSET FLAT:??_C@_0N@NFKC@?5data?$FL?$CFd?$FN?$DN?$CFd?$AA@ ; `string'
	push	ecx
	call	_fprintf
	mov	esi, DWORD PTR _?datacount@?1??ProcessPulseFutabaPpm@@9@9
	add	esp, 16					; 00000010H
$L27461:

; 1179 : 	if (datacount == 11)	sync = 0;			/* Reset sync after channel 12 */

	cmp	esi, 11					; 0000000bH
	jne	SHORT $L27462
	mov	DWORD PTR _?sync@?1??ProcessPulseFutabaPpm@@9@9, 0
$L27462:

; 1180 : 
; 1181 :     datacount++;

	inc	esi
	pop	edi
	mov	DWORD PTR _?datacount@?1??ProcessPulseFutabaPpm@@9@9, esi
	xor	eax, eax
	pop	esi

; 1182 : 	return 0;
; 1183 : }

	add	esp, 12					; 0000000cH
	ret	0
$L29541:

; 1118 : 
; 1119 : 	/* If pulse is a separator then go to the next one */
; 1120 : 	if (!input || width < PPM_SEP+7 || former_sync)

	fstp	ST(0)
$L27427:

; 1121 : 	{
; 1122 : 		former_sync = 0;

	mov	DWORD PTR _?former_sync@?1??ProcessPulseFutabaPpm@@9@9, 0
$L29543:
	pop	edi

; 1123 : 		return 0;

	xor	eax, eax
	pop	esi

; 1182 : 	return 0;
; 1183 : }

	add	esp, 12					; 0000000cH
	ret	0
_ProcessPulseFutabaPpm ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@JGMD@?6?$CFs?5?9?5ProcessPulseJrPpm?$CIwidth?$DN?$CFd@ ; `string'
_BSS	SEGMENT
_?data@?1??ProcessPulseJrPpm@@9@9 DD 0eH DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CM@JGMD@?6?$CFs?5?9?5ProcessPulseJrPpm?$CIwidth?$DN?$CFd@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0CM@JGMD@?6?$CFs?5?9?5ProcessPulseJrPpm?$CIwidth?$DN?$CFd@ DB 0aH, '%'
	DB	's - ProcessPulseJrPpm(width=%d, input=%d)', 00H ; `string'
_DATA	ENDS
;	COMDAT _ProcessPulseJrPpm
_TEXT	SEGMENT
_width$ = 8
_input$ = 12
_tbuffer$ = -12
_ProcessPulseJrPpm PROC NEAR				; COMDAT

; 1186 : {

	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 1187 :     static int sync = 0;
; 1188 : 
; 1189 :     int newdata;				/* Current width in joystick values */
; 1190 :     static int data[14];		/* Array of pulse widthes in joystick values */
; 1191 :     static int datacount = 0;	/* pulse index (corresponds to channel index) */
; 1192 : 	static int former_sync = 0;
; 1193 : 	char tbuffer [9];
; 1194 : 	static int i = 0;
; 1195 : 
; 1196 : 
; 1197 : 	if (width < 5)

	mov	edi, DWORD PTR _width$[esp+16]
	cmp	edi, 5

; 1198 : 		return 0;

	jl	$L29552

; 1199 : 
; 1200 : 	if (gDebugLevel>=2 /*&& gCtrlLogFile && !(i++%50)*/)

	mov	eax, DWORD PTR _gDebugLevel
	mov	esi, DWORD PTR _input$[esp+16]
	cmp	eax, 2
	jl	SHORT $L27482

; 1201 : 		fprintf(gCtrlLogFile,"\n%s - ProcessPulseJrPpm(width=%d, input=%d)", _strtime( tbuffer ), width, input);

	push	esi
	lea	eax, DWORD PTR _tbuffer$[esp+24]
	push	edi
	push	eax
	call	__strtime
	mov	ecx, DWORD PTR _gCtrlLogFile
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CM@JGMD@?6?$CFs?5?9?5ProcessPulseJrPpm?$CIwidth?$DN?$CFd@ ; `string'
	push	ecx
	call	_fprintf
	add	esp, 20					; 00000014H
$L27482:

; 1202 : 
; 1203 : 	/* If pulse is a separator then go to the next one */
; 1204 : 	if (input || width < PPM_SEP+7 || former_sync)

	test	esi, esi
	jne	$L27485
	fild	DWORD PTR _width$[esp+16]
	fcom	QWORD PTR __real@8@4003b000000000000000
	fnstsw	ax
	test	ah, 1
	jne	$L29550
	mov	eax, DWORD PTR _?former_sync@?1??ProcessPulseJrPpm@@9@9
	test	eax, eax
	jne	$L29550

; 1208 : 	};
; 1209 : 
; 1210 : 	/* sync is detected at the end of a very long pulse (over 200 samples = 4.5mSec) */
; 1211 :     if (!input && width > PPM_TRIG) {

	cmp	edi, 200				; 000000c8H
	jle	SHORT $L27486

; 1212 :         sync = 1;

	mov	eax, 1

; 1213 :         datacount = 0;

	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	mov	DWORD PTR _?sync@?1??ProcessPulseJrPpm@@9@9, eax

; 1214 : 		former_sync = 1;

	mov	DWORD PTR _?former_sync@?1??ProcessPulseJrPpm@@9@9, eax
	pop	edi
	xor	eax, eax
	fstp	ST(0)
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27486:

; 1215 : 		return 0;
; 1216 :     }
; 1217 : 
; 1218 :     if (!sync) return 0; /* still waiting for sync */

	mov	eax, DWORD PTR _?sync@?1??ProcessPulseJrPpm@@9@9
	test	eax, eax
	jne	SHORT $L29547
	pop	edi
	xor	eax, eax
	fstp	ST(0)
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L29547:

; 1226 : 	else
; 1227 : 		newdata = (int)((width - PPM_MIN) / (PPM_MAX - PPM_MIN) * 1024);		/* Futaba */

	fsub	QWORD PTR __real@8@4003f000000000000000
	mov	edi, DWORD PTR _JsChPostProc_selected
	cmp	edi, -1
	fmul	QWORD PTR __real@8@4003a3d70a3d70a3d800
	je	SHORT $L29553

; 1219 : 
; 1220 : 
; 1221 : 	/* convert pulse width in samples to joystick position values (newdata)
; 1222 : 	joystick position of 0 correspond to width over 100 samples (2.25mSec)
; 1223 : 	joystick position of 1023 correspond to width under 30 samples (0.68mSec)*/
; 1224 : 	if (input || JsChPostProc_selected!=-1)
; 1225 : 		newdata = (int)(1024 - (width - PPM_MIN) / (PPM_MAX - PPM_MIN) * 1024); /* JR */

	fsubr	QWORD PTR __real@8@40098000000000000000
$L29553:
	call	__ftol

; 1228 : 
; 1229 : 	/* Trim values into 0-1023 boundries */
; 1230 :     if (newdata < 0) newdata = 0;

	test	eax, eax
	jge	SHORT $L27493
	xor	eax, eax

; 1231 :     else if (newdata > 1023) newdata = 1023;

	jmp	SHORT $L27495
$L27493:
	cmp	eax, 1023				; 000003ffH
	jle	SHORT $L27495
	mov	eax, 1023				; 000003ffH
$L27495:

; 1232 : 
; 1233 : 	/* Update data - do not allow abrupt change */
; 1234 :     if (data[datacount] - newdata > 100) data[datacount] -= 100;

	mov	esi, DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9
	mov	ecx, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]
	mov	edx, ecx
	sub	edx, eax
	cmp	edx, 100				; 00000064H
	jle	SHORT $L27496
	add	ecx, -100				; ffffff9cH
	mov	DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4], ecx

; 1235 :     else if (newdata - data[datacount] > 100) data[datacount] += 100;

	jmp	SHORT $L29548
$L27496:
	mov	edx, eax
	sub	edx, ecx
	cmp	edx, 100				; 00000064H
	jle	SHORT $L27498
	add	ecx, 100				; 00000064H
	mov	DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4], ecx

; 1236 :     else data[datacount] = (data[datacount] + newdata) / 2;

	jmp	SHORT $L29548
$L27498:
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4], eax
$L29548:

; 1237 : 
; 1238 : 	
; 1239 : 	if (input|| JsChPostProc_selected!=-1)

	cmp	edi, -1
	jne	$L27501

; 1241 : 	else
; 1242 : 		switch (datacount)
; 1243 : 	{ // Futaba

	cmp	esi, 11					; 0000000bH
	ja	$L27519
	jmp	DWORD PTR $L29555[esi*4]
$L27507:

; 1244 : 	case 0: 	Position[1]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	eax, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]

; 1262 : 
; 1263 :     datacount++;

	inc	esi
	mov	DWORD PTR _Position+4, eax
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	pop	edi
	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27508:

; 1245 : 	case 1: 	Position[2]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]

; 1262 : 
; 1263 :     datacount++;

	inc	esi
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	pop	edi
	mov	DWORD PTR _Position+8, ecx
	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27509:

; 1246 : 	case 2: 	Position[0]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	edx, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]

; 1262 : 
; 1263 :     datacount++;

	inc	esi
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	pop	edi
	mov	DWORD PTR _Position, edx
	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27510:

; 1247 : 	case 3: 	Position[3]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	eax, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]

; 1262 : 
; 1263 :     datacount++;

	inc	esi
	mov	DWORD PTR _Position+12, eax
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	pop	edi
	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27511:

; 1248 : 	case 4: 	Position[4]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]

; 1262 : 
; 1263 :     datacount++;

	inc	esi
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	pop	edi
	mov	DWORD PTR _Position+16, ecx
	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27512:

; 1249 : 	case 5: 	Position[5]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	edx, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]

; 1262 : 
; 1263 :     datacount++;

	inc	esi
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	pop	edi
	mov	DWORD PTR _Position+20, edx
	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27513:

; 1250 : 	case 6: 	Position[6]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	eax, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]

; 1262 : 
; 1263 :     datacount++;

	inc	esi
	mov	DWORD PTR _Position+24, eax
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	pop	edi
	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27514:

; 1251 : 	case 7: 	Position[7]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]

; 1262 : 
; 1263 :     datacount++;

	inc	esi
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	pop	edi
	mov	DWORD PTR _Position+28, ecx
	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27515:

; 1252 : 	case 8: 	Position[8]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	edx, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]

; 1262 : 
; 1263 :     datacount++;

	inc	esi
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	pop	edi
	mov	DWORD PTR _Position+32, edx
	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27516:

; 1253 : 	case 9: 	Position[9]  = data[datacount];	break;/* Assign data to joystick channels */

	mov	eax, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]

; 1262 : 
; 1263 :     datacount++;

	inc	esi
	mov	DWORD PTR _Position+36, eax
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	pop	edi
	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27517:

; 1254 : 	case 10: 	Position[10] = data[datacount];	break;/* Assign data to joystick channels */

	mov	ecx, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]

; 1262 : 
; 1263 :     datacount++;

	inc	esi
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	pop	edi
	mov	DWORD PTR _Position+40, ecx
	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L27518:

; 1255 : 	case 11: 	Position[11] = data[datacount];	break;/* Assign data to joystick channels */

	mov	edx, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]
	mov	DWORD PTR _Position+44, edx
	jmp	SHORT $L29549
$L27501:

; 1240 : 		Position[datacount] = data[datacount];	/* JR - Assign data to joystick channels */

	mov	eax, DWORD PTR _?data@?1??ProcessPulseJrPpm@@9@9[esi*4]
	mov	DWORD PTR _Position[esi*4], eax
$L27504:

; 1256 : 	};
; 1257 : #ifdef PPJOY
; 1258 : 				SendPPJoy(datacount, Position);
; 1259 : #endif
; 1260 : 
; 1261 : 	if (datacount == 11)	sync = 0;			/* Reset sync after channel 12 */

	cmp	esi, 11					; 0000000bH
	jne	SHORT $L27519
$L29549:
	mov	DWORD PTR _?sync@?1??ProcessPulseJrPpm@@9@9, 0
$L27519:

; 1262 : 
; 1263 :     datacount++;

	inc	esi
	pop	edi
	mov	DWORD PTR _?datacount@?1??ProcessPulseJrPpm@@9@9, esi
	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
$L29550:

; 1202 : 
; 1203 : 	/* If pulse is a separator then go to the next one */
; 1204 : 	if (input || width < PPM_SEP+7 || former_sync)

	fstp	ST(0)
$L27485:

; 1205 : 	{
; 1206 : 		former_sync = 0;

	mov	DWORD PTR _?former_sync@?1??ProcessPulseJrPpm@@9@9, 0
$L29552:
	pop	edi

; 1207 : 		return 0;

	xor	eax, eax
	pop	esi

; 1264 : 	return 0;
; 1265 : }

	add	esp, 12					; 0000000cH
	ret	0
	npad	1
$L29555:
	DD	$L27507
	DD	$L27508
	DD	$L27509
	DD	$L27510
	DD	$L27511
	DD	$L27512
	DD	$L27513
	DD	$L27514
	DD	$L27515
	DD	$L27516
	DD	$L27517
	DD	$L27518
_ProcessPulseJrPpm ENDP
_TEXT	ENDS
PUBLIC	_GetJsChPostProcInfo
PUBLIC	_StartSppConsole
PUBLIC	??_C@_0BF@FCGA@WINMM?5Dll?5is?5running?$AA@	; `string'
PUBLIC	??_C@_0BC@MMLM@SppConsole?4exe?5?9i?$AA@	; `string'
PUBLIC	??_C@_0CA@PNCM@Inter?5SPP?5Application?5Message?52?$AA@ ; `string'
EXTRN	__imp__CreateProcessA@40:NEAR
EXTRN	__imp__RegisterWindowMessageA@4:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	__imp__CreateMutexA@12:NEAR
EXTRN	__imp__OpenMutexA@12:NEAR
EXTRN	__imp__PostMessageA@16:NEAR
_BSS	SEGMENT
_?WM_INTERSPPAPPS@?1??StartSppConsole@@9@9 DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BF@FCGA@WINMM?5Dll?5is?5running?$AA@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0BF@FCGA@WINMM?5Dll?5is?5running?$AA@ DB 'WINMM Dll is running', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@MMLM@SppConsole?4exe?5?9i?$AA@
_DATA	SEGMENT
??_C@_0BC@MMLM@SppConsole?4exe?5?9i?$AA@ DB 'SppConsole.exe -i', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@PNCM@Inter?5SPP?5Application?5Message?52?$AA@
_DATA	SEGMENT
??_C@_0CA@PNCM@Inter?5SPP?5Application?5Message?52?$AA@ DB 'Inter SPP App'
	DB	'lication Message 2', 00H			; `string'
_DATA	ENDS
;	COMDAT _StartSppConsole
_TEXT	SEGMENT
_StartupInfo$ = -68
_ProcessInformation$ = -84
_StartSppConsole PROC NEAR				; COMDAT

; 1381 : {

	sub	esp, 84					; 00000054H

; 1382 : 	STARTUPINFO StartupInfo;
; 1383 : 	PROCESS_INFORMATION ProcessInformation;
; 1384 : 	int errorcode, res;
; 1385 : 	static UINT NEAR WM_INTERSPPAPPS;	
; 1386 : 	
; 1387 : 	/* Mark this DLL as running */
; 1388 : 	if (!OpenMutex(MUTEX_ALL_ACCESS, TRUE, MUTXWINMM))

	push	OFFSET FLAT:??_C@_0BF@FCGA@WINMM?5Dll?5is?5running?$AA@ ; `string'
	push	1
	push	2031617					; 001f0001H
	call	DWORD PTR __imp__OpenMutexA@12
	test	eax, eax
	jne	SHORT $L27596

; 1389 : 		CreateMutex(NULL, FALSE, MUTXWINMM);

	push	OFFSET FLAT:??_C@_0BF@FCGA@WINMM?5Dll?5is?5running?$AA@ ; `string'
	push	eax
	push	eax
	call	DWORD PTR __imp__CreateMutexA@12
$L27596:
	push	edi

; 1390 : 	
; 1391 : 	/* Start the executable */
; 1392 : 	ZeroMemory(&StartupInfo, sizeof(STARTUPINFO));

	mov	ecx, 17					; 00000011H
	xor	eax, eax
	lea	edi, DWORD PTR _StartupInfo$[esp+88]
	rep stosd

; 1393 : 	StartupInfo.cb = sizeof(STARTUPINFO);
; 1394 : 	if (!CreateProcess(NULL,"SppConsole.exe -i", NULL, NULL, TRUE, 0, NULL, NULL, &StartupInfo, &ProcessInformation))

	lea	eax, DWORD PTR _ProcessInformation$[esp+88]
	lea	ecx, DWORD PTR _StartupInfo$[esp+88]
	push	eax
	push	ecx
	push	0
	push	0
	push	0
	push	1
	push	0
	push	0
	push	OFFSET FLAT:??_C@_0BC@MMLM@SppConsole?4exe?5?9i?$AA@ ; `string'
	push	0
	mov	DWORD PTR _StartupInfo$[esp+128], 68	; 00000044H
	call	DWORD PTR __imp__CreateProcessA@40
	test	eax, eax
	jne	SHORT $L27606

; 1395 : 	{
; 1396 : 		errorcode = GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 1397 : 		return 0;

	xor	eax, eax
	pop	edi

; 1419 : }

	add	esp, 84					; 00000054H
	ret	0
$L27606:

; 1398 : 	}
; 1399 : 	else
; 1400 : 	{
; 1401 : 		DWORD rc = WaitForSingleObject(ProcessInformation.hProcess, 1000); // 1 second time out

	mov	edx, DWORD PTR _ProcessInformation$[esp+88]
	push	esi
	push	1000					; 000003e8H
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 1402 : 		//out =  ProcessInformation.hProcess;
; 1403 : 		
; 1404 : 	};
; 1405 : 		
; 1406 : 	/* Send starting message to the GUI */
; 1407 : 	WM_INTERSPPAPPS = RegisterWindowMessage(INTERSPPAPPS);

	mov	esi, DWORD PTR __imp__RegisterWindowMessageA@4
	push	OFFSET FLAT:??_C@_0CA@PNCM@Inter?5SPP?5Application?5Message?52?$AA@ ; `string'
	call	esi

; 1408 : 	PostMessage(HWND_BROADCAST, WM_INTERSPPAPPS, MSG_DLLSTARTING, 0);

	mov	edi, DWORD PTR __imp__PostMessageA@16
	push	0
	push	1281					; 00000501H
	push	eax
	push	65535					; 0000ffffH
	mov	DWORD PTR _?WM_INTERSPPAPPS@?1??StartSppConsole@@9@9, eax
	call	edi

; 1409 : 
; 1410 : 	/* If a filter file is loaded - send filter info to the GUI */
; 1411 : 	WM_INTERSPPAPPS = RegisterWindowMessage(INTERSPPAPPS);

	push	OFFSET FLAT:??_C@_0CA@PNCM@Inter?5SPP?5Application?5Message?52?$AA@ ; `string'
	call	esi
	mov	DWORD PTR _?WM_INTERSPPAPPS@?1??StartSppConsole@@9@9, eax

; 1412 : 	if (hJschpostproc)

	mov	eax, DWORD PTR _hJschpostproc
	test	eax, eax
	pop	esi
	je	SHORT $L27612

; 1413 : 	{
; 1414 : 		res = GetJsChPostProcInfo(hJschpostproc);

	push	eax
	call	_GetJsChPostProcInfo
	add	esp, 4

; 1415 : 		PostMessage(HWND_BROADCAST, WM_INTERSPPAPPS, MSG_JSCHPPEVAIL, (long)res);

	push	eax
	mov	eax, DWORD PTR _?WM_INTERSPPAPPS@?1??StartSppConsole@@9@9
	push	1283					; 00000503H
	push	eax
	push	65535					; 0000ffffH
	call	edi
$L27612:

; 1416 : 	};
; 1417 : 
; 1418 : 	return 1;

	mov	eax, 1
	pop	edi

; 1419 : }

	add	esp, 84					; 00000054H
	ret	0
_StartSppConsole ENDP
_TEXT	ENDS
PUBLIC	_StartPropo
EXTRN	__imp__HeapAlloc@12:NEAR
EXTRN	__imp__GetProcessHeap@0:NEAR
EXTRN	_GetModulation:NEAR
EXTRN	_CreateDataBlock:NEAR
_BSS	SEGMENT
_waveIn	DD	01H DUP (?)
_waveFmt DB	014H DUP (?)
_waveBuf DD	02H DUP (?)
_waveRecording DD 01H DUP (?)
_DataBlock DD	01H DUP (?)
_BSS	ENDS
;	COMDAT _StartPropo
_TEXT	SEGMENT
_StartPropo PROC NEAR					; COMDAT

; 1548 :     int i;
; 1549 : 	struct Modulations *  Modulation;
; 1550 : 	int nActiveModulations;
; 1551 : 	char ChnlLogFileName[2000] = {""};
; 1552 : 
; 1553 : 	if (!DoStartPropo)

	mov	eax, DWORD PTR _DoStartPropo
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	$L27668
	push	ebx
	push	ebp
	push	esi

; 1554 : 		return;
; 1555 : 
; 1556 : 	/* Download configuration from the registry (if exists) */
; 1557 : 	Modulation= GetModulation(0);

	push	edi
	call	_GetModulation
	mov	esi, eax

; 1558 : 
; 1559 : 
; 1560 : 	/* Create the Global memory area (a.k.a. Shared Data) and upload configuration to it */
; 1561 : 	DataBlock =  CreateDataBlock(Modulation);

	push	esi
	call	_CreateDataBlock

; 1562 : 
; 1563 : 	/* SetActiveProcessPulseFunction(DataBlock); */
; 1564 : 	nActiveModulations = LoadProcessPulseFunctions(DataBlock);

	push	eax
	mov	DWORD PTR _DataBlock, eax
	call	_LoadProcessPulseFunctions

; 1565 : 
; 1566 : 	/* Get Debug level from the registry (if exists) and start debugging */
; 1567 : 	gDebugLevel = _GetDebugLevel();

	call	__GetDebugLevel

; 1568 : 	_DebugWelcomePopUp(Modulation);

	push	esi
	mov	DWORD PTR _gDebugLevel, eax
	call	__DebugWelcomePopUp

; 1569 : 
; 1570 : 
; 1571 :     waveRecording = TRUE; /* Start recording */

	mov	eax, 1
	add	esp, 16					; 00000010H
	mov	DWORD PTR _waveRecording, eax

; 1572 : 
; 1573 : 	/* Wave format structure initialization */ 
; 1574 :     waveFmt.wFormatTag = WAVE_FORMAT_PCM;
; 1575 :     waveFmt.nChannels = 1;
; 1576 :     waveFmt.nSamplesPerSec = 44100;
; 1577 :     waveFmt.wBitsPerSample =16;
; 1578 :     waveFmt.nBlockAlign = waveFmt.wBitsPerSample / 8 * waveFmt.nChannels;
; 1579 :     waveFmt.nAvgBytesPerSec = waveFmt.nSamplesPerSec * waveFmt.nBlockAlign;
; 1580 :     waveFmt.cbSize = 0;
; 1581 : 
; 1582 : 	/* Open audio stream, assigning 'waveInProc()' as the WAVE IN callback function*/
; 1583 :     pwaveInOpen(&waveIn, WAVE_MAPPER, &waveFmt, (DWORD)(waveInProc), 0, CALLBACK_FUNCTION);

	push	196608					; 00030000H
	push	edi
	push	OFFSET FLAT:_waveInProc@20
	push	OFFSET FLAT:_waveFmt
	push	-1
	push	OFFSET FLAT:_waveIn
	mov	WORD PTR _waveFmt, ax
	mov	WORD PTR _waveFmt+2, ax
	mov	DWORD PTR _waveFmt+4, 44100		; 0000ac44H
	mov	WORD PTR _waveFmt+14, 16		; 00000010H
	mov	WORD PTR _waveFmt+12, 2
	mov	DWORD PTR _waveFmt+8, 88200		; 00015888H
	mov	WORD PTR _waveFmt+16, di
	call	DWORD PTR _pwaveInOpen
	mov	ebx, DWORD PTR __imp__HeapAlloc@12
	mov	ebp, DWORD PTR __imp__GetProcessHeap@0
	mov	esi, OFFSET FLAT:_waveBuf
$L27676:

; 1584 : 
; 1585 : 	/* Initialize the two WAVE IN buffers*/
; 1586 :     for (i = 0; i < 2; i++) {
; 1587 :         waveBuf[i] = (WAVEHDR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(WAVEHDR));

	push	32					; 00000020H
	push	8
	call	ebp
	push	eax
	call	ebx
	mov	DWORD PTR [esi], eax

; 1588 :         waveBuf[i]->lpData = (char*)HeapAlloc(GetProcessHeap(), 0, waveBufSize);

	mov	eax, DWORD PTR _waveBufSize
	push	eax
	push	0
	call	ebp
	push	eax
	call	ebx
	mov	ecx, DWORD PTR [esi]

; 1589 :         waveBuf[i]->dwBufferLength = waveBufSize;
; 1590 :         waveBuf[i]->dwUser = i;
; 1591 :         pwaveInPrepareHeader(waveIn, waveBuf[i], sizeof(WAVEHDR));

	push	32					; 00000020H
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _waveBufSize
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+12], edi
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _waveIn
	push	edx
	push	eax
	call	DWORD PTR _pwaveInPrepareHeader

; 1592 :         pwaveInAddBuffer(waveIn, waveBuf[i], sizeof(WAVEHDR));

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _waveIn
	push	32					; 00000020H
	push	ecx
	push	edx
	call	DWORD PTR _pwaveInAddBuffer
	add	esi, 4
	inc	edi
	cmp	esi, OFFSET FLAT:_waveBuf+8
	jl	SHORT $L27676

; 1593 :     }
; 1594 : 
; 1595 : 	/* Begin listening to WAVE IN */
; 1596 :     pwaveInStart(waveIn);

	mov	eax, DWORD PTR _waveIn
	push	eax
	call	DWORD PTR _pwaveInStart
	pop	esi
	pop	ebp
	pop	ebx
$L27668:
	pop	edi

; 1597 : 	
; 1598 : #if 0//def _DEBUG // Collect channel data - open output file
; 1599 : 	sprintf(ChnlLogFileName,"%s\\%s", getenv("TEMP"), CHNL_LOG_FILE);
; 1600 : 	gChnlLogFile = fopen(ChnlLogFileName, "w");
; 1601 : 	fprintf(gChnlLogFile, "\nCH1\t;CH2\t;CH3\t;CH4\t;CH5\t;CH6\t;CH7\t;CH8\t;CH9\t;CH10\t;CH11\t;CH12");
; 1602 : 	
; 1603 : #endif
; 1604 : 	
; 1605 : }

	ret	0
_StartPropo ENDP
_TEXT	ENDS
;	COMDAT _waveInProc@20
_TEXT	SEGMENT
_uMsg$ = 12
_buf$ = 20
_waveInProc@20 PROC NEAR				; COMDAT

; 1483 :     int i;
; 1484 :     if (uMsg == WIM_DATA) /* Sent when the device driver is finished with a data block */

	mov	eax, DWORD PTR _uMsg$[esp-4]
	push	ebx
	cmp	eax, 960				; 000003c0H
	jne	SHORT $L27665

; 1485 : 	{
; 1486 :         int Size = waveFmt.nBlockAlign;
; 1487 :         int Length = buf->dwBytesRecorded / Size;

	mov	ebx, DWORD PTR _buf$[esp]
	mov	ecx, DWORD PTR _waveFmt+12
	and	ecx, 65535				; 0000ffffH
	xor	edx, edx
	mov	eax, DWORD PTR [ebx+8]
	push	esi
	div	ecx

; 1488 :         if (Size == 1) /* 8-bit per sample. Value range: 0-255 */

	cmp	ecx, 1
	push	edi
	mov	esi, eax
	jne	SHORT $L27654

; 1489 : 		{
; 1490 :             for (i = 0; i < Length; i++) 

	xor	edi, edi
	test	esi, esi
	jle	SHORT $L27663
$L27655:

; 1491 : 			{
; 1492 :                 ProcessData((unsigned char)buf->lpData[i]);

	mov	eax, DWORD PTR [ebx]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+edi]
	call	@ProcessData@4
	inc	edi
	cmp	edi, esi
	jl	SHORT $L27655

; 1493 :             }
; 1494 :         } 
; 1495 : 		else if (Size == 2)  /* 16-bit per sample. Value range: -32k - +32k */

	jmp	SHORT $L27663
$L27654:
	cmp	ecx, 2
	jne	SHORT $L27663

; 1496 : 		{
; 1497 :             for (i = 0; i < Length; i++) 

	xor	edi, edi
	test	esi, esi
	jle	SHORT $L27663
$L27661:

; 1498 : 			{
; 1499 :                 ProcessData(((signed short*)(buf->lpData))[i]);

	mov	ecx, DWORD PTR [ebx]
	movsx	ecx, WORD PTR [ecx+edi*2]
	call	@ProcessData@4
	inc	edi
	cmp	edi, esi
	jl	SHORT $L27661
$L27663:

; 1500 :             }
; 1501 :         }
; 1502 : 
; 1503 : 		/* Requests the audio device to refill the current buffer */
; 1504 :         if (waveRecording) 

	mov	eax, DWORD PTR _waveRecording
	pop	edi
	test	eax, eax
	pop	esi
	je	SHORT $L27665

; 1505 : 			pwaveInAddBuffer(waveIn, waveBuf[buf->dwUser], sizeof(WAVEHDR));

	mov	edx, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR _waveIn
	push	32					; 00000020H
	mov	eax, DWORD PTR _waveBuf[edx*4]
	push	eax
	push	ecx
	call	DWORD PTR _pwaveInAddBuffer
$L27665:
	pop	ebx

; 1506 :     }
; 1507 : }

	ret	20					; 00000014H
_waveInProc@20 ENDP
_TEXT	ENDS
PUBLIC	?mod@?1??_DebugChangeModPopUp@@9@9		; `_DebugChangeModPopUp'::`2'::mod
PUBLIC	?detect@?1??_DebugChangeModPopUp@@9@9		; `_DebugChangeModPopUp'::`2'::detect
PUBLIC	?pos@?1??_DebugChangeModPopUp@@9@9		; `_DebugChangeModPopUp'::`2'::pos
PUBLIC	??_C@_0CL@MHKP@Former?5Modulation?3?7Mod?$DN?$CFd?$DL?5Auto?$DN@ ; `string'
PUBLIC	??_C@_0CL@FEH@?$CFs?6New?5Modulation?3?7Mod?$DN?$CFd?$DL?5Auto?$DN@ ; `string'
PUBLIC	??_C@_0EA@HNBK@?6?$CFs?5?9?5ProcessData?$CI?$CF7d?$CJ?5?$CIH?$CJ?$DL?5Min?1@ ; `string'
PUBLIC	??_C@_0EA@DOJA@?6?$CFs?5?9?5ProcessData?$CI?$CF7d?$CJ?5?$CIL?$CJ?$DL?5Min?1@ ; `string'
PUBLIC	??_C@_0DF@JMB@?7JoyStick?5channels?3?5Ch?$FL1?36?$FN?3?5?$CF4d@ ; `string'
PUBLIC	__real@8@3ffbccccccccccccd000
PUBLIC	__real@8@3fff8000000000000000
;	COMDAT ?mod@?1??_DebugChangeModPopUp@@9@9
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
?mod@?1??_DebugChangeModPopUp@@9@9 DD 0ffffffffH	; `_DebugChangeModPopUp'::`2'::mod
_DATA	ENDS
;	COMDAT ?detect@?1??_DebugChangeModPopUp@@9@9
_DATA	SEGMENT
?detect@?1??_DebugChangeModPopUp@@9@9 DD 0ffffffffH	; `_DebugChangeModPopUp'::`2'::detect
_DATA	ENDS
;	COMDAT ?pos@?1??_DebugChangeModPopUp@@9@9
_DATA	SEGMENT
?pos@?1??_DebugChangeModPopUp@@9@9 DD 0ffffffffH	; `_DebugChangeModPopUp'::`2'::pos
_DATA	ENDS
;	COMDAT ??_C@_0CL@MHKP@Former?5Modulation?3?7Mod?$DN?$CFd?$DL?5Auto?$DN@
_DATA	SEGMENT
??_C@_0CL@MHKP@Former?5Modulation?3?7Mod?$DN?$CFd?$DL?5Auto?$DN@ DB 'Form'
	DB	'er Modulation:', 09H, 'Mod=%d; Auto=%d; Pos=%d', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@FEH@?$CFs?6New?5Modulation?3?7Mod?$DN?$CFd?$DL?5Auto?$DN@
_DATA	SEGMENT
??_C@_0CL@FEH@?$CFs?6New?5Modulation?3?7Mod?$DN?$CFd?$DL?5Auto?$DN@ DB '%'
	DB	's', 0aH, 'New Modulation:', 09H, 'Mod=%d; Auto=%d; Pos=%d', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EA@HNBK@?6?$CFs?5?9?5ProcessData?$CI?$CF7d?$CJ?5?$CIH?$CJ?$DL?5Min?1@
_DATA	SEGMENT
??_C@_0EA@HNBK@?6?$CFs?5?9?5ProcessData?$CI?$CF7d?$CJ?5?$CIH?$CJ?$DL?5Min?1@ DB 0aH
	DB	'%s - ProcessData(%7d) (H); Min/Max/Thresh=%d/%d/%d P-Width=%3'
	DB	'd', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EA@DOJA@?6?$CFs?5?9?5ProcessData?$CI?$CF7d?$CJ?5?$CIL?$CJ?$DL?5Min?1@
_DATA	SEGMENT
??_C@_0EA@DOJA@?6?$CFs?5?9?5ProcessData?$CI?$CF7d?$CJ?5?$CIL?$CJ?$DL?5Min?1@ DB 0aH
	DB	'%s - ProcessData(%7d) (L); Min/Max/Thresh=%d/%d/%d P-Width=%3'
	DB	'd', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DF@JMB@?7JoyStick?5channels?3?5Ch?$FL1?36?$FN?3?5?$CF4d@
_DATA	SEGMENT
??_C@_0DF@JMB@?7JoyStick?5channels?3?5Ch?$FL1?36?$FN?3?5?$CF4d@ DB 09H, 'J'
	DB	'oyStick channels: Ch[1:6]: %4d %4d %4d %4d %4d %4d', 00H ; `string'
_DATA	ENDS
;	COMDAT __real@8@3ffbccccccccccccd000
CONST	SEGMENT
__real@8@3ffbccccccccccccd000 DQ 03fb999999999999ar ; 0.1
CONST	ENDS
;	COMDAT __real@8@3fff8000000000000000
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT @ProcessData@4
_TEXT	SEGMENT
_msg$29580 = -4000
_tbuffer$29595 = -4012
_tbuffer$29609 = -4012
_i$ = -4024
_threshold$ = -4020
@ProcessData@4 PROC NEAR				; COMDAT

; 1430 : {

	sub	esp, 4024				; 00000fb8H

; 1431 :     static double min = 0;	/* Sticky minimum sample value */
; 1432 :     static double max = 0;	/* Sticky maximum sample value */
; 1433 :     static int high = 0;	/* Number of contingious above-threshold samples */
; 1434 :     static int low = 0;		/* Number of contingious below-threshold samples */
; 1435 :     double threshold;		/* calculated mid-point */
; 1436 : 	static int FormerInput;
; 1437 : 
; 1438 : 	/* Initialization of the min/max vaues */
; 1439 :     max -= 0.1;

	fld	QWORD PTR _?max@?1??ProcessData@@9@9
	fsub	QWORD PTR __real@8@3ffbccccccccccccd000
	mov	DWORD PTR _i$[esp+4024], ecx
	fstp	QWORD PTR _?max@?1??ProcessData@@9@9

; 1440 :     min += 0.1;

	fld	QWORD PTR _?min@?1??ProcessData@@9@9
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fstp	QWORD PTR _?min@?1??ProcessData@@9@9

; 1441 :     if (max < min) max = min + 1;

	fld	QWORD PTR _?max@?1??ProcessData@@9@9
	fcomp	QWORD PTR _?min@?1??ProcessData@@9@9
	fnstsw	ax
	test	ah, 1
	je	SHORT $L27630
	fld	QWORD PTR _?min@?1??ProcessData@@9@9
	fadd	QWORD PTR __real@8@3fff8000000000000000
	fstp	QWORD PTR _?max@?1??ProcessData@@9@9
$L27630:

; 1442 : 
; 1443 :     if (i> max) max = i;			/* Update max value */

	fild	DWORD PTR _i$[esp+4024]
	fcom	QWORD PTR _?max@?1??ProcessData@@9@9
	fst	QWORD PTR -4012+[esp+4024]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L27631
	fst	QWORD PTR _?max@?1??ProcessData@@9@9

; 1444 :     else if (i < min) min = i;		/* Update min value */

	jmp	SHORT $L27633
$L27631:
	fcom	QWORD PTR _?min@?1??ProcessData@@9@9
	fnstsw	ax
	test	ah, 1
	je	SHORT $L27633
	fst	QWORD PTR _?min@?1??ProcessData@@9@9
$L27633:

; 1445 :     threshold = (min + max) / 2;	/* Update mid-point value */

	fld	QWORD PTR _?min@?1??ProcessData@@9@9
	fadd	QWORD PTR _?max@?1??ProcessData@@9@9

; 1446 : 
; 1447 : 
; 1448 : 	SetActiveProcessPulseFunction(DataBlock);

	mov	eax, DWORD PTR _DataBlock
	push	ebx
	push	ebp
	push	esi
	mov	ecx, DWORD PTR [eax+144]
	lea	ebx, DWORD PTR [eax+144]
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	test	ecx, ecx
	push	edi
	mov	ebp, eax
	fstp	QWORD PTR _threshold$[esp+4040]
	je	SHORT $L29587
	xor	ecx, ecx
	jmp	SHORT $L29589
$L29587:
	mov	esi, DWORD PTR [eax+140]
	xor	ecx, ecx
	test	esi, esi
	setne	cl
	inc	ecx
$L29589:
	mov	edx, DWORD PTR [eax+148]
	mov	edi, DWORD PTR [eax+136]
	imul	edx, ecx
	mov	ecx, DWORD PTR _ListProcessPulseFunc
	lea	esi, DWORD PTR [eax+136]
	add	edx, edi
	mov	ecx, DWORD PTR [ecx+edx*4]
	test	ecx, ecx
	mov	DWORD PTR _ProcessPulse, ecx
	jne	SHORT $L29591
	mov	DWORD PTR _ProcessPulse, OFFSET FLAT:_ProcessPulsePpm
$L29591:
	mov	ecx, DWORD PTR _gDebugLevel
	test	ecx, ecx
	je	$L29582
	test	eax, eax
	je	$L29582
	mov	ecx, DWORD PTR ?mod@?1??_DebugChangeModPopUp@@9@9 ; `_DebugChangeModPopUp'::`2'::mod
	mov	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR ?pos@?1??_DebugChangeModPopUp@@9@9 ; `_DebugChangeModPopUp'::`2'::pos
	cmp	ecx, edx
	mov	edx, DWORD PTR ?detect@?1??_DebugChangeModPopUp@@9@9 ; `_DebugChangeModPopUp'::`2'::detect
	jne	SHORT $L29625
	cmp	edx, DWORD PTR [ebx]
	jne	SHORT $L29625
	cmp	edi, DWORD PTR [eax+140]
	je	SHORT $L29582
$L29625:
	push	edi
	push	edx
	push	ecx
	lea	edx, DWORD PTR _msg$29580[esp+4052]
	push	OFFSET FLAT:??_C@_0CL@MHKP@Former?5Modulation?3?7Mod?$DN?$CFd?$DL?5Auto?$DN@ ; `string'
	push	edx
	fstp	ST(0)
	call	_sprintf
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR ?mod@?1??_DebugChangeModPopUp@@9@9, eax ; `_DebugChangeModPopUp'::`2'::mod
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR ?detect@?1??_DebugChangeModPopUp@@9@9, ecx ; `_DebugChangeModPopUp'::`2'::detect
	mov	edx, DWORD PTR [ebp+140]
	push	edx
	push	ecx
	push	eax
	lea	eax, DWORD PTR _msg$29580[esp+4072]
	push	eax
	lea	ecx, DWORD PTR _msg$29580[esp+4076]
	push	OFFSET FLAT:??_C@_0CL@FEH@?$CFs?6New?5Modulation?3?7Mod?$DN?$CFd?$DL?5Auto?$DN@ ; `string'
	push	ecx
	mov	DWORD PTR ?pos@?1??_DebugChangeModPopUp@@9@9, edx ; `_DebugChangeModPopUp'::`2'::pos
	call	_sprintf
	add	esp, 44					; 0000002cH
	lea	edx, DWORD PTR _msg$29580[esp+4040]
	push	4096					; 00001000H
	push	OFFSET FLAT:??_C@_0BN@KJAH@SmartPropoPlus?5Debug?5Message?$AA@ ; `string'
	push	edx
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	fld	QWORD PTR -4012+[esp+4040]
$L29582:

; 1449 : 
; 1450 : 	/* Update the width of the number of the low/high samples */
; 1451 : 	/* If edge, then call ProcessPulse() to process the previous high/low level */
; 1452 :     if (i > threshold) 

	fcomp	QWORD PTR _threshold$[esp+4040]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L27634

; 1453 : 	{
; 1454 : 	high++;

	mov	edx, DWORD PTR _?high@?1??ProcessData@@9@9

; 1455 :         if (low) 

	mov	eax, DWORD PTR _?low@?1??ProcessData@@9@9
	inc	edx
	test	eax, eax
	mov	DWORD PTR _?high@?1??ProcessData@@9@9, edx
	je	$L27637

; 1456 : 		{
; 1457 : 			_DebugProcessData(i,min, max, threshold, low,0);

	mov	ecx, DWORD PTR _gDebugLevel
	mov	esi, 3
	cmp	ecx, esi
	jl	SHORT $L29598
	mov	ecx, DWORD PTR _gDataLogFile
	test	ecx, ecx
	je	SHORT $L29598
	fld	QWORD PTR _threshold$[esp+4040]
	push	eax
	call	__ftol
	fld	QWORD PTR _?max@?1??ProcessData@@9@9
	push	eax
	call	__ftol
	fld	QWORD PTR _?min@?1??ProcessData@@9@9
	push	eax
	call	__ftol
	push	eax
	mov	eax, DWORD PTR _i$[esp+4056]
	lea	ecx, DWORD PTR _tbuffer$29595[esp+4056]
	push	eax
	push	ecx
	call	__strtime
	mov	edx, DWORD PTR _gDataLogFile
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0EA@DOJA@?6?$CFs?5?9?5ProcessData?$CI?$CF7d?$CJ?5?$CIL?$CJ?$DL?5Min?1@ ; `string'
	push	edx
	call	_fprintf
	mov	eax, DWORD PTR _?low@?1??ProcessData@@9@9
	add	esp, 32					; 00000020H
$L29598:

; 1458 :             ProcessPulse(low, FALSE);

	push	0
	push	eax
	call	DWORD PTR _ProcessPulse

; 1459 : 			 _DebugJoyStickData();

	mov	eax, DWORD PTR _gDebugLevel
	add	esp, 8
	cmp	eax, esi
	jl	SHORT $L29605
	mov	eax, DWORD PTR _gDataLogFile
	test	eax, eax
	je	SHORT $L29605
	mov	ecx, DWORD PTR _Position+20
	mov	edx, DWORD PTR _Position+16
	push	ecx
	mov	ecx, DWORD PTR _Position+12
	push	edx
	mov	edx, DWORD PTR _Position+8
	push	ecx
	mov	ecx, DWORD PTR _Position+4
	push	edx
	mov	edx, DWORD PTR _Position
	push	ecx
	push	edx
	push	OFFSET FLAT:??_C@_0DF@JMB@?7JoyStick?5channels?3?5Ch?$FL1?36?$FN?3?5?$CF4d@ ; `string'
	push	eax
	call	_fprintf
	add	esp, 32					; 00000020H
$L29605:
	pop	edi
	pop	esi
	pop	ebp

; 1460 :             low = 0;

	mov	DWORD PTR _?low@?1??ProcessData@@9@9, 0
	pop	ebx

; 1471 :         }
; 1472 :     }
; 1473 : }

	add	esp, 4024				; 00000fb8H
	ret	0
$L27634:

; 1461 :         }
; 1462 :     } else 
; 1463 : 	{
; 1464 :         low++;

	mov	edx, DWORD PTR _?low@?1??ProcessData@@9@9

; 1465 :         if (high) 

	mov	eax, DWORD PTR _?high@?1??ProcessData@@9@9
	inc	edx
	test	eax, eax
	mov	DWORD PTR _?low@?1??ProcessData@@9@9, edx
	je	$L27637

; 1466 : 		{
; 1467 : 			_DebugProcessData(i,min, max, threshold, high,1);

	mov	ecx, DWORD PTR _gDebugLevel
	mov	esi, 3
	cmp	ecx, esi
	jl	SHORT $L29612
	mov	ecx, DWORD PTR _gDataLogFile
	test	ecx, ecx
	je	SHORT $L29612
	fld	QWORD PTR _threshold$[esp+4040]
	push	eax
	call	__ftol
	fld	QWORD PTR _?max@?1??ProcessData@@9@9
	push	eax
	call	__ftol
	fld	QWORD PTR _?min@?1??ProcessData@@9@9
	push	eax
	call	__ftol
	push	eax
	mov	eax, DWORD PTR _i$[esp+4056]
	lea	ecx, DWORD PTR _tbuffer$29609[esp+4056]
	push	eax
	push	ecx
	call	__strtime
	mov	edx, DWORD PTR _gDataLogFile
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0EA@HNBK@?6?$CFs?5?9?5ProcessData?$CI?$CF7d?$CJ?5?$CIH?$CJ?$DL?5Min?1@ ; `string'
	push	edx
	call	_fprintf
	mov	eax, DWORD PTR _?high@?1??ProcessData@@9@9
	add	esp, 32					; 00000020H
$L29612:

; 1468 :             ProcessPulse(high, TRUE);

	push	1
	push	eax
	call	DWORD PTR _ProcessPulse

; 1469 : 			 _DebugJoyStickData();

	mov	eax, DWORD PTR _gDebugLevel
	add	esp, 8
	cmp	eax, esi
	jl	SHORT $L29619
	mov	eax, DWORD PTR _gDataLogFile
	test	eax, eax
	je	SHORT $L29619
	mov	ecx, DWORD PTR _Position+20
	mov	edx, DWORD PTR _Position+16
	push	ecx
	mov	ecx, DWORD PTR _Position+12
	push	edx
	mov	edx, DWORD PTR _Position+8
	push	ecx
	mov	ecx, DWORD PTR _Position+4
	push	edx
	mov	edx, DWORD PTR _Position
	push	ecx
	push	edx
	push	OFFSET FLAT:??_C@_0DF@JMB@?7JoyStick?5channels?3?5Ch?$FL1?36?$FN?3?5?$CF4d@ ; `string'
	push	eax
	call	_fprintf
	add	esp, 32					; 00000020H
$L29619:

; 1470 :             high = 0;

	mov	DWORD PTR _?high@?1??ProcessData@@9@9, 0
$L27637:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1471 :         }
; 1472 :     }
; 1473 : }

	add	esp, 4024				; 00000fb8H
	ret	0
@ProcessData@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@PJBN@?6?$CFs?5?9?5Closing?5WINMM?4DLL?6?6?$AA@ ; `string'
EXTRN	__imp__HeapFree@12:NEAR
EXTRN	_fclose:NEAR
EXTRN	__imp__ReleaseMutex@4:NEAR
_BSS	SEGMENT
_?WM_INTERSPPAPPS@?1??StopPropo@@9@9 DD 01H DUP (?)
_console_started DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BK@PJBN@?6?$CFs?5?9?5Closing?5WINMM?4DLL?6?6?$AA@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0BK@PJBN@?6?$CFs?5?9?5Closing?5WINMM?4DLL?6?6?$AA@ DB 0aH, '%s - Cl'
	DB	'osing WINMM.DLL', 0aH, 0aH, 00H		; `string'
_DATA	ENDS
;	COMDAT _StopPropo
_TEXT	SEGMENT
_tbuffer$ = -12
_StopPropo PROC NEAR					; COMDAT

; 1609 : {

	sub	esp, 12					; 0000000cH
	push	edi

; 1610 :     int i;
; 1611 : 	char tbuffer [9];
; 1612 : 	static UINT NEAR WM_INTERSPPAPPS;
; 1613 : 	HANDLE hProcessHeap;
; 1614 : 	
; 1615 :     waveRecording = FALSE;

	mov	DWORD PTR _waveRecording, 0

; 1616 : 	hProcessHeap = GetProcessHeap();

	call	DWORD PTR __imp__GetProcessHeap@0
	mov	edi, eax

; 1617 : 	
; 1618 : 	if (waveIn && hProcessHeap)

	mov	eax, DWORD PTR _waveIn
	test	eax, eax
	je	SHORT $L27691
	test	edi, edi
	je	SHORT $L27691
	push	ebx
	push	esi

; 1619 : 	{
; 1620 : 		pwaveInStop(waveIn);

	push	eax
	call	DWORD PTR _pwaveInStop
	mov	ebx, DWORD PTR __imp__HeapFree@12
	mov	esi, OFFSET FLAT:_waveBuf
$L27692:

; 1621 : 		for (i = 0; i < 2 ;i++) {
; 1622 : 			pwaveInUnprepareHeader(waveIn, waveBuf[i], sizeof(WAVEHDR));

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _waveIn
	push	32					; 00000020H
	push	eax
	push	ecx
	call	DWORD PTR _pwaveInUnprepareHeader

; 1623 : 			HeapFree(hProcessHeap, 0, waveBuf[i]->lpData);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	push	edi
	call	ebx

; 1624 : 			HeapFree(hProcessHeap, 0, waveBuf[i]);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	push	0
	push	edi
	call	ebx
	add	esi, 4
	cmp	esi, OFFSET FLAT:_waveBuf+8
	jl	SHORT $L27692

; 1625 : 		}
; 1626 : 		pwaveInClose(waveIn);

	mov	edx, DWORD PTR _waveIn
	push	edx
	call	DWORD PTR _pwaveInClose
	pop	esi
	pop	ebx
$L27691:

; 1627 : 	};
; 1628 : 	
; 1629 : 	if (gDebugLevel>=2 && gCtrlLogFile)

	mov	eax, DWORD PTR _gDebugLevel
	pop	edi
	cmp	eax, 2
	jl	SHORT $L27696
	mov	eax, DWORD PTR _gCtrlLogFile
	test	eax, eax
	je	SHORT $L27696

; 1630 : 	{
; 1631 : 		fprintf(gCtrlLogFile,"\n%s - Closing WINMM.DLL\n\n", _strtime( tbuffer ));

	lea	eax, DWORD PTR _tbuffer$[esp+12]
	push	eax
	call	__strtime
	mov	ecx, DWORD PTR _gCtrlLogFile
	push	eax
	push	OFFSET FLAT:??_C@_0BK@PJBN@?6?$CFs?5?9?5Closing?5WINMM?4DLL?6?6?$AA@ ; `string'
	push	ecx
	call	_fprintf

; 1632 : 		fclose(gCtrlLogFile);

	mov	edx, DWORD PTR _gCtrlLogFile
	push	edx
	call	_fclose
	add	esp, 20					; 00000014H
$L27696:

; 1633 : 	};
; 1634 : 
; 1635 : 	/* TODO - Release global memory by UnMapping File View */
; 1636 : 
; 1637 : 	/* Release Mutex */
; 1638 : 	ReleaseMutex(MUTXWINMM);

	push	OFFSET FLAT:??_C@_0BF@FCGA@WINMM?5Dll?5is?5running?$AA@ ; `string'
	call	DWORD PTR __imp__ReleaseMutex@4

; 1639 : 
; 1640 : 	/* Send closing message to the GUI */
; 1641 : 	WM_INTERSPPAPPS = RegisterWindowMessage(INTERSPPAPPS);

	push	OFFSET FLAT:??_C@_0CA@PNCM@Inter?5SPP?5Application?5Message?52?$AA@ ; `string'
	call	DWORD PTR __imp__RegisterWindowMessageA@4

; 1642 : 	if (console_started)

	mov	ecx, DWORD PTR _console_started
	mov	DWORD PTR _?WM_INTERSPPAPPS@?1??StopPropo@@9@9, eax
	test	ecx, ecx
	je	SHORT $L27698

; 1643 : 		PostMessage(HWND_BROADCAST, WM_INTERSPPAPPS, MSG_DLLSTOPPING, 0);

	push	0
	push	1280					; 00000500H
	push	eax
	push	65535					; 0000ffffH
	call	DWORD PTR __imp__PostMessageA@16
$L27698:

; 1644 : 
; 1645 : #ifdef _DEBUG // Collect channel data - close output file
; 1646 : 	if (gChnlLogFile)
; 1647 : 		fclose(gChnlLogFile);
; 1648 : #endif
; 1649 : 
; 1650 : }

	add	esp, 12					; 0000000cH
	ret	0
_StopPropo ENDP
_TEXT	ENDS
PUBLIC	_GetPosition
;	COMDAT _GetPosition
_TEXT	SEGMENT
_ch$ = 8
_GetPosition PROC NEAR					; COMDAT

; 1655 :     return Position[ch];

	mov	eax, DWORD PTR _ch$[esp-4]
	mov	eax, DWORD PTR _Position[eax*4]

; 1656 : }

	ret	0
_GetPosition ENDP
_TEXT	ENDS
PUBLIC	_joyGetDevCapsA@12
PUBLIC	??_C@_0P@JKLI@SmartPropoPlus?$AA@		; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??_C@_0P@JKLI@SmartPropoPlus?$AA@
_DATA	SEGMENT
??_C@_0P@JKLI@SmartPropoPlus?$AA@ DB 'SmartPropoPlus', 00H ; `string'
_DATA	ENDS
;	COMDAT _joyGetDevCapsA@12
_TEXT	SEGMENT
_uJoyID$ = 8
_pjc$ = 12
_joyGetDevCapsA@12 PROC NEAR				; COMDAT

; 1663 : 	/* 
; 1664 : 		If the GUI console has not been started yet by the simulator then start it
; 1665 : 		Assumption - FMS (and any other simulator) will use this function but the GUI will not
; 1666 : 		Not assumed - the GUI console is not active yet.
; 1667 : 	*/
; 1668 : 	if (!console_started)

	mov	eax, DWORD PTR _console_started
	push	ebx
	xor	ebx, ebx
	cmp	eax, ebx
	jne	SHORT $L27712

; 1669 : 		console_started = StartSppConsole();

	call	_StartSppConsole
	mov	DWORD PTR _console_started, eax
$L27712:

; 1670 : 
; 1671 : #ifdef PPJOY
; 1672 : 	/* If a filter file is loaded - send filter info to the GUI */
; 1673 : 	return pjoyGetDevCapsA( uJoyID,  pjc,  cbjc);
; 1674 : #else /* PPJOY */
; 1675 : 
; 1676 : 	if (uJoyID == 0) {

	mov	eax, DWORD PTR _uJoyID$[esp]
	cmp	eax, ebx

; 1677 :         pjc->wMid = 0;

	mov	eax, DWORD PTR _pjc$[esp]
	mov	WORD PTR [eax], bx

; 1678 :         pjc->wPid = 0;

	mov	WORD PTR [eax+2], bx
	jne	$L27713

; 1679 :         strcpy((char*)pjc->szPname, PRODUCT);

	mov	edx, DWORD PTR ??_C@_0P@JKLI@SmartPropoPlus?$AA@
	lea	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR ??_C@_0P@JKLI@SmartPropoPlus?$AA@+4
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR ??_C@_0P@JKLI@SmartPropoPlus?$AA@+8
	mov	DWORD PTR [ecx+8], edx
	mov	dx, WORD PTR ??_C@_0P@JKLI@SmartPropoPlus?$AA@+12
	mov	WORD PTR [ecx+12], dx
	mov	dl, BYTE PTR ??_C@_0P@JKLI@SmartPropoPlus?$AA@+14

; 1680 :         pjc->wXmin = pjc->wYmin = pjc->wZmin = pjc->wRmin = pjc->wUmin = pjc->wVmin = 0;

	mov	DWORD PTR [eax+88], ebx
	mov	DWORD PTR [eax+80], ebx
	mov	BYTE PTR [ecx+14], dl

; 1681 :         pjc->wXmax = pjc->wYmax = pjc->wZmax = pjc->wRmax = pjc->wUmax = pjc->wVmax = 1023; /* Bug fix by Bruce Page */

	mov	ecx, 1023				; 000003ffH
	mov	DWORD PTR [eax+92], ecx
	mov	DWORD PTR [eax+84], ecx
	mov	DWORD PTR [eax+76], ecx
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+40], ecx

; 1682 :         pjc->wNumButtons = pjc->wMaxButtons = 6;

	mov	ecx, 6
	mov	DWORD PTR [eax+72], ebx
	mov	DWORD PTR [eax+52], ebx
	mov	DWORD PTR [eax+44], ebx
	mov	DWORD PTR [eax+36], ebx
	mov	DWORD PTR [eax+108], ecx
	mov	DWORD PTR [eax+60], ecx

; 1683 :         pjc->wMaxAxes = pjc->wNumAxes = 6;

	mov	DWORD PTR [eax+104], ecx
	mov	DWORD PTR [eax+100], ecx

; 1684 :         pjc->wPeriodMin = pjc->wPeriodMax = 0;

	mov	DWORD PTR [eax+68], ebx
	mov	DWORD PTR [eax+64], ebx

; 1685 :         pjc->wCaps = JOYCAPS_HASZ | JOYCAPS_HASR | JOYCAPS_HASU | JOYCAPS_HASV;

	mov	DWORD PTR [eax+96], 15			; 0000000fH

; 1686 :         pjc->szRegKey[0] = 0;

	mov	BYTE PTR [eax+112], bl

; 1687 :         pjc->szOEMVxD[0] = 0;

	mov	BYTE PTR [eax+144], bl

; 1688 :         return JOYERR_NOERROR;

	xor	eax, eax
	pop	ebx

; 1702 : #endif /* PPJOY */
; 1703 : }

	ret	12					; 0000000cH
$L27713:

; 1689 :     }
; 1690 :     pjc->wMid = 0;
; 1691 :     pjc->wPid = 0;
; 1692 :     strcpy((char*)pjc->szPname, "");

	mov	cl, BYTE PTR ??_C@_00A@?$AA@		; `string'

; 1693 :     pjc->wXmin = pjc->wYmin = pjc->wZmin = pjc->wRmin = pjc->wUmin = pjc->wVmin = 0;

	mov	DWORD PTR [eax+88], ebx
	mov	BYTE PTR [eax+4], cl
	mov	DWORD PTR [eax+80], ebx
	mov	DWORD PTR [eax+72], ebx
	mov	DWORD PTR [eax+52], ebx
	mov	DWORD PTR [eax+44], ebx
	mov	DWORD PTR [eax+36], ebx

; 1694 :     pjc->wXmax = pjc->wYmax = pjc->wZmax = pjc->wRmax = pjc->wUmax = pjc->wVmax = 0;

	mov	DWORD PTR [eax+92], ebx
	mov	DWORD PTR [eax+84], ebx
	mov	DWORD PTR [eax+76], ebx
	mov	DWORD PTR [eax+56], ebx
	mov	DWORD PTR [eax+48], ebx
	mov	DWORD PTR [eax+40], ebx

; 1695 :     pjc->wNumButtons = pjc->wMaxButtons = 0;

	mov	DWORD PTR [eax+108], ebx
	mov	DWORD PTR [eax+60], ebx

; 1696 :     pjc->wMaxAxes = pjc->wNumAxes = 0;

	mov	DWORD PTR [eax+104], ebx
	mov	DWORD PTR [eax+100], ebx

; 1697 :     pjc->wPeriodMin = pjc->wPeriodMax = 0;

	mov	DWORD PTR [eax+68], ebx
	mov	DWORD PTR [eax+64], ebx

; 1698 :     pjc->wCaps = JOYCAPS_HASV;

	mov	DWORD PTR [eax+96], 8

; 1699 :     pjc->szRegKey[0] = 0;

	mov	BYTE PTR [eax+112], bl

; 1700 :     pjc->szOEMVxD[0] = 0;

	mov	BYTE PTR [eax+144], bl

; 1701 :     return JOYERR_UNPLUGGED;

	mov	eax, 167				; 000000a7H
	pop	ebx

; 1702 : #endif /* PPJOY */
; 1703 : }

	ret	12					; 0000000cH
_joyGetDevCapsA@12 ENDP
_TEXT	ENDS
PUBLIC	_joyGetNumDevs@0
;	COMDAT _joyGetNumDevs@0
_TEXT	SEGMENT
_joyGetNumDevs@0 PROC NEAR				; COMDAT

; 1710 : #ifdef PPJOY
; 1711 : 	UINT res;
; 1712 : 	res = pjoyGetNumDevs( );
; 1713 : 	return res;
; 1714 : #else /* PPJOY */
; 1715 :     return 1;

	mov	eax, 1

; 1716 : #endif /* PPJOY */
; 1717 : }

	ret	0
_joyGetNumDevs@0 ENDP
_TEXT	ENDS
PUBLIC	_joyGetPosEx@8
PUBLIC	_RunJsFilter
;	COMDAT _joyGetPosEx@8
_TEXT	SEGMENT
_uJoyID$ = 8
_pji$ = 12
_ch$ = -48
_joyGetPosEx@8 PROC NEAR				; COMDAT

; 1722 : #ifdef PPJOY
; 1723 : 	UINT res;
; 1724 : 
; 1725 : 	res = pjoyGetPosEx( uJoyID,  pji);
; 1726 : 	return res;
; 1727 : #else /* PPJOY */
; 1728 : 	int ch[MAX_JS_CH];
; 1729 : 	if (uJoyID == 0) {

	mov	eax, DWORD PTR _uJoyID$[esp-4]
	sub	esp, 48					; 00000030H
	test	eax, eax
	jne	SHORT $L27727
	push	esi
	push	edi

; 1730 : 		
; 1731 : 		/* Duplicate channel data */
; 1732 : 		memcpy(ch, Position, MAX_JS_CH*sizeof(int));

	mov	ecx, 12					; 0000000cH
	mov	esi, OFFSET FLAT:_Position
	lea	edi, DWORD PTR _ch$[esp+56]

; 1733 : 		
; 1734 : 		/* channel external filter */
; 1735 : 		RunJsFilter(ch, MAX_JS_CH);

	lea	eax, DWORD PTR _ch$[esp+56]
	push	12					; 0000000cH
	push	eax
	rep movsd
	call	_RunJsFilter

; 1736 : 
; 1737 : 				
; 1738 :         pji->dwXpos = ch[3];

	mov	eax, DWORD PTR _pji$[esp+60]
	mov	ecx, DWORD PTR _ch$[esp+76]

; 1739 :         pji->dwYpos = ch[2];

	mov	edx, DWORD PTR _ch$[esp+72]
	add	esp, 8
	mov	DWORD PTR [eax+8], ecx

; 1740 :         pji->dwZpos = ch[1];

	mov	ecx, DWORD PTR _ch$[esp+60]
	mov	DWORD PTR [eax+12], edx

; 1741 :         pji->dwRpos = ch[0];

	mov	edx, DWORD PTR _ch$[esp+56]
	mov	DWORD PTR [eax+16], ecx

; 1742 :         pji->dwUpos = ch[4];

	mov	ecx, DWORD PTR _ch$[esp+72]
	mov	DWORD PTR [eax+20], edx

; 1743 :         pji->dwVpos = ch[5];

	mov	edx, DWORD PTR _ch$[esp+76]
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], edx
	pop	edi

; 1744 :         return JOYERR_NOERROR;

	xor	eax, eax
	pop	esi

; 1748 : #endif /* PPJOY */
; 1749 : }

	add	esp, 48					; 00000030H
	ret	8
$L27727:

; 1745 : 	};
; 1746 : 	
; 1747 :     return JOYERR_UNPLUGGED;

	mov	eax, 167				; 000000a7H

; 1748 : #endif /* PPJOY */
; 1749 : }

	add	esp, 48					; 00000030H
	ret	8
_joyGetPosEx@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@EJKD@LoadWinmm?$CI?$CFd?$CJ?3?5Cannot?5find?5path?5@ ; `string'
PUBLIC	??_C@_0CM@MBL@LoadWinmm?$CI?$CFd?$CJ?3?5Cannot?5find?5path?5@ ; `string'
PUBLIC	??_C@_0L@MJGG@?2winmm?4dll?$AA@			; `string'
PUBLIC	_LoadWinmm
PUBLIC	_GetPointerToOriginalFunc
EXTRN	__imp__GetSystemDirectoryA@8:NEAR
;	COMDAT ??_C@_0DA@EJKD@LoadWinmm?$CI?$CFd?$CJ?3?5Cannot?5find?5path?5@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0DA@EJKD@LoadWinmm?$CI?$CFd?$CJ?3?5Cannot?5find?5path?5@ DB 'LoadWi'
	DB	'nmm(%d): Cannot find path for file (NULL)', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@MBL@LoadWinmm?$CI?$CFd?$CJ?3?5Cannot?5find?5path?5@
_DATA	SEGMENT
??_C@_0CM@MBL@LoadWinmm?$CI?$CFd?$CJ?3?5Cannot?5find?5path?5@ DB 'LoadWin'
	DB	'mm(%d): Cannot find path for file %s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@MJGG@?2winmm?4dll?$AA@
_DATA	SEGMENT
??_C@_0L@MJGG@?2winmm?4dll?$AA@ DB '\winmm.dll', 00H	; `string'
_DATA	ENDS
;	COMDAT _LoadWinmm
_TEXT	SEGMENT
_line$ = 8
_msg$ = -4000
_LoadWinmm PROC NEAR					; COMDAT

; 1753 : {

	sub	esp, 4000				; 00000fa0H

; 1754 : 
; 1755 : 	char msg[4000];
; 1756 : 
; 1757 :     if (!GetSystemDirectory(path, MAX_PATH)) 

	push	260					; 00000104H
	push	OFFSET FLAT:_path
	call	DWORD PTR __imp__GetSystemDirectoryA@8
	test	eax, eax
	jne	SHORT $L27733

; 1758 : 	{
; 1759 : 		if (path)

	mov	eax, OFFSET FLAT:_path
	test	eax, eax
	je	SHORT $L27734

; 1760 : 			sprintf(msg, "LoadWinmm(%d): Cannot find path for file (NULL)", line);

	mov	ecx, DWORD PTR _line$[esp+3996]
	lea	edx, DWORD PTR _msg$[esp+4000]
	push	ecx
	push	OFFSET FLAT:??_C@_0DA@EJKD@LoadWinmm?$CI?$CFd?$CJ?3?5Cannot?5find?5path?5@ ; `string'
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1761 : 		else

	jmp	SHORT $L27736
$L27734:

; 1762 : 			sprintf(msg, "LoadWinmm(%d): Cannot find path for file %s", line, path);

	mov	eax, DWORD PTR _line$[esp+3996]
	push	OFFSET FLAT:_path
	push	eax
	lea	ecx, DWORD PTR _msg$[esp+4008]
	push	OFFSET FLAT:??_C@_0CM@MBL@LoadWinmm?$CI?$CFd?$CJ?3?5Cannot?5find?5path?5@ ; `string'
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
$L27736:

; 1763 : 		MESSAGE(msg, MB_ICONERROR);

	push	1763					; 000006e3H
	push	OFFSET FLAT:??_C@_0CJ@OOJL@C?3?2Code?2SmartPropoPlus?2330?2Winmm@ ; `string'
	lea	edx, DWORD PTR _msg$[esp+4008]
	push	16					; 00000010H
	push	edx
	call	_Message
	add	esp, 16					; 00000010H

; 1764 : 		return FALSE;

	xor	eax, eax

; 1774 : }

	add	esp, 4000				; 00000fa0H
	ret	0
$L27733:
	push	esi
	push	edi

; 1765 : 	};
; 1766 :     strcat(path, "\\winmm.dll");

	mov	edi, OFFSET FLAT:??_C@_0L@MJGG@?2winmm?4dll?$AA@ ; `string'
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	sub	edi, ecx
	mov	esi, edi
	mov	edx, ecx
	mov	edi, OFFSET FLAT:_path
	or	ecx, -1
	repne scasb
	mov	ecx, edx
	dec	edi
	shr	ecx, 2
	rep movsd

; 1767 :     hWinmm = LoadOrigDll(path, line);

	mov	eax, DWORD PTR _line$[esp+4004]
	mov	ecx, edx
	and	ecx, 3
	push	eax
	rep movsb
	push	OFFSET FLAT:_path
	call	_LoadOrigDll
	add	esp, 8
	mov	DWORD PTR _hWinmm, eax

; 1768 :     if (!hWinmm) 

	test	eax, eax
	pop	edi
	pop	esi
	jne	SHORT $L27739

; 1774 : }

	add	esp, 4000				; 00000fa0H
	ret	0
$L27739:

; 1769 : 		return FALSE;
; 1770 : 
; 1771 : 	GetPointerToOriginalFunc();

	call	_GetPointerToOriginalFunc

; 1772 : 
; 1773 : 	return TRUE;

	mov	eax, 1

; 1774 : }

	add	esp, 4000				; 00000fa0H
	ret	0
_LoadWinmm ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@NHMO@JsChPostProc?4dll?$AA@		; `string'
PUBLIC	??_C@_0DC@DGNP@Joystick?5filter?5too?5old?5?9?5cannot@ ; `string'
PUBLIC	_LoadJsChPostProc
PUBLIC	_GetPointerToJsChPostProcOriginalFunc
;	COMDAT ??_C@_0BB@NHMO@JsChPostProc?4dll?$AA@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0BB@NHMO@JsChPostProc?4dll?$AA@ DB 'JsChPostProc.dll', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DC@DGNP@Joystick?5filter?5too?5old?5?9?5cannot@
_DATA	SEGMENT
??_C@_0DC@DGNP@Joystick?5filter?5too?5old?5?9?5cannot@ DB 'Joystick filte'
	DB	'r too old - cannot load filter file', 00H	; `string'
_DATA	ENDS
;	COMDAT _LoadJsChPostProc
_TEXT	SEGMENT
_LoadJsChPostProc PROC NEAR				; COMDAT

; 1778 : {

	push	esi

; 1779 : 
; 1780 : 	HINSTANCE h;
; 1781 : 	long filter_ver;
; 1782 : 
; 1783 : 	/* Load DLL */
; 1784 : 	h = LoadLibraryEx("JsChPostProc.dll", NULL, 0);

	push	0
	push	0
	push	OFFSET FLAT:??_C@_0BB@NHMO@JsChPostProc?4dll?$AA@ ; `string'
	call	DWORD PTR __imp__LoadLibraryExA@12
	mov	esi, eax

; 1785 : 	if (!h)

	test	esi, esi
	jne	SHORT $L27745
	pop	esi

; 1804 : }

	ret	0
$L27745:

; 1786 : 		return h;
; 1787 : 
; 1788 : 	/* Load the interface functions */
; 1789 : 	if (!GetPointerToJsChPostProcOriginalFunc(h))

	push	esi
	call	_GetPointerToJsChPostProcOriginalFunc
	add	esp, 4
	test	eax, eax
	jne	SHORT $L27746
	pop	esi

; 1804 : }

	ret	0
$L27746:

; 1790 : 		return NULL;
; 1791 : 
; 1792 : 	/* Allocate in/out joystick data buffer */
; 1793 : 	js_data = (JS_CHANNELS *)calloc(1, sizeof(JS_CHANNELS));

	push	8
	push	1
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _js_data, eax

; 1794 : 
; 1795 : 	/* Initialize filter */
; 1796 : 	filter_ver = GetDllVersion();

	call	DWORD PTR _GetDllVersion

; 1797 : 	if (filter_ver < 0x30100)

	cmp	eax, 196864				; 00030100H
	jge	SHORT $L27750

; 1798 : 	{
; 1799 : 		MessageBox(NULL,"Joystick filter too old - cannot load filter file", "SmartPropoPlus Debug Message" , MB_SYSTEMMODAL);

	push	4096					; 00001000H
	push	OFFSET FLAT:??_C@_0BN@KJAH@SmartPropoPlus?5Debug?5Message?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0DC@DGNP@Joystick?5filter?5too?5old?5?9?5cannot@ ; `string'
	push	0
	call	DWORD PTR __imp__MessageBoxA@16

; 1800 : 		return NULL;

	xor	eax, eax
	pop	esi

; 1804 : }

	ret	0
$L27750:

; 1801 : 	};
; 1802 : 
; 1803 : 	return h;

	mov	eax, esi
	pop	esi

; 1804 : }

	ret	0
_LoadJsChPostProc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@KNBM@GetDllVersion?$AA@		; `string'
PUBLIC	??_C@_0BA@DOIL@ProcessChannels?$AA@		; `string'
PUBLIC	??_C@_0BD@OKGG@GetNumberOfFilters?$AA@		; `string'
PUBLIC	??_C@_0BF@IBB@GetFilterNameByIndex?$AA@		; `string'
PUBLIC	??_C@_0BD@IEFL@GetFilterIdByIndex?$AA@		; `string'
PUBLIC	??_C@_0BE@DEON@SelectFilterByIndex?$AA@		; `string'
PUBLIC	??_C@_0BJ@KJLB@GetIndexOfSelectedFilter?$AA@	; `string'
EXTRN	__imp__GetProcAddress@8:NEAR
;	COMDAT ??_C@_0O@KNBM@GetDllVersion?$AA@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0O@KNBM@GetDllVersion?$AA@ DB 'GetDllVersion', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@DOIL@ProcessChannels?$AA@
_DATA	SEGMENT
??_C@_0BA@DOIL@ProcessChannels?$AA@ DB 'ProcessChannels', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@OKGG@GetNumberOfFilters?$AA@
_DATA	SEGMENT
??_C@_0BD@OKGG@GetNumberOfFilters?$AA@ DB 'GetNumberOfFilters', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@IBB@GetFilterNameByIndex?$AA@
_DATA	SEGMENT
??_C@_0BF@IBB@GetFilterNameByIndex?$AA@ DB 'GetFilterNameByIndex', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IEFL@GetFilterIdByIndex?$AA@
_DATA	SEGMENT
??_C@_0BD@IEFL@GetFilterIdByIndex?$AA@ DB 'GetFilterIdByIndex', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DEON@SelectFilterByIndex?$AA@
_DATA	SEGMENT
??_C@_0BE@DEON@SelectFilterByIndex?$AA@ DB 'SelectFilterByIndex', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@KJLB@GetIndexOfSelectedFilter?$AA@
_DATA	SEGMENT
??_C@_0BJ@KJLB@GetIndexOfSelectedFilter?$AA@ DB 'GetIndexOfSelectedFilter'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT _GetPointerToJsChPostProcOriginalFunc
_TEXT	SEGMENT
_h$ = 8
_GetPointerToJsChPostProcOriginalFunc PROC NEAR		; COMDAT

; 1809 : {

	push	esi

; 1810 : 	if (!h)

	mov	esi, DWORD PTR _h$[esp]
	test	esi, esi
	push	edi
	jne	SHORT $L27757
	pop	edi

; 1811 : 		return FALSE;

	xor	eax, eax
	pop	esi

; 1828 : }

	ret	0
$L27757:

; 1812 : 
; 1813 : 	GetDllVersion = GetProcAddress(h,"GetDllVersion");

	mov	edi, DWORD PTR __imp__GetProcAddress@8
	push	OFFSET FLAT:??_C@_0O@KNBM@GetDllVersion?$AA@ ; `string'
	push	esi
	call	edi

; 1814 : 	if (!GetDllVersion)

	test	eax, eax
	mov	DWORD PTR _GetDllVersion, eax
	jne	SHORT $L27759
	pop	edi
	pop	esi

; 1828 : }

	ret	0
$L27759:

; 1815 : 		return FALSE;
; 1816 : 
; 1817 : 	ProcessChannels = (PJS_CHANNELS  (WINAPI *)(PJS_CHANNELS, int max, int min))GetProcAddress(h,"ProcessChannels");

	push	OFFSET FLAT:??_C@_0BA@DOIL@ProcessChannels?$AA@ ; `string'
	push	esi
	call	edi

; 1818 : 	if (!ProcessChannels)

	test	eax, eax
	mov	DWORD PTR _ProcessChannels, eax
	jne	SHORT $L27767
	pop	edi
	pop	esi

; 1828 : }

	ret	0
$L27767:

; 1819 : 		return FALSE;
; 1820 : 
; 1821 : 	pGetNumberOfFilters = (int  (WINAPI *)(void))GetProcAddress(h,"GetNumberOfFilters");

	push	OFFSET FLAT:??_C@_0BD@OKGG@GetNumberOfFilters?$AA@ ; `string'
	push	esi
	call	edi

; 1822 : 	pGetFilterNameByIndex = (const char *    (WINAPI *)(const int i))GetProcAddress(h,"GetFilterNameByIndex");

	push	OFFSET FLAT:??_C@_0BF@IBB@GetFilterNameByIndex?$AA@ ; `string'
	push	esi
	mov	DWORD PTR _pGetNumberOfFilters, eax
	call	edi

; 1823 : 	pGetFilterIdByIndex = (const int   (WINAPI *)(const int iFilter))GetProcAddress(h,"GetFilterIdByIndex");

	push	OFFSET FLAT:??_C@_0BD@IEFL@GetFilterIdByIndex?$AA@ ; `string'
	push	esi
	mov	DWORD PTR _pGetFilterNameByIndex, eax
	call	edi

; 1824 : 	pSelectFilterByIndex = (const int  (WINAPI *)(const int iFilter))GetProcAddress(h,"SelectFilterByIndex");

	push	OFFSET FLAT:??_C@_0BE@DEON@SelectFilterByIndex?$AA@ ; `string'
	push	esi
	mov	DWORD PTR _pGetFilterIdByIndex, eax
	call	edi

; 1825 : 	pGetIndexOfSelectedFilter = (const int  (WINAPI *)(void))GetProcAddress(h,"GetIndexOfSelectedFilter");

	push	OFFSET FLAT:??_C@_0BJ@KJLB@GetIndexOfSelectedFilter?$AA@ ; `string'
	push	esi
	mov	DWORD PTR _pSelectFilterByIndex, eax
	call	edi
	mov	DWORD PTR _pGetIndexOfSelectedFilter, eax
	pop	edi

; 1826 : 
; 1827 : 	return TRUE;

	mov	eax, 1
	pop	esi

; 1828 : }

	ret	0
_GetPointerToJsChPostProcOriginalFunc ENDP
_TEXT	ENDS
PUBLIC	??_C@_09HIAF@?$CIDefault?$CJ?$AA@		; `string'
EXTRN	_SetNumberOfFilters:NEAR
EXTRN	_SetSelectedFilterIndex:NEAR
EXTRN	_SetFilterNames:NEAR
EXTRN	_strdup:NEAR
;	COMDAT ??_C@_09HIAF@?$CIDefault?$CJ?$AA@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_09HIAF@?$CIDefault?$CJ?$AA@ DB '(Default)', 00H	; `string'
_DATA	ENDS
;	COMDAT _GetJsChPostProcInfo
_TEXT	SEGMENT
_hJschpostproc$ = 8
_names$ = -508
_GetJsChPostProcInfo PROC NEAR				; COMDAT

; 1833 : 	int n, sel, i;
; 1834 : 
; 1835 : 	char * names[127];
; 1836 : 	if (!hJschpostproc)

	mov	eax, DWORD PTR _hJschpostproc$[esp-4]
	sub	esp, 508				; 000001fcH
	test	eax, eax
	jne	SHORT $L27793

; 1837 : 		return 0;

	xor	eax, eax

; 1870 : }

	add	esp, 508				; 000001fcH
	ret	0
$L27793:

; 1838 : 
; 1839 : 
; 1840 : 	/* Number of supported filters */
; 1841 : 	if (pGetNumberOfFilters)

	mov	eax, DWORD PTR _pGetNumberOfFilters
	push	ebx
	test	eax, eax
	je	SHORT $L27794

; 1842 : 		n = pGetNumberOfFilters();

	call	eax
	mov	ebx, eax

; 1843 : 	else

	jmp	SHORT $L27795
$L27794:

; 1844 : 		n=1;

	mov	ebx, 1
$L27795:

; 1845 : 	SetNumberOfFilters(n);

	push	ebx
	call	_SetNumberOfFilters

; 1846 : 
; 1847 : 	/* Selected filter */
; 1848 : 	sel = -1;
; 1849 : 	if (pGetIndexOfSelectedFilter)

	mov	eax, DWORD PTR _pGetIndexOfSelectedFilter
	add	esp, 4
	test	eax, eax
	je	SHORT $L27797

; 1850 : 		sel = pGetIndexOfSelectedFilter();

	call	eax

; 1851 : 	if (sel >= 0)

	test	eax, eax
	jl	SHORT $L27797

; 1852 : 		SetSelectedFilterIndex(sel);

	push	eax
	call	_SetSelectedFilterIndex
	add	esp, 4
$L27797:

; 1853 : 	
; 1854 : 	/* Filter names */
; 1855 : 	if (pGetFilterNameByIndex)

	mov	eax, DWORD PTR _pGetFilterNameByIndex
	test	eax, eax
	je	SHORT $L27798
	push	esi

; 1856 : 	{
; 1857 : 		for (i=0; i<n ; i++)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $L27801
	push	edi
	lea	edi, DWORD PTR _names$[esp+520]
$L27799:

; 1858 : 			names[i] = strdup(pGetFilterNameByIndex(i));

	push	esi
	call	DWORD PTR _pGetFilterNameByIndex
	push	eax
	call	_strdup
	add	esp, 4
	mov	DWORD PTR [edi], eax
	inc	esi
	add	edi, 4
	cmp	esi, ebx
	jl	SHORT $L27799
	pop	edi
$L27801:

; 1859 : 		names[i] = NULL;

	mov	DWORD PTR _names$[esp+esi*4+516], 0
	pop	esi

; 1860 : 	}
; 1861 : 	else

	jmp	SHORT $L27803
$L27798:

; 1862 : 	{
; 1863 : 		names[0] = "(Default)";

	mov	DWORD PTR _names$[esp+512], OFFSET FLAT:??_C@_09HIAF@?$CIDefault?$CJ?$AA@ ; `string'

; 1864 : 		names[1] = NULL;

	mov	DWORD PTR _names$[esp+516], 0
$L27803:

; 1865 : 	};
; 1866 : 	
; 1867 : 	SetFilterNames(names);

	lea	eax, DWORD PTR _names$[esp+512]
	push	eax
	call	_SetFilterNames
	add	esp, 4

; 1868 : 
; 1869 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1870 : }

	add	esp, 508				; 000001fcH
	ret	0
_GetJsChPostProcInfo ENDP
_TEXT	ENDS
;	COMDAT _RunJsFilter
_TEXT	SEGMENT
_ch$ = 8
_nChannels$ = 12
_RunJsFilter PROC NEAR					; COMDAT

; 1876 : 	int n_out_ch=0;
; 1877 : 	JS_CHANNELS  * js_filter_out;
; 1878 : 	int i;
; 1879 : 
; 1880 : #if 0 // Collect channel data
; 1881 : 	fprintf(gChnlLogFile, "\n%d\t;%d\t;%d\t;%d\t;%d\t;%d\t;%d\t;%d\t;%d\t;%d\t;%d\t;%d",\
; 1882 : 		ch[0],ch[1],ch[2],ch[3],ch[4], ch[5],ch[6],ch[7],ch[8],ch[9],ch[10],ch[11]);
; 1883 : #endif
; 1884 : 
; 1885 : 	SetActiveJsChPostProcFunction(DataBlock);

	mov	eax, DWORD PTR _hJschpostproc
	push	esi
	push	edi
	xor	edi, edi
	test	eax, eax
	jne	SHORT $L29658
	mov	DWORD PTR _JsChPostProc_selected, -1
$L29665:

; 1901 : 		}
; 1902 : 	};
; 1903 : 	return n_out_ch;

	mov	eax, edi
	pop	edi
	pop	esi

; 1904 : }

	ret	0

; 1876 : 	int n_out_ch=0;
; 1877 : 	JS_CHANNELS  * js_filter_out;
; 1878 : 	int i;
; 1879 : 
; 1880 : #if 0 // Collect channel data
; 1881 : 	fprintf(gChnlLogFile, "\n%d\t;%d\t;%d\t;%d\t;%d\t;%d\t;%d\t;%d\t;%d\t;%d\t;%d\t;%d",\
; 1882 : 		ch[0],ch[1],ch[2],ch[3],ch[4], ch[5],ch[6],ch[7],ch[8],ch[9],ch[10],ch[11]);
; 1883 : #endif
; 1884 : 
; 1885 : 	SetActiveJsChPostProcFunction(DataBlock);

$L29658:
	mov	eax, DWORD PTR _DataBlock
	mov	ecx, DWORD PTR _JsChPostProc_selected
	mov	eax, DWORD PTR [eax+1180]
	cmp	eax, ecx
	je	SHORT $L29660
	mov	ecx, DWORD PTR _pSelectFilterByIndex
	mov	DWORD PTR _JsChPostProc_selected, eax
	test	ecx, ecx
	je	SHORT $L29660
	push	eax
	call	ecx
$L29660:

; 1886 : 
; 1887 : 	if (hJschpostproc && JsChPostProc_selected!=-1)

	mov	eax, DWORD PTR _hJschpostproc
	test	eax, eax
	je	SHORT $L29665
	cmp	DWORD PTR _JsChPostProc_selected, -1
	je	SHORT $L29665

; 1888 : 	{
; 1889 : 		js_data->ch = nChannels;

	mov	ecx, DWORD PTR _js_data
	mov	edx, DWORD PTR _nChannels$[esp+4]

; 1890 : 		js_data->value = ch;

	mov	esi, DWORD PTR _ch$[esp+4]

; 1891 : 		js_filter_out = ProcessChannels(js_data, 1023, 0);

	push	0
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _js_data
	push	1023					; 000003ffH
	mov	DWORD PTR [eax+4], esi
	mov	ecx, DWORD PTR _js_data
	push	ecx
	call	DWORD PTR _ProcessChannels

; 1892 : 		if (js_filter_out && js_filter_out->ch>0 && js_filter_out->ch<=MAX_JS_CH)

	test	eax, eax
	je	SHORT $L29665
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	jle	SHORT $L29665
	cmp	edx, 12					; 0000000cH
	jg	SHORT $L29665

; 1893 : 		{
; 1894 : 			for (i=0;i<js_filter_out->ch;i++)

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $L27818
$L27816:

; 1895 : 			{
; 1896 : 				ch[i] = js_filter_out->value[i];

	mov	edx, DWORD PTR [eax+4]
	inc	ecx
	mov	edx, DWORD PTR [edx+ecx*4-4]
	mov	DWORD PTR [esi+ecx*4-4], edx

; 1897 : 				js_filter_out->value[i] = 0;

	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx*4-4], 0
	mov	edx, DWORD PTR [eax]
	cmp	ecx, edx
	jl	SHORT $L27816
$L27818:

; 1898 : 			};
; 1899 : 			n_out_ch = js_filter_out->ch;

	mov	ecx, DWORD PTR [eax]

; 1900 : 			js_filter_out->ch=0;

	mov	DWORD PTR [eax], 0
	pop	edi

; 1901 : 		}
; 1902 : 	};
; 1903 : 	return n_out_ch;

	mov	eax, ecx
	pop	esi

; 1904 : }

	ret	0
_RunJsFilter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@FGGD@CloseDriver?$AA@			; `string'
PUBLIC	??_C@_0O@PEDJ@DefDriverProc?$AA@		; `string'
PUBLIC	??_C@_0P@GMDJ@DriverCallback?$AA@		; `string'
PUBLIC	??_C@_0BD@JLHO@DrvGetModuleHandle?$AA@		; `string'
PUBLIC	??_C@_0BG@EEHB@GetDriverModuleHandle?$AA@	; `string'
PUBLIC	??_C@_0BC@MFHB@MigrateAllDrivers?$AA@		; `string'
PUBLIC	??_C@_0BD@KFIL@MigrateSoundEvents?$AA@		; `string'
PUBLIC	??_C@_0BD@IALO@NotifyCallbackData?$AA@		; `string'
PUBLIC	??_C@_0L@OOCK@OpenDriver?$AA@			; `string'
PUBLIC	??_C@_09OHCJ@PlaySound?$AA@			; `string'
PUBLIC	??_C@_0L@CELA@PlaySoundA?$AA@			; `string'
PUBLIC	??_C@_0L@HCLC@PlaySoundW?$AA@			; `string'
PUBLIC	??_C@_0BC@EGH@SendDriverMessage?$AA@		; `string'
PUBLIC	??_C@_0BE@HCOI@WOW32DriverCallback?$AA@		; `string'
PUBLIC	??_C@_0BN@CCM@WOW32ResolveMultiMediaHandle?$AA@	; `string'
PUBLIC	??_C@_0L@KFKN@WOWAppExit?$AA@			; `string'
PUBLIC	??_C@_0M@IBFM@WinmmLogoff?$AA@			; `string'
PUBLIC	??_C@_0L@FKIE@WinmmLogon?$AA@			; `string'
PUBLIC	??_C@_0N@LFH@aux32Message?$AA@			; `string'
PUBLIC	??_C@_0P@CIL@auxGetDevCapsA?$AA@		; `string'
PUBLIC	??_C@_0P@FEIJ@auxGetDevCapsW?$AA@		; `string'
PUBLIC	??_C@_0O@IJOA@auxGetNumDevs?$AA@		; `string'
PUBLIC	??_C@_0N@EKJK@auxGetVolume?$AA@			; `string'
PUBLIC	??_C@_0O@FOOK@auxOutMessage?$AA@		; `string'
PUBLIC	??_C@_0N@GHDI@auxSetVolume?$AA@			; `string'
PUBLIC	??_C@_0N@HEGD@joy32Message?$AA@			; `string'
PUBLIC	??_C@_0BB@DMC@joyConfigChanged?$AA@		; `string'
PUBLIC	??_C@_0P@LCHD@joyGetDevCapsA?$AA@		; `string'
PUBLIC	??_C@_0P@OEHB@joyGetDevCapsW?$AA@		; `string'
PUBLIC	??_C@_0O@HBJP@joyGetNumDevs?$AA@		; `string'
PUBLIC	??_C@_09DPN@joyGetPos?$AA@			; `string'
PUBLIC	??_C@_0BA@JKBD@joyGetThreshold?$AA@		; `string'
PUBLIC	??_C@_0BC@DMDH@joyReleaseCapture?$AA@		; `string'
PUBLIC	??_C@_0O@KPDA@joySetCapture?$AA@		; `string'
PUBLIC	??_C@_0BA@PDBB@joySetThreshold?$AA@		; `string'
PUBLIC	??_C@_0N@HHJD@mci32Message?$AA@			; `string'
PUBLIC	??_C@_0BA@FIAF@mciDriverNotify?$AA@		; `string'
PUBLIC	??_C@_0P@KNAD@mciDriverYield?$AA@		; `string'
PUBLIC	??_C@_0L@LOGF@mciExecute?$AA@			; `string'
PUBLIC	??_C@_0BH@EHJF@mciFreeCommandResource?$AA@	; `string'
PUBLIC	??_C@_0BC@BBJL@mciGetCreatorTask?$AA@		; `string'
PUBLIC	??_C@_0BA@KIH@mciGetDeviceIDA?$AA@		; `string'
PUBLIC	??_C@_0BN@MCHF@mciGetDeviceIDFromElementIDA?$AA@ ; `string'
PUBLIC	??_C@_0BN@JEHH@mciGetDeviceIDFromElementIDW?$AA@ ; `string'
PUBLIC	??_C@_0BA@FMIF@mciGetDeviceIDW?$AA@		; `string'
PUBLIC	??_C@_0BB@DLAL@mciGetDriverData?$AA@		; `string'
PUBLIC	??_C@_0BD@IDBJ@mciGetErrorStringA?$AA@		; `string'
PUBLIC	??_C@_0BD@NFBL@mciGetErrorStringW?$AA@		; `string'
PUBLIC	??_C@_0BA@LJKD@mciGetYieldProc?$AA@		; `string'
PUBLIC	??_C@_0BH@IJD@mciLoadCommandResource?$AA@	; `string'
PUBLIC	??_C@_0BA@JKLO@mciSendCommandA?$AA@		; `string'
PUBLIC	??_C@_0BA@MMLM@mciSendCommandW?$AA@		; `string'
PUBLIC	??_C@_0P@GAMF@mciSendStringA?$AA@		; `string'
PUBLIC	??_C@_0P@DGMH@mciSendStringW?$AA@		; `string'
PUBLIC	??_C@_0BB@GIGC@mciSetDriverData?$AA@		; `string'
PUBLIC	??_C@_0BA@NAKB@mciSetYieldProc?$AA@		; `string'
PUBLIC	??_C@_0N@DICL@mid32Message?$AA@			; `string'
PUBLIC	??_C@_0M@CPPD@midiConnect?$AA@			; `string'
PUBLIC	??_C@_0P@KHF@midiDisconnect?$AA@		; `string'
PUBLIC	??_C@_0BA@MNBE@midiInAddBuffer?$AA@		; `string'
PUBLIC	??_C@_0M@KBJH@midiInClose?$AA@			; `string'
PUBLIC	??_C@_0BC@NPDI@midiInGetDevCapsA?$AA@		; `string'
PUBLIC	??_C@_0BC@IJDK@midiInGetDevCapsW?$AA@		; `string'
PUBLIC	??_C@_0BE@OCKH@midiInGetErrorTextA?$AA@		; `string'
PUBLIC	??_C@_0BE@LEKF@midiInGetErrorTextW?$AA@		; `string'
PUBLIC	??_C@_0M@LGKJ@midiInGetID?$AA@			; `string'
PUBLIC	??_C@_0BB@DKPK@midiInGetNumDevs?$AA@		; `string'
PUBLIC	??_C@_0O@DNDL@midiInMessage?$AA@		; `string'
PUBLIC	??_C@_0L@FPCM@midiInOpen?$AA@			; `string'
PUBLIC	??_C@_0BE@PKDG@midiInPrepareHeader?$AA@		; `string'
PUBLIC	??_C@_0M@OLBB@midiInReset?$AA@			; `string'
PUBLIC	??_C@_0M@LFPM@midiInStart?$AA@			; `string'
PUBLIC	??_C@_0L@GHDE@midiInStop?$AA@			; `string'
PUBLIC	??_C@_0BG@JPPA@midiInUnprepareHeader?$AA@	; `string'
PUBLIC	??_C@_0BI@NAJB@midiOutCacheDrumPatches?$AA@	; `string'
PUBLIC	??_C@_0BE@CBNA@midiOutCachePatches?$AA@		; `string'
PUBLIC	??_C@_0N@PCNN@midiOutClose?$AA@			; `string'
PUBLIC	??_C@_0BD@BA@midiOutGetDevCapsA?$AA@		; `string'
PUBLIC	??_C@_0BD@FGBC@midiOutGetDevCapsW?$AA@		; `string'
PUBLIC	??_C@_0BF@HLAE@midiOutGetErrorTextA?$AA@	; `string'
PUBLIC	??_C@_0BF@CNAG@midiOutGetErrorTextW?$AA@	; `string'
PUBLIC	??_C@_0N@OFOD@midiOutGetID?$AA@			; `string'
PUBLIC	??_C@_0BC@BCOH@midiOutGetNumDevs?$AA@		; `string'
PUBLIC	??_C@_0BB@ENJA@midiOutGetVolume?$AA@		; `string'
PUBLIC	??_C@_0P@KNDI@midiOutLongMsg?$AA@		; `string'
PUBLIC	??_C@_0P@BJFN@midiOutMessage?$AA@		; `string'
PUBLIC	??_C@_0M@BFFB@midiOutOpen?$AA@			; `string'
PUBLIC	??_C@_0BF@GDJF@midiOutPrepareHeader?$AA@	; `string'
PUBLIC	??_C@_0N@LIFL@midiOutReset?$AA@			; `string'
PUBLIC	??_C@_0BB@GADC@midiOutSetVolume?$AA@		; `string'
PUBLIC	??_C@_0BA@ICEO@midiOutShortMsg?$AA@		; `string'
PUBLIC	??_C@_0BH@MNAE@midiOutUnprepareHeader?$AA@	; `string'
PUBLIC	??_C@_0BA@PKJI@midiStreamClose?$AA@		; `string'
PUBLIC	??_C@_0P@FAGH@midiStreamOpen?$AA@		; `string'
PUBLIC	??_C@_0O@MCEN@midiStreamOut?$AA@		; `string'
PUBLIC	??_C@_0BA@JHNK@midiStreamPause?$AA@		; `string'
PUBLIC	??_C@_0BD@CJJI@midiStreamPosition?$AA@		; `string'
PUBLIC	??_C@_0BD@NHF@midiStreamProperty?$AA@		; `string'
PUBLIC	??_C@_0BC@LLAA@midiStreamRestart?$AA@		; `string'
PUBLIC	??_C@_0P@GIHP@midiStreamStop?$AA@		; `string'
PUBLIC	??_C@_0L@NGHK@mixerClose?$AA@			; `string'
PUBLIC	??_C@_0BI@KKIG@mixerGetControlDetailsA?$AA@	; `string'
PUBLIC	??_C@_0BI@PMIE@mixerGetControlDetailsW?$AA@	; `string'
PUBLIC	??_C@_0BB@MMIF@mixerGetDevCapsA?$AA@		; `string'
PUBLIC	??_C@_0BB@JKIH@mixerGetDevCapsW?$AA@		; `string'
PUBLIC	??_C@_0L@MBEE@mixerGetID?$AA@			; `string'
PUBLIC	??_C@_0BG@GELF@mixerGetLineControlsA?$AA@	; `string'
PUBLIC	??_C@_0BG@DCLH@mixerGetLineControlsW?$AA@	; `string'
PUBLIC	??_C@_0BC@LCF@mixerGetLineInfoA?$AA@		; `string'
PUBLIC	??_C@_0BC@FNCH@mixerGetLineInfoW?$AA@		; `string'
PUBLIC	??_C@_0BA@IHGE@mixerGetNumDevs?$AA@		; `string'
PUBLIC	??_C@_0N@LFII@mixerMessage?$AA@			; `string'
PUBLIC	??_C@_09LCEO@mixerOpen?$AA@			; `string'
PUBLIC	??_C@_0BH@EDCE@mixerSetControlDetails?$AA@	; `string'
PUBLIC	??_C@_0N@DCIM@mmDrvInstall?$AA@			; `string'
PUBLIC	??_C@_0BB@NEHP@mmGetCurrentTask?$AA@		; `string'
PUBLIC	??_C@_0M@CGD@mmTaskBlock?$AA@			; `string'
PUBLIC	??_C@_0N@GAFI@mmTaskCreate?$AA@			; `string'
PUBLIC	??_C@_0N@GFLM@mmTaskSignal?$AA@			; `string'
PUBLIC	??_C@_0M@LAKN@mmTaskYield?$AA@			; `string'
PUBLIC	??_C@_0M@IBMG@mmioAdvance?$AA@			; `string'
PUBLIC	??_C@_0L@LHNO@mmioAscend?$AA@			; `string'
PUBLIC	??_C@_09JPN@mmioClose?$AA@			; `string'
PUBLIC	??_C@_0BA@CDLD@mmioCreateChunk?$AA@		; `string'
PUBLIC	??_C@_0M@NPPM@mmioDescend?$AA@			; `string'
PUBLIC	??_C@_09GIMM@mmioFlush?$AA@			; `string'
PUBLIC	??_C@_0M@HOBF@mmioGetInfo?$AA@			; `string'
PUBLIC	??_C@_0BD@KFBE@mmioInstallIOProcA?$AA@		; `string'
PUBLIC	??_C@_0BD@PDBG@mmioInstallIOProcW?$AA@		; `string'
PUBLIC	??_C@_09DNGC@mmioOpenA?$AA@			; `string'
PUBLIC	??_C@_09GLGA@mmioOpenW?$AA@			; `string'
PUBLIC	??_C@_08JKLF@mmioRead?$AA@			; `string'
PUBLIC	??_C@_0M@PEIF@mmioRenameA?$AA@			; `string'
PUBLIC	??_C@_0M@KCIH@mmioRenameW?$AA@			; `string'
PUBLIC	??_C@_08OEBA@mmioSeek?$AA@			; `string'
PUBLIC	??_C@_0BA@PCED@mmioSendMessage?$AA@		; `string'
PUBLIC	??_C@_0O@OCHB@mmioSetBuffer?$AA@		; `string'
PUBLIC	??_C@_0M@CNBJ@mmioSetInfo?$AA@			; `string'
PUBLIC	??_C@_0BE@CJEP@mmioStringToFOURCCA?$AA@		; `string'
PUBLIC	??_C@_0BE@HPEN@mmioStringToFOURCCW?$AA@		; `string'
PUBLIC	??_C@_09KGEC@mmioWrite?$AA@			; `string'
PUBLIC	??_C@_0BD@BLEE@mmsystemGetVersion?$AA@		; `string'
PUBLIC	??_C@_0N@EHAL@mod32Message?$AA@			; `string'
PUBLIC	??_C@_0N@HKFI@mxd32Message?$AA@			; `string'
PUBLIC	??_C@_0O@CLPB@sndPlaySoundA?$AA@		; `string'
PUBLIC	??_C@_0O@HNPD@sndPlaySoundW?$AA@		; `string'
PUBLIC	??_C@_0N@OEDN@tid32Message?$AA@			; `string'
PUBLIC	??_C@_0BA@CAIP@timeBeginPeriod?$AA@		; `string'
PUBLIC	??_C@_0O@NIGI@timeEndPeriod?$AA@		; `string'
PUBLIC	??_C@_0P@MAOL@timeGetDevCaps?$AA@		; `string'
PUBLIC	??_C@_0BC@HHNM@timeGetSystemTime?$AA@		; `string'
PUBLIC	??_C@_0M@HBOP@timeGetTime?$AA@			; `string'
PUBLIC	??_C@_0O@CIKN@timeKillEvent?$AA@		; `string'
PUBLIC	??_C@_0N@JPEP@timeSetEvent?$AA@			; `string'
PUBLIC	??_C@_0BC@PGPH@waveInGetDevCapsA?$AA@		; `string'
PUBLIC	??_C@_0BC@KAPF@waveInGetDevCapsW?$AA@		; `string'
PUBLIC	??_C@_0BE@IDJN@waveInGetErrorTextA?$AA@		; `string'
PUBLIC	??_C@_0BE@NFJP@waveInGetErrorTextW?$AA@		; `string'
PUBLIC	??_C@_0M@CAPK@waveInGetID?$AA@			; `string'
PUBLIC	??_C@_0BB@PFCO@waveInGetNumDevs?$AA@		; `string'
PUBLIC	??_C@_0BC@CLNA@waveInGetPosition?$AA@		; `string'
PUBLIC	??_C@_0O@FBPN@waveInMessage?$AA@		; `string'
PUBLIC	??_C@_0M@HNEC@waveInReset?$AA@			; `string'
PUBLIC	??_C@_0BB@EJGO@waveOutBreakLoop?$AA@		; `string'
PUBLIC	??_C@_0N@DEEL@waveOutClose?$AA@			; `string'
PUBLIC	??_C@_0BD@DKDJ@waveOutGetDevCapsA?$AA@		; `string'
PUBLIC	??_C@_0BD@GMDL@waveOutGetDevCapsW?$AA@		; `string'
PUBLIC	??_C@_0BF@CJGF@waveOutGetErrorTextA?$AA@	; `string'
PUBLIC	??_C@_0BF@HPGH@waveOutGetErrorTextW?$AA@	; `string'
PUBLIC	??_C@_0N@CDHF@waveOutGetID?$AA@			; `string'
PUBLIC	??_C@_0BC@DLCI@waveOutGetNumDevs?$AA@		; `string'
PUBLIC	??_C@_0BA@BMAE@waveOutGetPitch?$AA@		; `string'
PUBLIC	??_C@_0BH@PGGC@waveOutGetPlaybackRate?$AA@	; `string'
PUBLIC	??_C@_0BD@OHBO@waveOutGetPosition?$AA@		; `string'
PUBLIC	??_C@_0BB@ICEE@waveOutGetVolume?$AA@		; `string'
PUBLIC	??_C@_0P@CODB@waveOutMessage?$AA@		; `string'
PUBLIC	??_C@_0M@IDAC@waveOutOpen?$AA@			; `string'
PUBLIC	??_C@_0N@FJAJ@waveOutPause?$AA@			; `string'
PUBLIC	??_C@_0BF@DBPE@waveOutPrepareHeader?$AA@	; `string'
PUBLIC	??_C@_0N@HOMN@waveOutReset?$AA@			; `string'
PUBLIC	??_C@_0P@KFNO@waveOutRestart?$AA@		; `string'
PUBLIC	??_C@_0BA@LOFH@waveOutSetPitch?$AA@		; `string'
PUBLIC	??_C@_0BH@NGOG@waveOutSetPlaybackRate?$AA@	; `string'
PUBLIC	??_C@_0BB@KPOG@waveOutSetVolume?$AA@		; `string'
PUBLIC	??_C@_0BH@DHFI@waveOutUnprepareHeader?$AA@	; `string'
PUBLIC	??_C@_0N@JLPE@waveOutWrite?$AA@			; `string'
PUBLIC	??_C@_0N@FCAC@wid32Message?$AA@			; `string'
PUBLIC	??_C@_0M@LDOC@winmmDbgOut?$AA@			; `string'
PUBLIC	??_C@_0BD@GICE@winmmSetDebugLevel?$AA@		; `string'
PUBLIC	??_C@_0N@CNCC@wod32Message?$AA@			; `string'
PUBLIC	??_C@_09OCCL@gfxAddGfx?$AA@			; `string'
PUBLIC	??_C@_0P@BJBG@gfxBatchChange?$AA@		; `string'
PUBLIC	??_C@_0BJ@EBCG@gfxCreateGfxFactoriesLis?$AA@	; `string'
PUBLIC	??_C@_0BL@FFCF@gfxCreateZoneFactoriesList?$AA@	; `string'
PUBLIC	??_C@_0BO@GJGP@gfxDestroyDeviceInterfaceList?$AA@ ; `string'
PUBLIC	??_C@_0BB@LMEH@gfxEnumerateGfxs?$AA@		; `string'
PUBLIC	??_C@_0N@MLFB@_gfxLogoff?$EA0?$AA@		; `string'
PUBLIC	??_C@_0M@HNL@_gfxLogon?$EA4?$AA@		; `string'
PUBLIC	??_C@_0N@EEEC@gfxModifyGfx?$AA@			; `string'
PUBLIC	??_C@_0L@LNDM@gfxOpenGfx?$AA@			; `string'
PUBLIC	??_C@_0N@CDAE@gfxRemoveGfx?$AA@			; `string'
PUBLIC	??_C@_0BA@BJCD@waveInAddBuffer?$AA@		; `string'
PUBLIC	??_C@_0M@DHME@waveInClose?$AA@			; `string'
PUBLIC	??_C@_0L@MJA@waveInOpen?$AA@			; `string'
PUBLIC	??_C@_0BE@JLAM@waveInPrepareHeader?$AA@		; `string'
PUBLIC	??_C@_0M@CDKP@waveInStart?$AA@			; `string'
PUBLIC	??_C@_0L@DEII@waveInStop?$AA@			; `string'
PUBLIC	??_C@_0BG@MDKC@waveInUnprepareHeader?$AA@	; `string'
PUBLIC	??_C@_0M@JMBN@joyGetPosEx?$AA@			; `string'
;	COMDAT ??_C@_0M@FGGD@CloseDriver?$AA@
; File C:\Code\SmartPropoPlus\330\Winmm\winmm.c
_DATA	SEGMENT
??_C@_0M@FGGD@CloseDriver?$AA@ DB 'CloseDriver', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@PEDJ@DefDriverProc?$AA@
_DATA	SEGMENT
??_C@_0O@PEDJ@DefDriverProc?$AA@ DB 'DefDriverProc', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@GMDJ@DriverCallback?$AA@
_DATA	SEGMENT
??_C@_0P@GMDJ@DriverCallback?$AA@ DB 'DriverCallback', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@JLHO@DrvGetModuleHandle?$AA@
_DATA	SEGMENT
??_C@_0BD@JLHO@DrvGetModuleHandle?$AA@ DB 'DrvGetModuleHandle', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@EEHB@GetDriverModuleHandle?$AA@
_DATA	SEGMENT
??_C@_0BG@EEHB@GetDriverModuleHandle?$AA@ DB 'GetDriverModuleHandle', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@MFHB@MigrateAllDrivers?$AA@
_DATA	SEGMENT
??_C@_0BC@MFHB@MigrateAllDrivers?$AA@ DB 'MigrateAllDrivers', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KFIL@MigrateSoundEvents?$AA@
_DATA	SEGMENT
??_C@_0BD@KFIL@MigrateSoundEvents?$AA@ DB 'MigrateSoundEvents', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IALO@NotifyCallbackData?$AA@
_DATA	SEGMENT
??_C@_0BD@IALO@NotifyCallbackData?$AA@ DB 'NotifyCallbackData', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@OOCK@OpenDriver?$AA@
_DATA	SEGMENT
??_C@_0L@OOCK@OpenDriver?$AA@ DB 'OpenDriver', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09OHCJ@PlaySound?$AA@
_DATA	SEGMENT
??_C@_09OHCJ@PlaySound?$AA@ DB 'PlaySound', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@CELA@PlaySoundA?$AA@
_DATA	SEGMENT
??_C@_0L@CELA@PlaySoundA?$AA@ DB 'PlaySoundA', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@HCLC@PlaySoundW?$AA@
_DATA	SEGMENT
??_C@_0L@HCLC@PlaySoundW?$AA@ DB 'PlaySoundW', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@EGH@SendDriverMessage?$AA@
_DATA	SEGMENT
??_C@_0BC@EGH@SendDriverMessage?$AA@ DB 'SendDriverMessage', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HCOI@WOW32DriverCallback?$AA@
_DATA	SEGMENT
??_C@_0BE@HCOI@WOW32DriverCallback?$AA@ DB 'WOW32DriverCallback', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@CCM@WOW32ResolveMultiMediaHandle?$AA@
_DATA	SEGMENT
??_C@_0BN@CCM@WOW32ResolveMultiMediaHandle?$AA@ DB 'WOW32ResolveMultiMedi'
	DB	'aHandle', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@KFKN@WOWAppExit?$AA@
_DATA	SEGMENT
??_C@_0L@KFKN@WOWAppExit?$AA@ DB 'WOWAppExit', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@IBFM@WinmmLogoff?$AA@
_DATA	SEGMENT
??_C@_0M@IBFM@WinmmLogoff?$AA@ DB 'WinmmLogoff', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@FKIE@WinmmLogon?$AA@
_DATA	SEGMENT
??_C@_0L@FKIE@WinmmLogon?$AA@ DB 'WinmmLogon', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@LFH@aux32Message?$AA@
_DATA	SEGMENT
??_C@_0N@LFH@aux32Message?$AA@ DB 'aux32Message', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@CIL@auxGetDevCapsA?$AA@
_DATA	SEGMENT
??_C@_0P@CIL@auxGetDevCapsA?$AA@ DB 'auxGetDevCapsA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@FEIJ@auxGetDevCapsW?$AA@
_DATA	SEGMENT
??_C@_0P@FEIJ@auxGetDevCapsW?$AA@ DB 'auxGetDevCapsW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@IJOA@auxGetNumDevs?$AA@
_DATA	SEGMENT
??_C@_0O@IJOA@auxGetNumDevs?$AA@ DB 'auxGetNumDevs', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@EKJK@auxGetVolume?$AA@
_DATA	SEGMENT
??_C@_0N@EKJK@auxGetVolume?$AA@ DB 'auxGetVolume', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@FOOK@auxOutMessage?$AA@
_DATA	SEGMENT
??_C@_0O@FOOK@auxOutMessage?$AA@ DB 'auxOutMessage', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@GHDI@auxSetVolume?$AA@
_DATA	SEGMENT
??_C@_0N@GHDI@auxSetVolume?$AA@ DB 'auxSetVolume', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@HEGD@joy32Message?$AA@
_DATA	SEGMENT
??_C@_0N@HEGD@joy32Message?$AA@ DB 'joy32Message', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DMC@joyConfigChanged?$AA@
_DATA	SEGMENT
??_C@_0BB@DMC@joyConfigChanged?$AA@ DB 'joyConfigChanged', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@LCHD@joyGetDevCapsA?$AA@
_DATA	SEGMENT
??_C@_0P@LCHD@joyGetDevCapsA?$AA@ DB 'joyGetDevCapsA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@OEHB@joyGetDevCapsW?$AA@
_DATA	SEGMENT
??_C@_0P@OEHB@joyGetDevCapsW?$AA@ DB 'joyGetDevCapsW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@HBJP@joyGetNumDevs?$AA@
_DATA	SEGMENT
??_C@_0O@HBJP@joyGetNumDevs?$AA@ DB 'joyGetNumDevs', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_09DPN@joyGetPos?$AA@
_DATA	SEGMENT
??_C@_09DPN@joyGetPos?$AA@ DB 'joyGetPos', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JKBD@joyGetThreshold?$AA@
_DATA	SEGMENT
??_C@_0BA@JKBD@joyGetThreshold?$AA@ DB 'joyGetThreshold', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@DMDH@joyReleaseCapture?$AA@
_DATA	SEGMENT
??_C@_0BC@DMDH@joyReleaseCapture?$AA@ DB 'joyReleaseCapture', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@KPDA@joySetCapture?$AA@
_DATA	SEGMENT
??_C@_0O@KPDA@joySetCapture?$AA@ DB 'joySetCapture', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@PDBB@joySetThreshold?$AA@
_DATA	SEGMENT
??_C@_0BA@PDBB@joySetThreshold?$AA@ DB 'joySetThreshold', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@HHJD@mci32Message?$AA@
_DATA	SEGMENT
??_C@_0N@HHJD@mci32Message?$AA@ DB 'mci32Message', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FIAF@mciDriverNotify?$AA@
_DATA	SEGMENT
??_C@_0BA@FIAF@mciDriverNotify?$AA@ DB 'mciDriverNotify', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@KNAD@mciDriverYield?$AA@
_DATA	SEGMENT
??_C@_0P@KNAD@mciDriverYield?$AA@ DB 'mciDriverYield', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@LOGF@mciExecute?$AA@
_DATA	SEGMENT
??_C@_0L@LOGF@mciExecute?$AA@ DB 'mciExecute', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@EHJF@mciFreeCommandResource?$AA@
_DATA	SEGMENT
??_C@_0BH@EHJF@mciFreeCommandResource?$AA@ DB 'mciFreeCommandResource', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@BBJL@mciGetCreatorTask?$AA@
_DATA	SEGMENT
??_C@_0BC@BBJL@mciGetCreatorTask?$AA@ DB 'mciGetCreatorTask', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@KIH@mciGetDeviceIDA?$AA@
_DATA	SEGMENT
??_C@_0BA@KIH@mciGetDeviceIDA?$AA@ DB 'mciGetDeviceIDA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@MCHF@mciGetDeviceIDFromElementIDA?$AA@
_DATA	SEGMENT
??_C@_0BN@MCHF@mciGetDeviceIDFromElementIDA?$AA@ DB 'mciGetDeviceIDFromEl'
	DB	'ementIDA', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@JEHH@mciGetDeviceIDFromElementIDW?$AA@
_DATA	SEGMENT
??_C@_0BN@JEHH@mciGetDeviceIDFromElementIDW?$AA@ DB 'mciGetDeviceIDFromEl'
	DB	'ementIDW', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FMIF@mciGetDeviceIDW?$AA@
_DATA	SEGMENT
??_C@_0BA@FMIF@mciGetDeviceIDW?$AA@ DB 'mciGetDeviceIDW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DLAL@mciGetDriverData?$AA@
_DATA	SEGMENT
??_C@_0BB@DLAL@mciGetDriverData?$AA@ DB 'mciGetDriverData', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IDBJ@mciGetErrorStringA?$AA@
_DATA	SEGMENT
??_C@_0BD@IDBJ@mciGetErrorStringA?$AA@ DB 'mciGetErrorStringA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@NFBL@mciGetErrorStringW?$AA@
_DATA	SEGMENT
??_C@_0BD@NFBL@mciGetErrorStringW?$AA@ DB 'mciGetErrorStringW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@LJKD@mciGetYieldProc?$AA@
_DATA	SEGMENT
??_C@_0BA@LJKD@mciGetYieldProc?$AA@ DB 'mciGetYieldProc', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IJD@mciLoadCommandResource?$AA@
_DATA	SEGMENT
??_C@_0BH@IJD@mciLoadCommandResource?$AA@ DB 'mciLoadCommandResource', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JKLO@mciSendCommandA?$AA@
_DATA	SEGMENT
??_C@_0BA@JKLO@mciSendCommandA?$AA@ DB 'mciSendCommandA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@MMLM@mciSendCommandW?$AA@
_DATA	SEGMENT
??_C@_0BA@MMLM@mciSendCommandW?$AA@ DB 'mciSendCommandW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@GAMF@mciSendStringA?$AA@
_DATA	SEGMENT
??_C@_0P@GAMF@mciSendStringA?$AA@ DB 'mciSendStringA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@DGMH@mciSendStringW?$AA@
_DATA	SEGMENT
??_C@_0P@DGMH@mciSendStringW?$AA@ DB 'mciSendStringW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@GIGC@mciSetDriverData?$AA@
_DATA	SEGMENT
??_C@_0BB@GIGC@mciSetDriverData?$AA@ DB 'mciSetDriverData', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@NAKB@mciSetYieldProc?$AA@
_DATA	SEGMENT
??_C@_0BA@NAKB@mciSetYieldProc?$AA@ DB 'mciSetYieldProc', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@DICL@mid32Message?$AA@
_DATA	SEGMENT
??_C@_0N@DICL@mid32Message?$AA@ DB 'mid32Message', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@CPPD@midiConnect?$AA@
_DATA	SEGMENT
??_C@_0M@CPPD@midiConnect?$AA@ DB 'midiConnect', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@KHF@midiDisconnect?$AA@
_DATA	SEGMENT
??_C@_0P@KHF@midiDisconnect?$AA@ DB 'midiDisconnect', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@MNBE@midiInAddBuffer?$AA@
_DATA	SEGMENT
??_C@_0BA@MNBE@midiInAddBuffer?$AA@ DB 'midiInAddBuffer', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@KBJH@midiInClose?$AA@
_DATA	SEGMENT
??_C@_0M@KBJH@midiInClose?$AA@ DB 'midiInClose', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@NPDI@midiInGetDevCapsA?$AA@
_DATA	SEGMENT
??_C@_0BC@NPDI@midiInGetDevCapsA?$AA@ DB 'midiInGetDevCapsA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@IJDK@midiInGetDevCapsW?$AA@
_DATA	SEGMENT
??_C@_0BC@IJDK@midiInGetDevCapsW?$AA@ DB 'midiInGetDevCapsW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@OCKH@midiInGetErrorTextA?$AA@
_DATA	SEGMENT
??_C@_0BE@OCKH@midiInGetErrorTextA?$AA@ DB 'midiInGetErrorTextA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@LEKF@midiInGetErrorTextW?$AA@
_DATA	SEGMENT
??_C@_0BE@LEKF@midiInGetErrorTextW?$AA@ DB 'midiInGetErrorTextW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@LGKJ@midiInGetID?$AA@
_DATA	SEGMENT
??_C@_0M@LGKJ@midiInGetID?$AA@ DB 'midiInGetID', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DKPK@midiInGetNumDevs?$AA@
_DATA	SEGMENT
??_C@_0BB@DKPK@midiInGetNumDevs?$AA@ DB 'midiInGetNumDevs', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@DNDL@midiInMessage?$AA@
_DATA	SEGMENT
??_C@_0O@DNDL@midiInMessage?$AA@ DB 'midiInMessage', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@FPCM@midiInOpen?$AA@
_DATA	SEGMENT
??_C@_0L@FPCM@midiInOpen?$AA@ DB 'midiInOpen', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@PKDG@midiInPrepareHeader?$AA@
_DATA	SEGMENT
??_C@_0BE@PKDG@midiInPrepareHeader?$AA@ DB 'midiInPrepareHeader', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@OLBB@midiInReset?$AA@
_DATA	SEGMENT
??_C@_0M@OLBB@midiInReset?$AA@ DB 'midiInReset', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@LFPM@midiInStart?$AA@
_DATA	SEGMENT
??_C@_0M@LFPM@midiInStart?$AA@ DB 'midiInStart', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GHDE@midiInStop?$AA@
_DATA	SEGMENT
??_C@_0L@GHDE@midiInStop?$AA@ DB 'midiInStop', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@JPPA@midiInUnprepareHeader?$AA@
_DATA	SEGMENT
??_C@_0BG@JPPA@midiInUnprepareHeader?$AA@ DB 'midiInUnprepareHeader', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@NAJB@midiOutCacheDrumPatches?$AA@
_DATA	SEGMENT
??_C@_0BI@NAJB@midiOutCacheDrumPatches?$AA@ DB 'midiOutCacheDrumPatches', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CBNA@midiOutCachePatches?$AA@
_DATA	SEGMENT
??_C@_0BE@CBNA@midiOutCachePatches?$AA@ DB 'midiOutCachePatches', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@PCNN@midiOutClose?$AA@
_DATA	SEGMENT
??_C@_0N@PCNN@midiOutClose?$AA@ DB 'midiOutClose', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@BA@midiOutGetDevCapsA?$AA@
_DATA	SEGMENT
??_C@_0BD@BA@midiOutGetDevCapsA?$AA@ DB 'midiOutGetDevCapsA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@FGBC@midiOutGetDevCapsW?$AA@
_DATA	SEGMENT
??_C@_0BD@FGBC@midiOutGetDevCapsW?$AA@ DB 'midiOutGetDevCapsW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@HLAE@midiOutGetErrorTextA?$AA@
_DATA	SEGMENT
??_C@_0BF@HLAE@midiOutGetErrorTextA?$AA@ DB 'midiOutGetErrorTextA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@CNAG@midiOutGetErrorTextW?$AA@
_DATA	SEGMENT
??_C@_0BF@CNAG@midiOutGetErrorTextW?$AA@ DB 'midiOutGetErrorTextW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@OFOD@midiOutGetID?$AA@
_DATA	SEGMENT
??_C@_0N@OFOD@midiOutGetID?$AA@ DB 'midiOutGetID', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@BCOH@midiOutGetNumDevs?$AA@
_DATA	SEGMENT
??_C@_0BC@BCOH@midiOutGetNumDevs?$AA@ DB 'midiOutGetNumDevs', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@ENJA@midiOutGetVolume?$AA@
_DATA	SEGMENT
??_C@_0BB@ENJA@midiOutGetVolume?$AA@ DB 'midiOutGetVolume', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@KNDI@midiOutLongMsg?$AA@
_DATA	SEGMENT
??_C@_0P@KNDI@midiOutLongMsg?$AA@ DB 'midiOutLongMsg', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@BJFN@midiOutMessage?$AA@
_DATA	SEGMENT
??_C@_0P@BJFN@midiOutMessage?$AA@ DB 'midiOutMessage', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@BFFB@midiOutOpen?$AA@
_DATA	SEGMENT
??_C@_0M@BFFB@midiOutOpen?$AA@ DB 'midiOutOpen', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@GDJF@midiOutPrepareHeader?$AA@
_DATA	SEGMENT
??_C@_0BF@GDJF@midiOutPrepareHeader?$AA@ DB 'midiOutPrepareHeader', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@LIFL@midiOutReset?$AA@
_DATA	SEGMENT
??_C@_0N@LIFL@midiOutReset?$AA@ DB 'midiOutReset', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@GADC@midiOutSetVolume?$AA@
_DATA	SEGMENT
??_C@_0BB@GADC@midiOutSetVolume?$AA@ DB 'midiOutSetVolume', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@ICEO@midiOutShortMsg?$AA@
_DATA	SEGMENT
??_C@_0BA@ICEO@midiOutShortMsg?$AA@ DB 'midiOutShortMsg', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@MNAE@midiOutUnprepareHeader?$AA@
_DATA	SEGMENT
??_C@_0BH@MNAE@midiOutUnprepareHeader?$AA@ DB 'midiOutUnprepareHeader', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@PKJI@midiStreamClose?$AA@
_DATA	SEGMENT
??_C@_0BA@PKJI@midiStreamClose?$AA@ DB 'midiStreamClose', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@FAGH@midiStreamOpen?$AA@
_DATA	SEGMENT
??_C@_0P@FAGH@midiStreamOpen?$AA@ DB 'midiStreamOpen', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@MCEN@midiStreamOut?$AA@
_DATA	SEGMENT
??_C@_0O@MCEN@midiStreamOut?$AA@ DB 'midiStreamOut', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JHNK@midiStreamPause?$AA@
_DATA	SEGMENT
??_C@_0BA@JHNK@midiStreamPause?$AA@ DB 'midiStreamPause', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@CJJI@midiStreamPosition?$AA@
_DATA	SEGMENT
??_C@_0BD@CJJI@midiStreamPosition?$AA@ DB 'midiStreamPosition', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@NHF@midiStreamProperty?$AA@
_DATA	SEGMENT
??_C@_0BD@NHF@midiStreamProperty?$AA@ DB 'midiStreamProperty', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LLAA@midiStreamRestart?$AA@
_DATA	SEGMENT
??_C@_0BC@LLAA@midiStreamRestart?$AA@ DB 'midiStreamRestart', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@GIHP@midiStreamStop?$AA@
_DATA	SEGMENT
??_C@_0P@GIHP@midiStreamStop?$AA@ DB 'midiStreamStop', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@NGHK@mixerClose?$AA@
_DATA	SEGMENT
??_C@_0L@NGHK@mixerClose?$AA@ DB 'mixerClose', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@KKIG@mixerGetControlDetailsA?$AA@
_DATA	SEGMENT
??_C@_0BI@KKIG@mixerGetControlDetailsA?$AA@ DB 'mixerGetControlDetailsA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@PMIE@mixerGetControlDetailsW?$AA@
_DATA	SEGMENT
??_C@_0BI@PMIE@mixerGetControlDetailsW?$AA@ DB 'mixerGetControlDetailsW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MMIF@mixerGetDevCapsA?$AA@
_DATA	SEGMENT
??_C@_0BB@MMIF@mixerGetDevCapsA?$AA@ DB 'mixerGetDevCapsA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@JKIH@mixerGetDevCapsW?$AA@
_DATA	SEGMENT
??_C@_0BB@JKIH@mixerGetDevCapsW?$AA@ DB 'mixerGetDevCapsW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@MBEE@mixerGetID?$AA@
_DATA	SEGMENT
??_C@_0L@MBEE@mixerGetID?$AA@ DB 'mixerGetID', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@GELF@mixerGetLineControlsA?$AA@
_DATA	SEGMENT
??_C@_0BG@GELF@mixerGetLineControlsA?$AA@ DB 'mixerGetLineControlsA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@DCLH@mixerGetLineControlsW?$AA@
_DATA	SEGMENT
??_C@_0BG@DCLH@mixerGetLineControlsW?$AA@ DB 'mixerGetLineControlsW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@LCF@mixerGetLineInfoA?$AA@
_DATA	SEGMENT
??_C@_0BC@LCF@mixerGetLineInfoA?$AA@ DB 'mixerGetLineInfoA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@FNCH@mixerGetLineInfoW?$AA@
_DATA	SEGMENT
??_C@_0BC@FNCH@mixerGetLineInfoW?$AA@ DB 'mixerGetLineInfoW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@IHGE@mixerGetNumDevs?$AA@
_DATA	SEGMENT
??_C@_0BA@IHGE@mixerGetNumDevs?$AA@ DB 'mixerGetNumDevs', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@LFII@mixerMessage?$AA@
_DATA	SEGMENT
??_C@_0N@LFII@mixerMessage?$AA@ DB 'mixerMessage', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09LCEO@mixerOpen?$AA@
_DATA	SEGMENT
??_C@_09LCEO@mixerOpen?$AA@ DB 'mixerOpen', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@EDCE@mixerSetControlDetails?$AA@
_DATA	SEGMENT
??_C@_0BH@EDCE@mixerSetControlDetails?$AA@ DB 'mixerSetControlDetails', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@DCIM@mmDrvInstall?$AA@
_DATA	SEGMENT
??_C@_0N@DCIM@mmDrvInstall?$AA@ DB 'mmDrvInstall', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@NEHP@mmGetCurrentTask?$AA@
_DATA	SEGMENT
??_C@_0BB@NEHP@mmGetCurrentTask?$AA@ DB 'mmGetCurrentTask', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@CGD@mmTaskBlock?$AA@
_DATA	SEGMENT
??_C@_0M@CGD@mmTaskBlock?$AA@ DB 'mmTaskBlock', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@GAFI@mmTaskCreate?$AA@
_DATA	SEGMENT
??_C@_0N@GAFI@mmTaskCreate?$AA@ DB 'mmTaskCreate', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@GFLM@mmTaskSignal?$AA@
_DATA	SEGMENT
??_C@_0N@GFLM@mmTaskSignal?$AA@ DB 'mmTaskSignal', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@LAKN@mmTaskYield?$AA@
_DATA	SEGMENT
??_C@_0M@LAKN@mmTaskYield?$AA@ DB 'mmTaskYield', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@IBMG@mmioAdvance?$AA@
_DATA	SEGMENT
??_C@_0M@IBMG@mmioAdvance?$AA@ DB 'mmioAdvance', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@LHNO@mmioAscend?$AA@
_DATA	SEGMENT
??_C@_0L@LHNO@mmioAscend?$AA@ DB 'mmioAscend', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JPN@mmioClose?$AA@
_DATA	SEGMENT
??_C@_09JPN@mmioClose?$AA@ DB 'mmioClose', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CDLD@mmioCreateChunk?$AA@
_DATA	SEGMENT
??_C@_0BA@CDLD@mmioCreateChunk?$AA@ DB 'mmioCreateChunk', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@NPPM@mmioDescend?$AA@
_DATA	SEGMENT
??_C@_0M@NPPM@mmioDescend?$AA@ DB 'mmioDescend', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GIMM@mmioFlush?$AA@
_DATA	SEGMENT
??_C@_09GIMM@mmioFlush?$AA@ DB 'mmioFlush', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@HOBF@mmioGetInfo?$AA@
_DATA	SEGMENT
??_C@_0M@HOBF@mmioGetInfo?$AA@ DB 'mmioGetInfo', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KFBE@mmioInstallIOProcA?$AA@
_DATA	SEGMENT
??_C@_0BD@KFBE@mmioInstallIOProcA?$AA@ DB 'mmioInstallIOProcA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@PDBG@mmioInstallIOProcW?$AA@
_DATA	SEGMENT
??_C@_0BD@PDBG@mmioInstallIOProcW?$AA@ DB 'mmioInstallIOProcW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_09DNGC@mmioOpenA?$AA@
_DATA	SEGMENT
??_C@_09DNGC@mmioOpenA?$AA@ DB 'mmioOpenA', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GLGA@mmioOpenW?$AA@
_DATA	SEGMENT
??_C@_09GLGA@mmioOpenW?$AA@ DB 'mmioOpenW', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08JKLF@mmioRead?$AA@
_DATA	SEGMENT
??_C@_08JKLF@mmioRead?$AA@ DB 'mmioRead', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@PEIF@mmioRenameA?$AA@
_DATA	SEGMENT
??_C@_0M@PEIF@mmioRenameA?$AA@ DB 'mmioRenameA', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@KCIH@mmioRenameW?$AA@
_DATA	SEGMENT
??_C@_0M@KCIH@mmioRenameW?$AA@ DB 'mmioRenameW', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08OEBA@mmioSeek?$AA@
_DATA	SEGMENT
??_C@_08OEBA@mmioSeek?$AA@ DB 'mmioSeek', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@PCED@mmioSendMessage?$AA@
_DATA	SEGMENT
??_C@_0BA@PCED@mmioSendMessage?$AA@ DB 'mmioSendMessage', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@OCHB@mmioSetBuffer?$AA@
_DATA	SEGMENT
??_C@_0O@OCHB@mmioSetBuffer?$AA@ DB 'mmioSetBuffer', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@CNBJ@mmioSetInfo?$AA@
_DATA	SEGMENT
??_C@_0M@CNBJ@mmioSetInfo?$AA@ DB 'mmioSetInfo', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CJEP@mmioStringToFOURCCA?$AA@
_DATA	SEGMENT
??_C@_0BE@CJEP@mmioStringToFOURCCA?$AA@ DB 'mmioStringToFOURCCA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HPEN@mmioStringToFOURCCW?$AA@
_DATA	SEGMENT
??_C@_0BE@HPEN@mmioStringToFOURCCW?$AA@ DB 'mmioStringToFOURCCW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_09KGEC@mmioWrite?$AA@
_DATA	SEGMENT
??_C@_09KGEC@mmioWrite?$AA@ DB 'mmioWrite', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@BLEE@mmsystemGetVersion?$AA@
_DATA	SEGMENT
??_C@_0BD@BLEE@mmsystemGetVersion?$AA@ DB 'mmsystemGetVersion', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@EHAL@mod32Message?$AA@
_DATA	SEGMENT
??_C@_0N@EHAL@mod32Message?$AA@ DB 'mod32Message', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@HKFI@mxd32Message?$AA@
_DATA	SEGMENT
??_C@_0N@HKFI@mxd32Message?$AA@ DB 'mxd32Message', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@CLPB@sndPlaySoundA?$AA@
_DATA	SEGMENT
??_C@_0O@CLPB@sndPlaySoundA?$AA@ DB 'sndPlaySoundA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@HNPD@sndPlaySoundW?$AA@
_DATA	SEGMENT
??_C@_0O@HNPD@sndPlaySoundW?$AA@ DB 'sndPlaySoundW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@OEDN@tid32Message?$AA@
_DATA	SEGMENT
??_C@_0N@OEDN@tid32Message?$AA@ DB 'tid32Message', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CAIP@timeBeginPeriod?$AA@
_DATA	SEGMENT
??_C@_0BA@CAIP@timeBeginPeriod?$AA@ DB 'timeBeginPeriod', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@NIGI@timeEndPeriod?$AA@
_DATA	SEGMENT
??_C@_0O@NIGI@timeEndPeriod?$AA@ DB 'timeEndPeriod', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@MAOL@timeGetDevCaps?$AA@
_DATA	SEGMENT
??_C@_0P@MAOL@timeGetDevCaps?$AA@ DB 'timeGetDevCaps', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@HHNM@timeGetSystemTime?$AA@
_DATA	SEGMENT
??_C@_0BC@HHNM@timeGetSystemTime?$AA@ DB 'timeGetSystemTime', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@HBOP@timeGetTime?$AA@
_DATA	SEGMENT
??_C@_0M@HBOP@timeGetTime?$AA@ DB 'timeGetTime', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@CIKN@timeKillEvent?$AA@
_DATA	SEGMENT
??_C@_0O@CIKN@timeKillEvent?$AA@ DB 'timeKillEvent', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@JPEP@timeSetEvent?$AA@
_DATA	SEGMENT
??_C@_0N@JPEP@timeSetEvent?$AA@ DB 'timeSetEvent', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@PGPH@waveInGetDevCapsA?$AA@
_DATA	SEGMENT
??_C@_0BC@PGPH@waveInGetDevCapsA?$AA@ DB 'waveInGetDevCapsA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KAPF@waveInGetDevCapsW?$AA@
_DATA	SEGMENT
??_C@_0BC@KAPF@waveInGetDevCapsW?$AA@ DB 'waveInGetDevCapsW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IDJN@waveInGetErrorTextA?$AA@
_DATA	SEGMENT
??_C@_0BE@IDJN@waveInGetErrorTextA?$AA@ DB 'waveInGetErrorTextA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@NFJP@waveInGetErrorTextW?$AA@
_DATA	SEGMENT
??_C@_0BE@NFJP@waveInGetErrorTextW?$AA@ DB 'waveInGetErrorTextW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@CAPK@waveInGetID?$AA@
_DATA	SEGMENT
??_C@_0M@CAPK@waveInGetID?$AA@ DB 'waveInGetID', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@PFCO@waveInGetNumDevs?$AA@
_DATA	SEGMENT
??_C@_0BB@PFCO@waveInGetNumDevs?$AA@ DB 'waveInGetNumDevs', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@CLNA@waveInGetPosition?$AA@
_DATA	SEGMENT
??_C@_0BC@CLNA@waveInGetPosition?$AA@ DB 'waveInGetPosition', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@FBPN@waveInMessage?$AA@
_DATA	SEGMENT
??_C@_0O@FBPN@waveInMessage?$AA@ DB 'waveInMessage', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@HNEC@waveInReset?$AA@
_DATA	SEGMENT
??_C@_0M@HNEC@waveInReset?$AA@ DB 'waveInReset', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@EJGO@waveOutBreakLoop?$AA@
_DATA	SEGMENT
??_C@_0BB@EJGO@waveOutBreakLoop?$AA@ DB 'waveOutBreakLoop', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@DEEL@waveOutClose?$AA@
_DATA	SEGMENT
??_C@_0N@DEEL@waveOutClose?$AA@ DB 'waveOutClose', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DKDJ@waveOutGetDevCapsA?$AA@
_DATA	SEGMENT
??_C@_0BD@DKDJ@waveOutGetDevCapsA?$AA@ DB 'waveOutGetDevCapsA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GMDL@waveOutGetDevCapsW?$AA@
_DATA	SEGMENT
??_C@_0BD@GMDL@waveOutGetDevCapsW?$AA@ DB 'waveOutGetDevCapsW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@CJGF@waveOutGetErrorTextA?$AA@
_DATA	SEGMENT
??_C@_0BF@CJGF@waveOutGetErrorTextA?$AA@ DB 'waveOutGetErrorTextA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@HPGH@waveOutGetErrorTextW?$AA@
_DATA	SEGMENT
??_C@_0BF@HPGH@waveOutGetErrorTextW?$AA@ DB 'waveOutGetErrorTextW', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@CDHF@waveOutGetID?$AA@
_DATA	SEGMENT
??_C@_0N@CDHF@waveOutGetID?$AA@ DB 'waveOutGetID', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@DLCI@waveOutGetNumDevs?$AA@
_DATA	SEGMENT
??_C@_0BC@DLCI@waveOutGetNumDevs?$AA@ DB 'waveOutGetNumDevs', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@BMAE@waveOutGetPitch?$AA@
_DATA	SEGMENT
??_C@_0BA@BMAE@waveOutGetPitch?$AA@ DB 'waveOutGetPitch', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@PGGC@waveOutGetPlaybackRate?$AA@
_DATA	SEGMENT
??_C@_0BH@PGGC@waveOutGetPlaybackRate?$AA@ DB 'waveOutGetPlaybackRate', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@OHBO@waveOutGetPosition?$AA@
_DATA	SEGMENT
??_C@_0BD@OHBO@waveOutGetPosition?$AA@ DB 'waveOutGetPosition', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@ICEE@waveOutGetVolume?$AA@
_DATA	SEGMENT
??_C@_0BB@ICEE@waveOutGetVolume?$AA@ DB 'waveOutGetVolume', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@CODB@waveOutMessage?$AA@
_DATA	SEGMENT
??_C@_0P@CODB@waveOutMessage?$AA@ DB 'waveOutMessage', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@IDAC@waveOutOpen?$AA@
_DATA	SEGMENT
??_C@_0M@IDAC@waveOutOpen?$AA@ DB 'waveOutOpen', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@FJAJ@waveOutPause?$AA@
_DATA	SEGMENT
??_C@_0N@FJAJ@waveOutPause?$AA@ DB 'waveOutPause', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@DBPE@waveOutPrepareHeader?$AA@
_DATA	SEGMENT
??_C@_0BF@DBPE@waveOutPrepareHeader?$AA@ DB 'waveOutPrepareHeader', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@HOMN@waveOutReset?$AA@
_DATA	SEGMENT
??_C@_0N@HOMN@waveOutReset?$AA@ DB 'waveOutReset', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@KFNO@waveOutRestart?$AA@
_DATA	SEGMENT
??_C@_0P@KFNO@waveOutRestart?$AA@ DB 'waveOutRestart', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@LOFH@waveOutSetPitch?$AA@
_DATA	SEGMENT
??_C@_0BA@LOFH@waveOutSetPitch?$AA@ DB 'waveOutSetPitch', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NGOG@waveOutSetPlaybackRate?$AA@
_DATA	SEGMENT
??_C@_0BH@NGOG@waveOutSetPlaybackRate?$AA@ DB 'waveOutSetPlaybackRate', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@KPOG@waveOutSetVolume?$AA@
_DATA	SEGMENT
??_C@_0BB@KPOG@waveOutSetVolume?$AA@ DB 'waveOutSetVolume', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@DHFI@waveOutUnprepareHeader?$AA@
_DATA	SEGMENT
??_C@_0BH@DHFI@waveOutUnprepareHeader?$AA@ DB 'waveOutUnprepareHeader', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@JLPE@waveOutWrite?$AA@
_DATA	SEGMENT
??_C@_0N@JLPE@waveOutWrite?$AA@ DB 'waveOutWrite', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@FCAC@wid32Message?$AA@
_DATA	SEGMENT
??_C@_0N@FCAC@wid32Message?$AA@ DB 'wid32Message', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@LDOC@winmmDbgOut?$AA@
_DATA	SEGMENT
??_C@_0M@LDOC@winmmDbgOut?$AA@ DB 'winmmDbgOut', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GICE@winmmSetDebugLevel?$AA@
_DATA	SEGMENT
??_C@_0BD@GICE@winmmSetDebugLevel?$AA@ DB 'winmmSetDebugLevel', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@CNCC@wod32Message?$AA@
_DATA	SEGMENT
??_C@_0N@CNCC@wod32Message?$AA@ DB 'wod32Message', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09OCCL@gfxAddGfx?$AA@
_DATA	SEGMENT
??_C@_09OCCL@gfxAddGfx?$AA@ DB 'gfxAddGfx', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@BJBG@gfxBatchChange?$AA@
_DATA	SEGMENT
??_C@_0P@BJBG@gfxBatchChange?$AA@ DB 'gfxBatchChange', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@EBCG@gfxCreateGfxFactoriesLis?$AA@
_DATA	SEGMENT
??_C@_0BJ@EBCG@gfxCreateGfxFactoriesLis?$AA@ DB 'gfxCreateGfxFactoriesLis'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@FFCF@gfxCreateZoneFactoriesList?$AA@
_DATA	SEGMENT
??_C@_0BL@FFCF@gfxCreateZoneFactoriesList?$AA@ DB 'gfxCreateZoneFactories'
	DB	'List', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@GJGP@gfxDestroyDeviceInterfaceList?$AA@
_DATA	SEGMENT
??_C@_0BO@GJGP@gfxDestroyDeviceInterfaceList?$AA@ DB 'gfxDestroyDeviceInt'
	DB	'erfaceList', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LMEH@gfxEnumerateGfxs?$AA@
_DATA	SEGMENT
??_C@_0BB@LMEH@gfxEnumerateGfxs?$AA@ DB 'gfxEnumerateGfxs', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@MLFB@_gfxLogoff?$EA0?$AA@
_DATA	SEGMENT
??_C@_0N@MLFB@_gfxLogoff?$EA0?$AA@ DB '_gfxLogoff@0', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@HNL@_gfxLogon?$EA4?$AA@
_DATA	SEGMENT
??_C@_0M@HNL@_gfxLogon?$EA4?$AA@ DB '_gfxLogon@4', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@EEEC@gfxModifyGfx?$AA@
_DATA	SEGMENT
??_C@_0N@EEEC@gfxModifyGfx?$AA@ DB 'gfxModifyGfx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@LNDM@gfxOpenGfx?$AA@
_DATA	SEGMENT
??_C@_0L@LNDM@gfxOpenGfx?$AA@ DB 'gfxOpenGfx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@CDAE@gfxRemoveGfx?$AA@
_DATA	SEGMENT
??_C@_0N@CDAE@gfxRemoveGfx?$AA@ DB 'gfxRemoveGfx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@BJCD@waveInAddBuffer?$AA@
_DATA	SEGMENT
??_C@_0BA@BJCD@waveInAddBuffer?$AA@ DB 'waveInAddBuffer', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@DHME@waveInClose?$AA@
_DATA	SEGMENT
??_C@_0M@DHME@waveInClose?$AA@ DB 'waveInClose', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@MJA@waveInOpen?$AA@
_DATA	SEGMENT
??_C@_0L@MJA@waveInOpen?$AA@ DB 'waveInOpen', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@JLAM@waveInPrepareHeader?$AA@
_DATA	SEGMENT
??_C@_0BE@JLAM@waveInPrepareHeader?$AA@ DB 'waveInPrepareHeader', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@CDKP@waveInStart?$AA@
_DATA	SEGMENT
??_C@_0M@CDKP@waveInStart?$AA@ DB 'waveInStart', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DEII@waveInStop?$AA@
_DATA	SEGMENT
??_C@_0L@DEII@waveInStop?$AA@ DB 'waveInStop', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@MDKC@waveInUnprepareHeader?$AA@
_DATA	SEGMENT
??_C@_0BG@MDKC@waveInUnprepareHeader?$AA@ DB 'waveInUnprepareHeader', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@JMBN@joyGetPosEx?$AA@
_DATA	SEGMENT
??_C@_0M@JMBN@joyGetPosEx?$AA@ DB 'joyGetPosEx', 00H	; `string'
_DATA	ENDS
;	COMDAT _GetPointerToOriginalFunc
_TEXT	SEGMENT
_GetPointerToOriginalFunc PROC NEAR			; COMDAT

; 1909 :     pCloseDriver = GetProcAddress(hWinmm, "CloseDriver");

	mov	eax, DWORD PTR _hWinmm
	push	esi
	mov	esi, DWORD PTR __imp__GetProcAddress@8
	push	OFFSET FLAT:??_C@_0M@FGGD@CloseDriver?$AA@ ; `string'
	push	eax
	call	esi

; 1910 :     pDefDriverProc = GetProcAddress(hWinmm, "DefDriverProc");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0O@PEDJ@DefDriverProc?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pCloseDriver, eax
	call	esi

; 1911 :     pDriverCallback = GetProcAddress(hWinmm, "DriverCallback");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@GMDJ@DriverCallback?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pDefDriverProc, eax
	call	esi
	mov	DWORD PTR _pDriverCallback, eax

; 1912 :     pDrvGetModuleHandle = GetProcAddress(hWinmm, "DrvGetModuleHandle");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@JLHO@DrvGetModuleHandle?$AA@ ; `string'
	push	eax
	call	esi

; 1913 :     pGetDriverModuleHandle = GetProcAddress(hWinmm, "GetDriverModuleHandle");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BG@EEHB@GetDriverModuleHandle?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pDrvGetModuleHandle, eax
	call	esi

; 1914 :     pMigrateAllDrivers = GetProcAddress(hWinmm, "MigrateAllDrivers");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@MFHB@MigrateAllDrivers?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pGetDriverModuleHandle, eax
	call	esi
	mov	DWORD PTR _pMigrateAllDrivers, eax

; 1915 : //    pMigrateMidiUser = GetProcAddress(hWinmm, "MigrateMidiUser");
; 1916 :     pMigrateSoundEvents = GetProcAddress(hWinmm, "MigrateSoundEvents");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@KFIL@MigrateSoundEvents?$AA@ ; `string'
	push	eax
	call	esi

; 1917 :     pNotifyCallbackData = GetProcAddress(hWinmm, "NotifyCallbackData");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@IALO@NotifyCallbackData?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pMigrateSoundEvents, eax
	call	esi

; 1918 :     pOpenDriver = GetProcAddress(hWinmm, "OpenDriver");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@OOCK@OpenDriver?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pNotifyCallbackData, eax
	call	esi
	mov	DWORD PTR _pOpenDriver, eax

; 1919 :     pPlaySound = GetProcAddress(hWinmm, "PlaySound");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_09OHCJ@PlaySound?$AA@	; `string'
	push	eax
	call	esi

; 1920 :     pPlaySoundA = GetProcAddress(hWinmm, "PlaySoundA");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@CELA@PlaySoundA?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pPlaySound, eax
	call	esi

; 1921 :     pPlaySoundW = GetProcAddress(hWinmm, "PlaySoundW");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@HCLC@PlaySoundW?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pPlaySoundA, eax
	call	esi
	mov	DWORD PTR _pPlaySoundW, eax

; 1922 :     pSendDriverMessage = GetProcAddress(hWinmm, "SendDriverMessage");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@EGH@SendDriverMessage?$AA@ ; `string'
	push	eax
	call	esi

; 1923 :     pWOW32DriverCallback = GetProcAddress(hWinmm, "WOW32DriverCallback");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BE@HCOI@WOW32DriverCallback?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pSendDriverMessage, eax
	call	esi

; 1924 :     pWOW32ResolveMultiMediaHandle = GetProcAddress(hWinmm, "WOW32ResolveMultiMediaHandle");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BN@CCM@WOW32ResolveMultiMediaHandle?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pWOW32DriverCallback, eax
	call	esi
	mov	DWORD PTR _pWOW32ResolveMultiMediaHandle, eax

; 1925 :     pWOWAppExit = GetProcAddress(hWinmm, "WOWAppExit");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@KFKN@WOWAppExit?$AA@ ; `string'
	push	eax
	call	esi

; 1926 :     pWinmmLogoff = GetProcAddress(hWinmm, "WinmmLogoff");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@IBFM@WinmmLogoff?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pWOWAppExit, eax
	call	esi

; 1927 :     pWinmmLogon = GetProcAddress(hWinmm, "WinmmLogon");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@FKIE@WinmmLogon?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pWinmmLogoff, eax
	call	esi
	mov	DWORD PTR _pWinmmLogon, eax

; 1928 :     paux32Message = GetProcAddress(hWinmm, "aux32Message");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@LFH@aux32Message?$AA@ ; `string'
	push	eax
	call	esi

; 1929 :     pauxGetDevCapsA = GetProcAddress(hWinmm, "auxGetDevCapsA");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@CIL@auxGetDevCapsA?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _paux32Message, eax
	call	esi

; 1930 :     pauxGetDevCapsW = GetProcAddress(hWinmm, "auxGetDevCapsW");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@FEIJ@auxGetDevCapsW?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pauxGetDevCapsA, eax
	call	esi
	mov	DWORD PTR _pauxGetDevCapsW, eax

; 1931 :     pauxGetNumDevs = GetProcAddress(hWinmm, "auxGetNumDevs");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0O@IJOA@auxGetNumDevs?$AA@ ; `string'
	push	eax
	call	esi

; 1932 :     pauxGetVolume = GetProcAddress(hWinmm, "auxGetVolume");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@EKJK@auxGetVolume?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pauxGetNumDevs, eax
	call	esi

; 1933 :     pauxOutMessage = GetProcAddress(hWinmm, "auxOutMessage");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0O@FOOK@auxOutMessage?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pauxGetVolume, eax
	call	esi
	mov	DWORD PTR _pauxOutMessage, eax

; 1934 :     pauxSetVolume = GetProcAddress(hWinmm, "auxSetVolume");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@GHDI@auxSetVolume?$AA@ ; `string'
	push	eax
	call	esi

; 1935 :     pjoy32Message = GetProcAddress(hWinmm, "joy32Message");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@HEGD@joy32Message?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pauxSetVolume, eax
	call	esi

; 1936 :     pjoyConfigChanged = GetProcAddress(hWinmm, "joyConfigChanged");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@DMC@joyConfigChanged?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pjoy32Message, eax
	call	esi
	mov	DWORD PTR _pjoyConfigChanged, eax

; 1937 :     pjoyGetDevCapsA = GetProcAddress(hWinmm, "joyGetDevCapsA");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@LCHD@joyGetDevCapsA?$AA@ ; `string'
	push	eax
	call	esi

; 1938 :     pjoyGetDevCapsW = GetProcAddress(hWinmm, "joyGetDevCapsW");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@OEHB@joyGetDevCapsW?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pjoyGetDevCapsA, eax
	call	esi

; 1939 :     pjoyGetNumDevs = GetProcAddress(hWinmm, "joyGetNumDevs");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0O@HBJP@joyGetNumDevs?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pjoyGetDevCapsW, eax
	call	esi
	mov	DWORD PTR _pjoyGetNumDevs, eax

; 1940 :     pjoyGetPos = GetProcAddress(hWinmm, "joyGetPos");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_09DPN@joyGetPos?$AA@	; `string'
	push	eax
	call	esi

; 1941 :     pjoyGetThreshold = GetProcAddress(hWinmm, "joyGetThreshold");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@JKBD@joyGetThreshold?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pjoyGetPos, eax
	call	esi
	mov	DWORD PTR _pjoyGetThreshold, eax

; 1942 :     pjoyReleaseCapture = GetProcAddress(hWinmm, "joyReleaseCapture");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@DMDH@joyReleaseCapture?$AA@ ; `string'
	push	edx
	call	esi
	mov	DWORD PTR _pjoyReleaseCapture, eax

; 1943 :     pjoySetCapture = GetProcAddress(hWinmm, "joySetCapture");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0O@KPDA@joySetCapture?$AA@ ; `string'
	push	eax
	call	esi

; 1944 :     pjoySetThreshold = GetProcAddress(hWinmm, "joySetThreshold");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@PDBB@joySetThreshold?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pjoySetCapture, eax
	call	esi

; 1945 :     pmci32Message = GetProcAddress(hWinmm, "mci32Message");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@HHJD@mci32Message?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pjoySetThreshold, eax
	call	esi
	mov	DWORD PTR _pmci32Message, eax

; 1946 :     pmciDriverNotify = GetProcAddress(hWinmm, "mciDriverNotify");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@FIAF@mciDriverNotify?$AA@ ; `string'
	push	eax
	call	esi

; 1947 :     pmciDriverYield = GetProcAddress(hWinmm, "mciDriverYield");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@KNAD@mciDriverYield?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmciDriverNotify, eax
	call	esi

; 1948 :     pmciExecute = GetProcAddress(hWinmm, "mciExecute");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@LOGF@mciExecute?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmciDriverYield, eax
	call	esi
	mov	DWORD PTR _pmciExecute, eax

; 1949 :     pmciFreeCommandResource = GetProcAddress(hWinmm, "mciFreeCommandResource");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BH@EHJF@mciFreeCommandResource?$AA@ ; `string'
	push	eax
	call	esi

; 1950 :     pmciGetCreatorTask = GetProcAddress(hWinmm, "mciGetCreatorTask");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@BBJL@mciGetCreatorTask?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmciFreeCommandResource, eax
	call	esi

; 1951 :     pmciGetDeviceIDA = GetProcAddress(hWinmm, "mciGetDeviceIDA");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@KIH@mciGetDeviceIDA?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmciGetCreatorTask, eax
	call	esi
	mov	DWORD PTR _pmciGetDeviceIDA, eax

; 1952 :     pmciGetDeviceIDFromElementIDA = GetProcAddress(hWinmm, "mciGetDeviceIDFromElementIDA");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BN@MCHF@mciGetDeviceIDFromElementIDA?$AA@ ; `string'
	push	eax
	call	esi

; 1953 :     pmciGetDeviceIDFromElementIDW = GetProcAddress(hWinmm, "mciGetDeviceIDFromElementIDW");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BN@JEHH@mciGetDeviceIDFromElementIDW?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmciGetDeviceIDFromElementIDA, eax
	call	esi

; 1954 :     pmciGetDeviceIDW = GetProcAddress(hWinmm, "mciGetDeviceIDW");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@FMIF@mciGetDeviceIDW?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmciGetDeviceIDFromElementIDW, eax
	call	esi
	mov	DWORD PTR _pmciGetDeviceIDW, eax

; 1955 :     pmciGetDriverData = GetProcAddress(hWinmm, "mciGetDriverData");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@DLAL@mciGetDriverData?$AA@ ; `string'
	push	eax
	call	esi

; 1956 :     pmciGetErrorStringA = GetProcAddress(hWinmm, "mciGetErrorStringA");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@IDBJ@mciGetErrorStringA?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmciGetDriverData, eax
	call	esi

; 1957 :     pmciGetErrorStringW = GetProcAddress(hWinmm, "mciGetErrorStringW");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@NFBL@mciGetErrorStringW?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmciGetErrorStringA, eax
	call	esi
	mov	DWORD PTR _pmciGetErrorStringW, eax

; 1958 :     pmciGetYieldProc = GetProcAddress(hWinmm, "mciGetYieldProc");

	push	OFFSET FLAT:??_C@_0BA@LJKD@mciGetYieldProc?$AA@ ; `string'
	mov	eax, DWORD PTR _hWinmm
	push	eax
	call	esi

; 1959 :     pmciLoadCommandResource = GetProcAddress(hWinmm, "mciLoadCommandResource");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BH@IJD@mciLoadCommandResource?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmciGetYieldProc, eax
	call	esi

; 1960 :     pmciSendCommandA = GetProcAddress(hWinmm, "mciSendCommandA");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@JKLO@mciSendCommandA?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmciLoadCommandResource, eax
	call	esi
	mov	DWORD PTR _pmciSendCommandA, eax

; 1961 :     pmciSendCommandW = GetProcAddress(hWinmm, "mciSendCommandW");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@MMLM@mciSendCommandW?$AA@ ; `string'
	push	eax
	call	esi

; 1962 :     pmciSendStringA = GetProcAddress(hWinmm, "mciSendStringA");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@GAMF@mciSendStringA?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmciSendCommandW, eax
	call	esi

; 1963 :     pmciSendStringW = GetProcAddress(hWinmm, "mciSendStringW");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@DGMH@mciSendStringW?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmciSendStringA, eax
	call	esi
	mov	DWORD PTR _pmciSendStringW, eax

; 1964 :     pmciSetDriverData = GetProcAddress(hWinmm, "mciSetDriverData");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@GIGC@mciSetDriverData?$AA@ ; `string'
	push	eax
	call	esi

; 1965 :     pmciSetYieldProc = GetProcAddress(hWinmm, "mciSetYieldProc");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@NAKB@mciSetYieldProc?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmciSetDriverData, eax
	call	esi

; 1966 :     pmid32Message = GetProcAddress(hWinmm, "mid32Message");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@DICL@mid32Message?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmciSetYieldProc, eax
	call	esi
	mov	DWORD PTR _pmid32Message, eax

; 1967 :     pmidiConnect = GetProcAddress(hWinmm, "midiConnect");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@CPPD@midiConnect?$AA@ ; `string'
	push	eax
	call	esi

; 1968 :     pmidiDisconnect = GetProcAddress(hWinmm, "midiDisconnect");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@KHF@midiDisconnect?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiConnect, eax
	call	esi

; 1969 :     pmidiInAddBuffer = GetProcAddress(hWinmm, "midiInAddBuffer");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@MNBE@midiInAddBuffer?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiDisconnect, eax
	call	esi
	mov	DWORD PTR _pmidiInAddBuffer, eax

; 1970 :     pmidiInClose = GetProcAddress(hWinmm, "midiInClose");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@KBJH@midiInClose?$AA@ ; `string'
	push	eax
	call	esi

; 1971 :     pmidiInGetDevCapsA = GetProcAddress(hWinmm, "midiInGetDevCapsA");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@NPDI@midiInGetDevCapsA?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiInClose, eax
	call	esi

; 1972 :     pmidiInGetDevCapsW = GetProcAddress(hWinmm, "midiInGetDevCapsW");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@IJDK@midiInGetDevCapsW?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiInGetDevCapsA, eax
	call	esi
	mov	DWORD PTR _pmidiInGetDevCapsW, eax

; 1973 :     pmidiInGetErrorTextA = GetProcAddress(hWinmm, "midiInGetErrorTextA");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BE@OCKH@midiInGetErrorTextA?$AA@ ; `string'
	push	eax
	call	esi

; 1974 :     pmidiInGetErrorTextW = GetProcAddress(hWinmm, "midiInGetErrorTextW");

	mov	ecx, DWORD PTR _hWinmm
	mov	DWORD PTR _pmidiInGetErrorTextA, eax
	push	OFFSET FLAT:??_C@_0BE@LEKF@midiInGetErrorTextW?$AA@ ; `string'
	push	ecx
	call	esi

; 1975 :     pmidiInGetID = GetProcAddress(hWinmm, "midiInGetID");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@LGKJ@midiInGetID?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiInGetErrorTextW, eax
	call	esi
	mov	DWORD PTR _pmidiInGetID, eax

; 1976 :     pmidiInGetNumDevs = GetProcAddress(hWinmm, "midiInGetNumDevs");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@DKPK@midiInGetNumDevs?$AA@ ; `string'
	push	eax
	call	esi

; 1977 :     pmidiInMessage = GetProcAddress(hWinmm, "midiInMessage");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0O@DNDL@midiInMessage?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiInGetNumDevs, eax
	call	esi

; 1978 :     pmidiInOpen = GetProcAddress(hWinmm, "midiInOpen");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@FPCM@midiInOpen?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiInMessage, eax
	call	esi
	mov	DWORD PTR _pmidiInOpen, eax

; 1979 :     pmidiInPrepareHeader = GetProcAddress(hWinmm, "midiInPrepareHeader");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BE@PKDG@midiInPrepareHeader?$AA@ ; `string'
	push	eax
	call	esi

; 1980 :     pmidiInReset = GetProcAddress(hWinmm, "midiInReset");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@OLBB@midiInReset?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiInPrepareHeader, eax
	call	esi

; 1981 :     pmidiInStart = GetProcAddress(hWinmm, "midiInStart");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@LFPM@midiInStart?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiInReset, eax
	call	esi
	mov	DWORD PTR _pmidiInStart, eax

; 1982 :     pmidiInStop = GetProcAddress(hWinmm, "midiInStop");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@GHDE@midiInStop?$AA@ ; `string'
	push	eax
	call	esi

; 1983 :     pmidiInUnprepareHeader = GetProcAddress(hWinmm, "midiInUnprepareHeader");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BG@JPPA@midiInUnprepareHeader?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiInStop, eax
	call	esi

; 1984 :     pmidiOutCacheDrumPatches = GetProcAddress(hWinmm, "midiOutCacheDrumPatches");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BI@NAJB@midiOutCacheDrumPatches?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiInUnprepareHeader, eax
	call	esi
	mov	DWORD PTR _pmidiOutCacheDrumPatches, eax

; 1985 :     pmidiOutCachePatches = GetProcAddress(hWinmm, "midiOutCachePatches");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BE@CBNA@midiOutCachePatches?$AA@ ; `string'
	push	eax
	call	esi

; 1986 :     pmidiOutClose = GetProcAddress(hWinmm, "midiOutClose");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@PCNN@midiOutClose?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiOutCachePatches, eax
	call	esi

; 1987 :     pmidiOutGetDevCapsA = GetProcAddress(hWinmm, "midiOutGetDevCapsA");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@BA@midiOutGetDevCapsA?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiOutClose, eax
	call	esi
	mov	DWORD PTR _pmidiOutGetDevCapsA, eax

; 1988 :     pmidiOutGetDevCapsW = GetProcAddress(hWinmm, "midiOutGetDevCapsW");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@FGBC@midiOutGetDevCapsW?$AA@ ; `string'
	push	eax
	call	esi

; 1989 :     pmidiOutGetErrorTextA = GetProcAddress(hWinmm, "midiOutGetErrorTextA");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BF@HLAE@midiOutGetErrorTextA?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiOutGetDevCapsW, eax
	call	esi

; 1990 :     pmidiOutGetErrorTextW = GetProcAddress(hWinmm, "midiOutGetErrorTextW");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BF@CNAG@midiOutGetErrorTextW?$AA@ ; `string'
	mov	DWORD PTR _pmidiOutGetErrorTextA, eax
	push	edx
	call	esi
	mov	DWORD PTR _pmidiOutGetErrorTextW, eax

; 1991 :     pmidiOutGetID = GetProcAddress(hWinmm, "midiOutGetID");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@OFOD@midiOutGetID?$AA@ ; `string'
	push	eax
	call	esi

; 1992 :     pmidiOutGetNumDevs = GetProcAddress(hWinmm, "midiOutGetNumDevs");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@BCOH@midiOutGetNumDevs?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiOutGetID, eax
	call	esi

; 1993 :     pmidiOutGetVolume = GetProcAddress(hWinmm, "midiOutGetVolume");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@ENJA@midiOutGetVolume?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiOutGetNumDevs, eax
	call	esi
	mov	DWORD PTR _pmidiOutGetVolume, eax

; 1994 :     pmidiOutLongMsg = GetProcAddress(hWinmm, "midiOutLongMsg");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@KNDI@midiOutLongMsg?$AA@ ; `string'
	push	eax
	call	esi

; 1995 :     pmidiOutMessage = GetProcAddress(hWinmm, "midiOutMessage");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@BJFN@midiOutMessage?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiOutLongMsg, eax
	call	esi

; 1996 :     pmidiOutOpen = GetProcAddress(hWinmm, "midiOutOpen");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@BFFB@midiOutOpen?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiOutMessage, eax
	call	esi
	mov	DWORD PTR _pmidiOutOpen, eax

; 1997 :     pmidiOutPrepareHeader = GetProcAddress(hWinmm, "midiOutPrepareHeader");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BF@GDJF@midiOutPrepareHeader?$AA@ ; `string'
	push	eax
	call	esi

; 1998 :     pmidiOutReset = GetProcAddress(hWinmm, "midiOutReset");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@LIFL@midiOutReset?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiOutPrepareHeader, eax
	call	esi

; 1999 :     pmidiOutSetVolume = GetProcAddress(hWinmm, "midiOutSetVolume");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@GADC@midiOutSetVolume?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiOutReset, eax
	call	esi
	mov	DWORD PTR _pmidiOutSetVolume, eax

; 2000 :     pmidiOutShortMsg = GetProcAddress(hWinmm, "midiOutShortMsg");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@ICEO@midiOutShortMsg?$AA@ ; `string'
	push	eax
	call	esi

; 2001 :     pmidiOutUnprepareHeader = GetProcAddress(hWinmm, "midiOutUnprepareHeader");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BH@MNAE@midiOutUnprepareHeader?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiOutShortMsg, eax
	call	esi

; 2002 :     pmidiStreamClose = GetProcAddress(hWinmm, "midiStreamClose");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@PKJI@midiStreamClose?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiOutUnprepareHeader, eax
	call	esi
	mov	DWORD PTR _pmidiStreamClose, eax

; 2003 :     pmidiStreamOpen = GetProcAddress(hWinmm, "midiStreamOpen");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@FAGH@midiStreamOpen?$AA@ ; `string'
	push	eax
	call	esi

; 2004 :     pmidiStreamOut = GetProcAddress(hWinmm, "midiStreamOut");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0O@MCEN@midiStreamOut?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiStreamOpen, eax
	call	esi

; 2005 :     pmidiStreamPause = GetProcAddress(hWinmm, "midiStreamPause");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@JHNK@midiStreamPause?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiStreamOut, eax
	call	esi
	mov	DWORD PTR _pmidiStreamPause, eax

; 2006 :     pmidiStreamPosition = GetProcAddress(hWinmm, "midiStreamPosition");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@CJJI@midiStreamPosition?$AA@ ; `string'
	push	eax
	call	esi

; 2007 :     pmidiStreamProperty = GetProcAddress(hWinmm, "midiStreamProperty");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@NHF@midiStreamProperty?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiStreamPosition, eax
	call	esi

; 2008 :     pmidiStreamRestart = GetProcAddress(hWinmm, "midiStreamRestart");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@LLAA@midiStreamRestart?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmidiStreamProperty, eax
	call	esi
	mov	DWORD PTR _pmidiStreamRestart, eax

; 2009 :     pmidiStreamStop = GetProcAddress(hWinmm, "midiStreamStop");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@GIHP@midiStreamStop?$AA@ ; `string'
	push	eax
	call	esi

; 2010 :     pmixerClose = GetProcAddress(hWinmm, "mixerClose");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@NGHK@mixerClose?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmidiStreamStop, eax
	call	esi

; 2011 :     pmixerGetControlDetailsA = GetProcAddress(hWinmm, "mixerGetControlDetailsA");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BI@KKIG@mixerGetControlDetailsA?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmixerClose, eax
	call	esi
	mov	DWORD PTR _pmixerGetControlDetailsA, eax

; 2012 :     pmixerGetControlDetailsW = GetProcAddress(hWinmm, "mixerGetControlDetailsW");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BI@PMIE@mixerGetControlDetailsW?$AA@ ; `string'
	push	eax
	call	esi

; 2013 :     pmixerGetDevCapsA = GetProcAddress(hWinmm, "mixerGetDevCapsA");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@MMIF@mixerGetDevCapsA?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmixerGetControlDetailsW, eax
	call	esi

; 2014 :     pmixerGetDevCapsW = GetProcAddress(hWinmm, "mixerGetDevCapsW");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@JKIH@mixerGetDevCapsW?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmixerGetDevCapsA, eax
	call	esi
	mov	DWORD PTR _pmixerGetDevCapsW, eax

; 2015 :     pmixerGetID = GetProcAddress(hWinmm, "mixerGetID");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@MBEE@mixerGetID?$AA@ ; `string'
	push	eax
	call	esi

; 2016 :     pmixerGetLineControlsA = GetProcAddress(hWinmm, "mixerGetLineControlsA");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BG@GELF@mixerGetLineControlsA?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmixerGetID, eax
	call	esi

; 2017 :     pmixerGetLineControlsW = GetProcAddress(hWinmm, "mixerGetLineControlsW");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BG@DCLH@mixerGetLineControlsW?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmixerGetLineControlsA, eax
	call	esi
	mov	DWORD PTR _pmixerGetLineControlsW, eax

; 2018 :     pmixerGetLineInfoA = GetProcAddress(hWinmm, "mixerGetLineInfoA");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@LCF@mixerGetLineInfoA?$AA@ ; `string'
	push	eax
	call	esi

; 2019 :     pmixerGetLineInfoW = GetProcAddress(hWinmm, "mixerGetLineInfoW");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@FNCH@mixerGetLineInfoW?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmixerGetLineInfoA, eax
	call	esi

; 2020 :     pmixerGetNumDevs = GetProcAddress(hWinmm, "mixerGetNumDevs");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@IHGE@mixerGetNumDevs?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmixerGetLineInfoW, eax
	call	esi
	mov	DWORD PTR _pmixerGetNumDevs, eax

; 2021 :     pmixerMessage = GetProcAddress(hWinmm, "mixerMessage");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@LFII@mixerMessage?$AA@ ; `string'
	push	eax
	call	esi

; 2022 :     pmixerOpen = GetProcAddress(hWinmm, "mixerOpen");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_09LCEO@mixerOpen?$AA@	; `string'
	push	ecx
	mov	DWORD PTR _pmixerMessage, eax
	call	esi
	mov	DWORD PTR _pmixerOpen, eax

; 2023 :     pmixerSetControlDetails = GetProcAddress(hWinmm, "mixerSetControlDetails");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BH@EDCE@mixerSetControlDetails?$AA@ ; `string'
	push	edx
	call	esi
	mov	DWORD PTR _pmixerSetControlDetails, eax

; 2024 :     pmmDrvInstall = GetProcAddress(hWinmm, "mmDrvInstall");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@DCIM@mmDrvInstall?$AA@ ; `string'
	push	eax
	call	esi

; 2025 :     pmmGetCurrentTask = GetProcAddress(hWinmm, "mmGetCurrentTask");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@NEHP@mmGetCurrentTask?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmmDrvInstall, eax
	call	esi

; 2026 :     pmmTaskBlock = GetProcAddress(hWinmm, "mmTaskBlock");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@CGD@mmTaskBlock?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmmGetCurrentTask, eax
	call	esi
	mov	DWORD PTR _pmmTaskBlock, eax

; 2027 :     pmmTaskCreate = GetProcAddress(hWinmm, "mmTaskCreate");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@GAFI@mmTaskCreate?$AA@ ; `string'
	push	eax
	call	esi

; 2028 :     pmmTaskSignal = GetProcAddress(hWinmm, "mmTaskSignal");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@GFLM@mmTaskSignal?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmmTaskCreate, eax
	call	esi

; 2029 :     pmmTaskYield = GetProcAddress(hWinmm, "mmTaskYield");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@LAKN@mmTaskYield?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmmTaskSignal, eax
	call	esi
	mov	DWORD PTR _pmmTaskYield, eax

; 2030 :     pmmioAdvance = GetProcAddress(hWinmm, "mmioAdvance");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@IBMG@mmioAdvance?$AA@ ; `string'
	push	eax
	call	esi

; 2031 :     pmmioAscend = GetProcAddress(hWinmm, "mmioAscend");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@LHNO@mmioAscend?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmmioAdvance, eax
	call	esi

; 2032 :     pmmioClose = GetProcAddress(hWinmm, "mmioClose");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_09JPN@mmioClose?$AA@	; `string'
	push	edx
	mov	DWORD PTR _pmmioAscend, eax
	call	esi
	mov	DWORD PTR _pmmioClose, eax

; 2033 :     pmmioCreateChunk = GetProcAddress(hWinmm, "mmioCreateChunk");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@CDLD@mmioCreateChunk?$AA@ ; `string'
	push	eax
	call	esi

; 2034 :     pmmioDescend = GetProcAddress(hWinmm, "mmioDescend");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@NPPM@mmioDescend?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmmioCreateChunk, eax
	call	esi

; 2035 :     pmmioFlush = GetProcAddress(hWinmm, "mmioFlush");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_09GIMM@mmioFlush?$AA@	; `string'
	push	edx
	mov	DWORD PTR _pmmioDescend, eax
	call	esi
	mov	DWORD PTR _pmmioFlush, eax

; 2036 :     pmmioGetInfo = GetProcAddress(hWinmm, "mmioGetInfo");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@HOBF@mmioGetInfo?$AA@ ; `string'
	push	eax
	call	esi

; 2037 :     pmmioInstallIOProcA = GetProcAddress(hWinmm, "mmioInstallIOProcA");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@KFBE@mmioInstallIOProcA?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmmioGetInfo, eax
	call	esi

; 2038 :     pmmioInstallIOProcW = GetProcAddress(hWinmm, "mmioInstallIOProcW");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@PDBG@mmioInstallIOProcW?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmmioInstallIOProcA, eax
	call	esi
	mov	DWORD PTR _pmmioInstallIOProcW, eax

; 2039 :     pmmioOpenA = GetProcAddress(hWinmm, "mmioOpenA");

	push	OFFSET FLAT:??_C@_09DNGC@mmioOpenA?$AA@	; `string'
	mov	eax, DWORD PTR _hWinmm
	push	eax
	call	esi

; 2040 :     pmmioOpenW = GetProcAddress(hWinmm, "mmioOpenW");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_09GLGA@mmioOpenW?$AA@	; `string'
	push	ecx
	mov	DWORD PTR _pmmioOpenA, eax
	call	esi

; 2041 :     pmmioRead = GetProcAddress(hWinmm, "mmioRead");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_08JKLF@mmioRead?$AA@	; `string'
	push	edx
	mov	DWORD PTR _pmmioOpenW, eax
	call	esi
	mov	DWORD PTR _pmmioRead, eax

; 2042 :     pmmioRenameA = GetProcAddress(hWinmm, "mmioRenameA");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@PEIF@mmioRenameA?$AA@ ; `string'
	push	eax
	call	esi

; 2043 :     pmmioRenameW = GetProcAddress(hWinmm, "mmioRenameW");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@KCIH@mmioRenameW?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmmioRenameA, eax
	call	esi

; 2044 :     pmmioSeek = GetProcAddress(hWinmm, "mmioSeek");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_08OEBA@mmioSeek?$AA@	; `string'
	push	edx
	mov	DWORD PTR _pmmioRenameW, eax
	call	esi
	mov	DWORD PTR _pmmioSeek, eax

; 2045 :     pmmioSendMessage = GetProcAddress(hWinmm, "mmioSendMessage");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@PCED@mmioSendMessage?$AA@ ; `string'
	push	eax
	call	esi

; 2046 :     pmmioSetBuffer = GetProcAddress(hWinmm, "mmioSetBuffer");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0O@OCHB@mmioSetBuffer?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmmioSendMessage, eax
	call	esi

; 2047 :     pmmioSetInfo = GetProcAddress(hWinmm, "mmioSetInfo");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@CNBJ@mmioSetInfo?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmmioSetBuffer, eax
	call	esi
	mov	DWORD PTR _pmmioSetInfo, eax

; 2048 :     pmmioStringToFOURCCA = GetProcAddress(hWinmm, "mmioStringToFOURCCA");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BE@CJEP@mmioStringToFOURCCA?$AA@ ; `string'
	push	eax
	call	esi

; 2049 :     pmmioStringToFOURCCW = GetProcAddress(hWinmm, "mmioStringToFOURCCW");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BE@HPEN@mmioStringToFOURCCW?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmmioStringToFOURCCA, eax
	call	esi

; 2050 :     pmmioWrite = GetProcAddress(hWinmm, "mmioWrite");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_09KGEC@mmioWrite?$AA@	; `string'
	push	edx
	mov	DWORD PTR _pmmioStringToFOURCCW, eax
	call	esi
	mov	DWORD PTR _pmmioWrite, eax

; 2051 :     pmmsystemGetVersion = GetProcAddress(hWinmm, "mmsystemGetVersion");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@BLEE@mmsystemGetVersion?$AA@ ; `string'
	push	eax
	call	esi

; 2052 :     pmod32Message = GetProcAddress(hWinmm, "mod32Message");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@EHAL@mod32Message?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pmmsystemGetVersion, eax
	call	esi

; 2053 :     pmxd32Message = GetProcAddress(hWinmm, "mxd32Message");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@HKFI@mxd32Message?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pmod32Message, eax
	call	esi
	mov	DWORD PTR _pmxd32Message, eax

; 2054 :     psndPlaySoundA = GetProcAddress(hWinmm, "sndPlaySoundA");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0O@CLPB@sndPlaySoundA?$AA@ ; `string'
	push	eax
	call	esi

; 2055 :     psndPlaySoundW = GetProcAddress(hWinmm, "sndPlaySoundW");

	mov	ecx, DWORD PTR _hWinmm
	mov	DWORD PTR _psndPlaySoundA, eax
	push	OFFSET FLAT:??_C@_0O@HNPD@sndPlaySoundW?$AA@ ; `string'
	push	ecx
	call	esi

; 2056 :     ptid32Message = GetProcAddress(hWinmm, "tid32Message");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@OEDN@tid32Message?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _psndPlaySoundW, eax
	call	esi
	mov	DWORD PTR _ptid32Message, eax

; 2057 :     ptimeBeginPeriod = GetProcAddress(hWinmm, "timeBeginPeriod");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@CAIP@timeBeginPeriod?$AA@ ; `string'
	push	eax
	call	esi

; 2058 :     ptimeEndPeriod = GetProcAddress(hWinmm, "timeEndPeriod");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0O@NIGI@timeEndPeriod?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _ptimeBeginPeriod, eax
	call	esi

; 2059 :     ptimeGetDevCaps = GetProcAddress(hWinmm, "timeGetDevCaps");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@MAOL@timeGetDevCaps?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _ptimeEndPeriod, eax
	call	esi
	mov	DWORD PTR _ptimeGetDevCaps, eax

; 2060 :     ptimeGetSystemTime = GetProcAddress(hWinmm, "timeGetSystemTime");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@HHNM@timeGetSystemTime?$AA@ ; `string'
	push	eax
	call	esi

; 2061 :     ptimeGetTime = GetProcAddress(hWinmm, "timeGetTime");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@HBOP@timeGetTime?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _ptimeGetSystemTime, eax
	call	esi

; 2062 :     ptimeKillEvent = GetProcAddress(hWinmm, "timeKillEvent");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0O@CIKN@timeKillEvent?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _ptimeGetTime, eax
	call	esi
	mov	DWORD PTR _ptimeKillEvent, eax

; 2063 :     ptimeSetEvent = GetProcAddress(hWinmm, "timeSetEvent");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@JPEP@timeSetEvent?$AA@ ; `string'
	push	eax
	call	esi

; 2064 :     pwaveInGetDevCapsA = GetProcAddress(hWinmm, "waveInGetDevCapsA");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@PGPH@waveInGetDevCapsA?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _ptimeSetEvent, eax
	call	esi

; 2065 :     pwaveInGetDevCapsW = GetProcAddress(hWinmm, "waveInGetDevCapsW");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@KAPF@waveInGetDevCapsW?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwaveInGetDevCapsA, eax
	call	esi
	mov	DWORD PTR _pwaveInGetDevCapsW, eax

; 2066 :     pwaveInGetErrorTextA = GetProcAddress(hWinmm, "waveInGetErrorTextA");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BE@IDJN@waveInGetErrorTextA?$AA@ ; `string'
	push	eax
	call	esi

; 2067 :     pwaveInGetErrorTextW = GetProcAddress(hWinmm, "waveInGetErrorTextW");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BE@NFJP@waveInGetErrorTextW?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveInGetErrorTextA, eax
	call	esi

; 2068 :     pwaveInGetID = GetProcAddress(hWinmm, "waveInGetID");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@CAPK@waveInGetID?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwaveInGetErrorTextW, eax
	call	esi
	mov	DWORD PTR _pwaveInGetID, eax

; 2069 :     pwaveInGetNumDevs = GetProcAddress(hWinmm, "waveInGetNumDevs");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@PFCO@waveInGetNumDevs?$AA@ ; `string'
	push	eax
	call	esi

; 2070 :     pwaveInGetPosition = GetProcAddress(hWinmm, "waveInGetPosition");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@CLNA@waveInGetPosition?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveInGetNumDevs, eax
	call	esi

; 2071 :     pwaveInMessage = GetProcAddress(hWinmm, "waveInMessage");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0O@FBPN@waveInMessage?$AA@ ; `string'
	mov	DWORD PTR _pwaveInGetPosition, eax
	push	edx
	call	esi
	mov	DWORD PTR _pwaveInMessage, eax

; 2072 :     pwaveInReset = GetProcAddress(hWinmm, "waveInReset");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@HNEC@waveInReset?$AA@ ; `string'
	push	eax
	call	esi

; 2073 :     pwaveOutBreakLoop = GetProcAddress(hWinmm, "waveOutBreakLoop");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@EJGO@waveOutBreakLoop?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveInReset, eax
	call	esi

; 2074 :     pwaveOutClose = GetProcAddress(hWinmm, "waveOutClose");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@DEEL@waveOutClose?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwaveOutBreakLoop, eax
	call	esi
	mov	DWORD PTR _pwaveOutClose, eax

; 2075 :     pwaveOutGetDevCapsA = GetProcAddress(hWinmm, "waveOutGetDevCapsA");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@DKDJ@waveOutGetDevCapsA?$AA@ ; `string'
	push	eax
	call	esi

; 2076 :     pwaveOutGetDevCapsW = GetProcAddress(hWinmm, "waveOutGetDevCapsW");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@GMDL@waveOutGetDevCapsW?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveOutGetDevCapsA, eax
	call	esi

; 2077 :     pwaveOutGetErrorTextA = GetProcAddress(hWinmm, "waveOutGetErrorTextA");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BF@CJGF@waveOutGetErrorTextA?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwaveOutGetDevCapsW, eax
	call	esi
	mov	DWORD PTR _pwaveOutGetErrorTextA, eax

; 2078 :     pwaveOutGetErrorTextW = GetProcAddress(hWinmm, "waveOutGetErrorTextW");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BF@HPGH@waveOutGetErrorTextW?$AA@ ; `string'
	push	eax
	call	esi

; 2079 :     pwaveOutGetID = GetProcAddress(hWinmm, "waveOutGetID");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@CDHF@waveOutGetID?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveOutGetErrorTextW, eax
	call	esi

; 2080 :     pwaveOutGetNumDevs = GetProcAddress(hWinmm, "waveOutGetNumDevs");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BC@DLCI@waveOutGetNumDevs?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwaveOutGetID, eax
	call	esi
	mov	DWORD PTR _pwaveOutGetNumDevs, eax

; 2081 :     pwaveOutGetPitch = GetProcAddress(hWinmm, "waveOutGetPitch");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@BMAE@waveOutGetPitch?$AA@ ; `string'
	push	eax
	call	esi

; 2082 :     pwaveOutGetPlaybackRate = GetProcAddress(hWinmm, "waveOutGetPlaybackRate");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BH@PGGC@waveOutGetPlaybackRate?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveOutGetPitch, eax
	call	esi

; 2083 :     pwaveOutGetPosition = GetProcAddress(hWinmm, "waveOutGetPosition");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@OHBO@waveOutGetPosition?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwaveOutGetPlaybackRate, eax
	call	esi
	mov	DWORD PTR _pwaveOutGetPosition, eax

; 2084 :     pwaveOutGetVolume = GetProcAddress(hWinmm, "waveOutGetVolume");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@ICEE@waveOutGetVolume?$AA@ ; `string'
	push	eax
	call	esi

; 2085 :     pwaveOutMessage = GetProcAddress(hWinmm, "waveOutMessage");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@CODB@waveOutMessage?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveOutGetVolume, eax
	call	esi

; 2086 :     pwaveOutOpen = GetProcAddress(hWinmm, "waveOutOpen");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@IDAC@waveOutOpen?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwaveOutMessage, eax
	call	esi
	mov	DWORD PTR _pwaveOutOpen, eax

; 2087 :     pwaveOutPause = GetProcAddress(hWinmm, "waveOutPause");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@FJAJ@waveOutPause?$AA@ ; `string'
	push	eax
	call	esi

; 2088 :     pwaveOutPrepareHeader = GetProcAddress(hWinmm, "waveOutPrepareHeader");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BF@DBPE@waveOutPrepareHeader?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveOutPause, eax
	call	esi

; 2089 :     pwaveOutReset = GetProcAddress(hWinmm, "waveOutReset");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@HOMN@waveOutReset?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwaveOutPrepareHeader, eax
	call	esi
	mov	DWORD PTR _pwaveOutReset, eax

; 2090 :     pwaveOutRestart = GetProcAddress(hWinmm, "waveOutRestart");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@KFNO@waveOutRestart?$AA@ ; `string'
	push	eax
	call	esi

; 2091 :     pwaveOutSetPitch = GetProcAddress(hWinmm, "waveOutSetPitch");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@LOFH@waveOutSetPitch?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveOutRestart, eax
	call	esi

; 2092 :     pwaveOutSetPlaybackRate = GetProcAddress(hWinmm, "waveOutSetPlaybackRate");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BH@NGOG@waveOutSetPlaybackRate?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwaveOutSetPitch, eax
	call	esi
	mov	DWORD PTR _pwaveOutSetPlaybackRate, eax

; 2093 :     pwaveOutSetVolume = GetProcAddress(hWinmm, "waveOutSetVolume");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@KPOG@waveOutSetVolume?$AA@ ; `string'
	push	eax
	call	esi

; 2094 :     pwaveOutUnprepareHeader = GetProcAddress(hWinmm, "waveOutUnprepareHeader");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BH@DHFI@waveOutUnprepareHeader?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveOutSetVolume, eax
	call	esi

; 2095 :     pwaveOutWrite = GetProcAddress(hWinmm, "waveOutWrite");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@JLPE@waveOutWrite?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwaveOutUnprepareHeader, eax
	call	esi
	mov	DWORD PTR _pwaveOutWrite, eax

; 2096 :     pwid32Message = GetProcAddress(hWinmm, "wid32Message");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@FCAC@wid32Message?$AA@ ; `string'
	push	eax
	call	esi

; 2097 :     pwinmmDbgOut = GetProcAddress(hWinmm, "winmmDbgOut");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@LDOC@winmmDbgOut?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwid32Message, eax
	call	esi

; 2098 :     pwinmmSetDebugLevel = GetProcAddress(hWinmm, "winmmSetDebugLevel");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BD@GICE@winmmSetDebugLevel?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwinmmDbgOut, eax
	call	esi
	mov	DWORD PTR _pwinmmSetDebugLevel, eax

; 2099 :     pwod32Message = GetProcAddress(hWinmm, "wod32Message");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@CNCC@wod32Message?$AA@ ; `string'
	push	eax
	call	esi

; 2100 : 
; 2101 :     pgfxAddGfx = GetProcAddress(hWinmm, "gfxAddGfx");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_09OCCL@gfxAddGfx?$AA@	; `string'
	push	ecx
	mov	DWORD PTR _pwod32Message, eax
	call	esi

; 2102 :     pgfxBatchChange = GetProcAddress(hWinmm, "gfxBatchChange");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0P@BJBG@gfxBatchChange?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pgfxAddGfx, eax
	call	esi
	mov	DWORD PTR _pgfxBatchChange, eax

; 2103 :     pgfxCreateGfxFactoriesList = GetProcAddress(hWinmm, "gfxCreateGfxFactoriesLis");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BJ@EBCG@gfxCreateGfxFactoriesLis?$AA@ ; `string'
	push	eax
	call	esi

; 2104 :     pgfxCreateZoneFactoriesList = GetProcAddress(hWinmm, "gfxCreateZoneFactoriesList");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BL@FFCF@gfxCreateZoneFactoriesList?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pgfxCreateGfxFactoriesList, eax
	call	esi
	mov	DWORD PTR _pgfxCreateZoneFactoriesList, eax

; 2105 :     pgfxDestroyDeviceInterfaceList = GetProcAddress(hWinmm, "gfxDestroyDeviceInterfaceList");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BO@GJGP@gfxDestroyDeviceInterfaceList?$AA@ ; `string'
	push	edx
	call	esi
	mov	DWORD PTR _pgfxDestroyDeviceInterfaceList, eax

; 2106 :     pgfxEnumerateGfxs = GetProcAddress(hWinmm, "gfxEnumerateGfxs");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BB@LMEH@gfxEnumerateGfxs?$AA@ ; `string'
	push	eax
	call	esi

; 2107 :     p_gfxLogoff = GetProcAddress(hWinmm, "_gfxLogoff@0");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@MLFB@_gfxLogoff?$EA0?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pgfxEnumerateGfxs, eax
	call	esi

; 2108 :     p_gfxLogon = GetProcAddress(hWinmm, "_gfxLogon@4");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@HNL@_gfxLogon?$EA4?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _p_gfxLogoff, eax
	call	esi
	mov	DWORD PTR _p_gfxLogon, eax

; 2109 :     pgfxModifyGfx = GetProcAddress(hWinmm, "gfxModifyGfx");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@EEEC@gfxModifyGfx?$AA@ ; `string'
	push	eax
	call	esi

; 2110 :     pgfxOpenGfx = GetProcAddress(hWinmm, "gfxOpenGfx");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@LNDM@gfxOpenGfx?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pgfxModifyGfx, eax
	call	esi

; 2111 :     pgfxRemoveGfx = GetProcAddress(hWinmm, "gfxRemoveGfx");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0N@CDAE@gfxRemoveGfx?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pgfxOpenGfx, eax
	call	esi
	mov	DWORD PTR _pgfxRemoveGfx, eax

; 2112 : 
; 2113 : 
; 2114 :     pwaveInAddBuffer =  (UINT ( WINAPI *)(HWAVEIN, void*, UINT))GetProcAddress(hWinmm, "waveInAddBuffer");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BA@BJCD@waveInAddBuffer?$AA@ ; `string'
	push	eax
	call	esi

; 2115 :     pwaveInClose = (UINT ( WINAPI *)(HWAVEIN))GetProcAddress(hWinmm, "waveInClose");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@DHME@waveInClose?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveInAddBuffer, eax
	call	esi

; 2116 :     pwaveInOpen = (UINT (WINAPI*)(LPHWAVIN, UINT, LPCWAVEFORMATEX, DWORD, DWORD, DWORD))GetProcAddress(hWinmm, "waveInOpen");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@MJA@waveInOpen?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwaveInClose, eax
	call	esi
	mov	DWORD PTR _pwaveInOpen, eax

; 2117 :     pwaveInPrepareHeader = (UINT ( WINAPI *)(HWAVEIN, void*, UINT))GetProcAddress(hWinmm, "waveInPrepareHeader");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BE@JLAM@waveInPrepareHeader?$AA@ ; `string'
	push	eax
	call	esi

; 2118 :     pwaveInStart = (UINT ( WINAPI *)(HWAVEIN))GetProcAddress(hWinmm, "waveInStart");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@CDKP@waveInStart?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveInPrepareHeader, eax
	call	esi

; 2119 :     pwaveInStop = (UINT ( WINAPI *)(HWAVEIN))GetProcAddress(hWinmm, "waveInStop");

	mov	edx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0L@DEII@waveInStop?$AA@ ; `string'
	push	edx
	mov	DWORD PTR _pwaveInStart, eax
	call	esi
	mov	DWORD PTR _pwaveInStop, eax

; 2120 :     pwaveInUnprepareHeader = (UINT ( WINAPI *)(HWAVEIN, void*, UINT))GetProcAddress(hWinmm, "waveInUnprepareHeader");

	mov	eax, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0BG@MDKC@waveInUnprepareHeader?$AA@ ; `string'
	push	eax
	call	esi

; 2121 : 	pjoyGetPosEx = (UINT ( WINAPI *)(UINT uJoyID, LPJOYINFOEX pji))GetProcAddress(hWinmm, "joyGetPosEx");

	mov	ecx, DWORD PTR _hWinmm
	push	OFFSET FLAT:??_C@_0M@JMBN@joyGetPosEx?$AA@ ; `string'
	push	ecx
	mov	DWORD PTR _pwaveInUnprepareHeader, eax
	call	esi
	mov	DWORD PTR _pjoyGetPosEx, eax
	pop	esi

; 2122 : }

	ret	0
_GetPointerToOriginalFunc ENDP
_TEXT	ENDS
PUBLIC	_joyConfigChanged
EXTRN	__imp__TlsSetValue@8:NEAR
;	COMDAT _joyConfigChanged
_TEXT	SEGMENT
_joyConfigChanged PROC NEAR				; COMDAT

; 2133 : void NAKED joyConfigChanged(void) {  INITWINMM __asm jmp dword ptr pjoyConfigChanged  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28062
	push	2133					; 00000855H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28062:
	jmp	DWORD PTR _pjoyConfigChanged
_joyConfigChanged ENDP
_TEXT	ENDS
PUBLIC	_joyGetThreshold
;	COMDAT _joyGetThreshold
_TEXT	SEGMENT
_joyGetThreshold PROC NEAR				; COMDAT

; 2134 : void NAKED joyGetThreshold(void)   {   INITWINMM __asm  jmp dword ptr   pjoyGetThreshold}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28065
	push	2134					; 00000856H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28065:
	jmp	DWORD PTR _pjoyGetThreshold
_joyGetThreshold ENDP
_TEXT	ENDS
PUBLIC	_joyReleaseCapture
;	COMDAT _joyReleaseCapture
_TEXT	SEGMENT
_joyReleaseCapture PROC NEAR				; COMDAT

; 2135 : void NAKED joyReleaseCapture(void) {   INITWINMM __asm jmp dword ptr   pjoyReleaseCapture}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28068
	push	2135					; 00000857H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28068:
	jmp	DWORD PTR _pjoyReleaseCapture
_joyReleaseCapture ENDP
_TEXT	ENDS
PUBLIC	_joySetCapture
;	COMDAT _joySetCapture
_TEXT	SEGMENT
_joySetCapture PROC NEAR				; COMDAT

; 2136 : void NAKED joySetCapture(void) {   INITWINMM __asm jmp dword ptr   pjoySetCapture}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28071
	push	2136					; 00000858H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28071:
	jmp	DWORD PTR _pjoySetCapture
_joySetCapture ENDP
_TEXT	ENDS
PUBLIC	_joySetThreshold
;	COMDAT _joySetThreshold
_TEXT	SEGMENT
_joySetThreshold PROC NEAR				; COMDAT

; 2137 : void NAKED joySetThreshold(void) {   INITWINMM __asm jmp dword ptr   pjoySetThreshold}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28074
	push	2137					; 00000859H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28074:
	jmp	DWORD PTR _pjoySetThreshold
_joySetThreshold ENDP
_TEXT	ENDS
PUBLIC	_mci32Message
;	COMDAT _mci32Message
_TEXT	SEGMENT
_mci32Message PROC NEAR					; COMDAT

; 2138 : void NAKED mci32Message(void) {   INITWINMM __asm jmp dword ptr   pmci32Message}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28077
	push	2138					; 0000085aH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28077:
	jmp	DWORD PTR _pmci32Message
_mci32Message ENDP
_TEXT	ENDS
PUBLIC	_mciDriverNotify
;	COMDAT _mciDriverNotify
_TEXT	SEGMENT
_mciDriverNotify PROC NEAR				; COMDAT

; 2139 : void NAKED mciDriverNotify(void) {   INITWINMM __asm jmp dword ptr   pmciDriverNotify}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28080
	push	2139					; 0000085bH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28080:
	jmp	DWORD PTR _pmciDriverNotify
_mciDriverNotify ENDP
_TEXT	ENDS
PUBLIC	_mciDriverYield
;	COMDAT _mciDriverYield
_TEXT	SEGMENT
_mciDriverYield PROC NEAR				; COMDAT

; 2140 : void NAKED mciDriverYield(void) {   INITWINMM __asm jmp dword ptr   pmciDriverYield}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28083
	push	2140					; 0000085cH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28083:
	jmp	DWORD PTR _pmciDriverYield
_mciDriverYield ENDP
_TEXT	ENDS
PUBLIC	_mciExecute
;	COMDAT _mciExecute
_TEXT	SEGMENT
_mciExecute PROC NEAR					; COMDAT

; 2141 : void NAKED mciExecute(void) {   INITWINMM __asm jmp dword ptr   pmciExecute}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28086
	push	2141					; 0000085dH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28086:
	jmp	DWORD PTR _pmciExecute
_mciExecute ENDP
_TEXT	ENDS
PUBLIC	_mciFreeCommandResource
;	COMDAT _mciFreeCommandResource
_TEXT	SEGMENT
_mciFreeCommandResource PROC NEAR			; COMDAT

; 2142 : void NAKED mciFreeCommandResource(void) {   INITWINMM __asm jmp dword ptr   pmciFreeCommandResource}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28089
	push	2142					; 0000085eH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28089:
	jmp	DWORD PTR _pmciFreeCommandResource
_mciFreeCommandResource ENDP
_TEXT	ENDS
PUBLIC	_mciGetCreatorTask
;	COMDAT _mciGetCreatorTask
_TEXT	SEGMENT
_mciGetCreatorTask PROC NEAR				; COMDAT

; 2143 : void NAKED mciGetCreatorTask(void) {   INITWINMM __asm jmp dword ptr   pmciGetCreatorTask}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28092
	push	2143					; 0000085fH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28092:
	jmp	DWORD PTR _pmciGetCreatorTask
_mciGetCreatorTask ENDP
_TEXT	ENDS
PUBLIC	_mciGetDeviceIDA
;	COMDAT _mciGetDeviceIDA
_TEXT	SEGMENT
_mciGetDeviceIDA PROC NEAR				; COMDAT

; 2144 : void NAKED mciGetDeviceIDA(void) {   INITWINMM __asm jmp dword ptr   pmciGetDeviceIDA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28095
	push	2144					; 00000860H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28095:
	jmp	DWORD PTR _pmciGetDeviceIDA
_mciGetDeviceIDA ENDP
_TEXT	ENDS
PUBLIC	_mciGetDeviceIDFromElementIDA
;	COMDAT _mciGetDeviceIDFromElementIDA
_TEXT	SEGMENT
_mciGetDeviceIDFromElementIDA PROC NEAR			; COMDAT

; 2145 : void NAKED mciGetDeviceIDFromElementIDA(void) {   INITWINMM __asm jmp dword ptr   pmciGetDeviceIDFromElementIDA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28098
	push	2145					; 00000861H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28098:
	jmp	DWORD PTR _pmciGetDeviceIDFromElementIDA
_mciGetDeviceIDFromElementIDA ENDP
_TEXT	ENDS
PUBLIC	_mciGetDeviceIDFromElementIDW
;	COMDAT _mciGetDeviceIDFromElementIDW
_TEXT	SEGMENT
_mciGetDeviceIDFromElementIDW PROC NEAR			; COMDAT

; 2146 : void NAKED mciGetDeviceIDFromElementIDW(void) {   INITWINMM __asm jmp dword ptr   pmciGetDeviceIDFromElementIDW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28101
	push	2146					; 00000862H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28101:
	jmp	DWORD PTR _pmciGetDeviceIDFromElementIDW
_mciGetDeviceIDFromElementIDW ENDP
_TEXT	ENDS
PUBLIC	_mciGetDeviceIDW
;	COMDAT _mciGetDeviceIDW
_TEXT	SEGMENT
_mciGetDeviceIDW PROC NEAR				; COMDAT

; 2147 : void NAKED mciGetDeviceIDW(void) {   INITWINMM __asm jmp dword ptr   pmciGetDeviceIDW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28104
	push	2147					; 00000863H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28104:
	jmp	DWORD PTR _pmciGetDeviceIDW
_mciGetDeviceIDW ENDP
_TEXT	ENDS
PUBLIC	_mciGetDriverData
;	COMDAT _mciGetDriverData
_TEXT	SEGMENT
_mciGetDriverData PROC NEAR				; COMDAT

; 2148 : void NAKED mciGetDriverData(void) {   INITWINMM __asm jmp dword ptr   pmciGetDriverData}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28107
	push	2148					; 00000864H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28107:
	jmp	DWORD PTR _pmciGetDriverData
_mciGetDriverData ENDP
_TEXT	ENDS
PUBLIC	_mciGetErrorStringA
;	COMDAT _mciGetErrorStringA
_TEXT	SEGMENT
_mciGetErrorStringA PROC NEAR				; COMDAT

; 2149 : void NAKED mciGetErrorStringA(void) {   INITWINMM __asm jmp dword ptr   pmciGetErrorStringA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28110
	push	2149					; 00000865H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28110:
	jmp	DWORD PTR _pmciGetErrorStringA
_mciGetErrorStringA ENDP
_TEXT	ENDS
PUBLIC	_mciGetErrorStringW
;	COMDAT _mciGetErrorStringW
_TEXT	SEGMENT
_mciGetErrorStringW PROC NEAR				; COMDAT

; 2150 : void NAKED mciGetErrorStringW(void) {   INITWINMM __asm jmp dword ptr   pmciGetErrorStringW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28113
	push	2150					; 00000866H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28113:
	jmp	DWORD PTR _pmciGetErrorStringW
_mciGetErrorStringW ENDP
_TEXT	ENDS
PUBLIC	_mciGetYieldProc
;	COMDAT _mciGetYieldProc
_TEXT	SEGMENT
_mciGetYieldProc PROC NEAR				; COMDAT

; 2151 : void NAKED mciGetYieldProc(void) {   INITWINMM __asm jmp dword ptr   pmciGetYieldProc}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28116
	push	2151					; 00000867H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28116:
	jmp	DWORD PTR _pmciGetYieldProc
_mciGetYieldProc ENDP
_TEXT	ENDS
PUBLIC	_mciLoadCommandResource
;	COMDAT _mciLoadCommandResource
_TEXT	SEGMENT
_mciLoadCommandResource PROC NEAR			; COMDAT

; 2152 : void NAKED mciLoadCommandResource(void) {   INITWINMM __asm jmp dword ptr   pmciLoadCommandResource}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28119
	push	2152					; 00000868H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28119:
	jmp	DWORD PTR _pmciLoadCommandResource
_mciLoadCommandResource ENDP
_TEXT	ENDS
PUBLIC	_mciSendCommandA
;	COMDAT _mciSendCommandA
_TEXT	SEGMENT
_mciSendCommandA PROC NEAR				; COMDAT

; 2153 : void NAKED mciSendCommandA(void) {   INITWINMM __asm jmp dword ptr   pmciSendCommandA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28122
	push	2153					; 00000869H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28122:
	jmp	DWORD PTR _pmciSendCommandA
_mciSendCommandA ENDP
_TEXT	ENDS
PUBLIC	_mciSendCommandW
;	COMDAT _mciSendCommandW
_TEXT	SEGMENT
_mciSendCommandW PROC NEAR				; COMDAT

; 2154 : void NAKED mciSendCommandW(void) {   INITWINMM __asm jmp dword ptr   pmciSendCommandW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28125
	push	2154					; 0000086aH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28125:
	jmp	DWORD PTR _pmciSendCommandW
_mciSendCommandW ENDP
_TEXT	ENDS
PUBLIC	_mciSendStringA
;	COMDAT _mciSendStringA
_TEXT	SEGMENT
_mciSendStringA PROC NEAR				; COMDAT

; 2155 : void NAKED mciSendStringA(void) {   INITWINMM __asm jmp dword ptr   pmciSendStringA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28128
	push	2155					; 0000086bH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28128:
	jmp	DWORD PTR _pmciSendStringA
_mciSendStringA ENDP
_TEXT	ENDS
PUBLIC	_mciSendStringW
;	COMDAT _mciSendStringW
_TEXT	SEGMENT
_mciSendStringW PROC NEAR				; COMDAT

; 2156 : void NAKED mciSendStringW(void) {   INITWINMM __asm jmp dword ptr   pmciSendStringW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28131
	push	2156					; 0000086cH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28131:
	jmp	DWORD PTR _pmciSendStringW
_mciSendStringW ENDP
_TEXT	ENDS
PUBLIC	_mciSetDriverData
;	COMDAT _mciSetDriverData
_TEXT	SEGMENT
_mciSetDriverData PROC NEAR				; COMDAT

; 2157 : void NAKED mciSetDriverData(void) {   INITWINMM __asm jmp dword ptr   pmciSetDriverData}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28134
	push	2157					; 0000086dH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28134:
	jmp	DWORD PTR _pmciSetDriverData
_mciSetDriverData ENDP
_TEXT	ENDS
PUBLIC	_mciSetYieldProc
;	COMDAT _mciSetYieldProc
_TEXT	SEGMENT
_mciSetYieldProc PROC NEAR				; COMDAT

; 2158 : void NAKED mciSetYieldProc(void) {   INITWINMM __asm jmp dword ptr   pmciSetYieldProc}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28137
	push	2158					; 0000086eH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28137:
	jmp	DWORD PTR _pmciSetYieldProc
_mciSetYieldProc ENDP
_TEXT	ENDS
PUBLIC	_mid32Message
;	COMDAT _mid32Message
_TEXT	SEGMENT
_mid32Message PROC NEAR					; COMDAT

; 2159 : void NAKED mid32Message(void) {   INITWINMM __asm jmp dword ptr   pmid32Message}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28140
	push	2159					; 0000086fH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28140:
	jmp	DWORD PTR _pmid32Message
_mid32Message ENDP
_TEXT	ENDS
PUBLIC	_midiConnect
;	COMDAT _midiConnect
_TEXT	SEGMENT
_midiConnect PROC NEAR					; COMDAT

; 2160 : void NAKED midiConnect(void) {   INITWINMM __asm jmp dword ptr   pmidiConnect}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28143
	push	2160					; 00000870H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28143:
	jmp	DWORD PTR _pmidiConnect
_midiConnect ENDP
_TEXT	ENDS
PUBLIC	_midiDisconnect
;	COMDAT _midiDisconnect
_TEXT	SEGMENT
_midiDisconnect PROC NEAR				; COMDAT

; 2161 : void NAKED midiDisconnect(void) {   INITWINMM __asm jmp dword ptr   pmidiDisconnect}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28146
	push	2161					; 00000871H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28146:
	jmp	DWORD PTR _pmidiDisconnect
_midiDisconnect ENDP
_TEXT	ENDS
PUBLIC	_midiInAddBuffer
;	COMDAT _midiInAddBuffer
_TEXT	SEGMENT
_midiInAddBuffer PROC NEAR				; COMDAT

; 2162 : void NAKED midiInAddBuffer(void) {   INITWINMM __asm jmp dword ptr   pmidiInAddBuffer}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28149
	push	2162					; 00000872H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28149:
	jmp	DWORD PTR _pmidiInAddBuffer
_midiInAddBuffer ENDP
_TEXT	ENDS
PUBLIC	_midiInClose
;	COMDAT _midiInClose
_TEXT	SEGMENT
_midiInClose PROC NEAR					; COMDAT

; 2163 : void NAKED midiInClose(void) {  INITWINMM __asm jmp dword ptr   pmidiInClose}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28152
	push	2163					; 00000873H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28152:
	jmp	DWORD PTR _pmidiInClose
_midiInClose ENDP
_TEXT	ENDS
PUBLIC	_midiInGetDevCapsA
;	COMDAT _midiInGetDevCapsA
_TEXT	SEGMENT
_midiInGetDevCapsA PROC NEAR				; COMDAT

; 2164 : void NAKED midiInGetDevCapsA(void) {   INITWINMM __asm jmp dword ptr   pmidiInGetDevCapsA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28155
	push	2164					; 00000874H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28155:
	jmp	DWORD PTR _pmidiInGetDevCapsA
_midiInGetDevCapsA ENDP
_TEXT	ENDS
PUBLIC	_midiInGetDevCapsW
;	COMDAT _midiInGetDevCapsW
_TEXT	SEGMENT
_midiInGetDevCapsW PROC NEAR				; COMDAT

; 2165 : void NAKED midiInGetDevCapsW(void) {   INITWINMM __asm jmp dword ptr   pmidiInGetDevCapsW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28158
	push	2165					; 00000875H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28158:
	jmp	DWORD PTR _pmidiInGetDevCapsW
_midiInGetDevCapsW ENDP
_TEXT	ENDS
PUBLIC	_midiInGetErrorTextA
;	COMDAT _midiInGetErrorTextA
_TEXT	SEGMENT
_midiInGetErrorTextA PROC NEAR				; COMDAT

; 2166 : void NAKED midiInGetErrorTextA(void) {   INITWINMM __asm jmp dword ptr   pmidiInGetErrorTextA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28161
	push	2166					; 00000876H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28161:
	jmp	DWORD PTR _pmidiInGetErrorTextA
_midiInGetErrorTextA ENDP
_TEXT	ENDS
PUBLIC	_midiInGetErrorTextW
;	COMDAT _midiInGetErrorTextW
_TEXT	SEGMENT
_midiInGetErrorTextW PROC NEAR				; COMDAT

; 2167 : void NAKED midiInGetErrorTextW(void) {   INITWINMM __asm jmp dword ptr   pmidiInGetErrorTextW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28164
	push	2167					; 00000877H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28164:
	jmp	DWORD PTR _pmidiInGetErrorTextW
_midiInGetErrorTextW ENDP
_TEXT	ENDS
PUBLIC	_midiInGetID
;	COMDAT _midiInGetID
_TEXT	SEGMENT
_midiInGetID PROC NEAR					; COMDAT

; 2168 : void NAKED midiInGetID(void) {   INITWINMM __asm jmp dword ptr   pmidiInGetID}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28167
	push	2168					; 00000878H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28167:
	jmp	DWORD PTR _pmidiInGetID
_midiInGetID ENDP
_TEXT	ENDS
PUBLIC	_midiInGetNumDevs
;	COMDAT _midiInGetNumDevs
_TEXT	SEGMENT
_midiInGetNumDevs PROC NEAR				; COMDAT

; 2169 : void NAKED midiInGetNumDevs(void) {   INITWINMM __asm jmp dword ptr   pmidiInGetNumDevs}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28170
	push	2169					; 00000879H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28170:
	jmp	DWORD PTR _pmidiInGetNumDevs
_midiInGetNumDevs ENDP
_TEXT	ENDS
PUBLIC	_midiInMessage
;	COMDAT _midiInMessage
_TEXT	SEGMENT
_midiInMessage PROC NEAR				; COMDAT

; 2170 : void NAKED midiInMessage(void) {   INITWINMM __asm jmp dword ptr   pmidiInMessage}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28173
	push	2170					; 0000087aH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28173:
	jmp	DWORD PTR _pmidiInMessage
_midiInMessage ENDP
_TEXT	ENDS
PUBLIC	_midiInOpen
;	COMDAT _midiInOpen
_TEXT	SEGMENT
_midiInOpen PROC NEAR					; COMDAT

; 2171 : void NAKED midiInOpen(void) {   INITWINMM __asm jmp dword ptr   pmidiInOpen}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28176
	push	2171					; 0000087bH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28176:
	jmp	DWORD PTR _pmidiInOpen
_midiInOpen ENDP
_TEXT	ENDS
PUBLIC	_midiInPrepareHeader
;	COMDAT _midiInPrepareHeader
_TEXT	SEGMENT
_midiInPrepareHeader PROC NEAR				; COMDAT

; 2172 : void NAKED midiInPrepareHeader(void) {   INITWINMM __asm jmp dword ptr   pmidiInPrepareHeader}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28179
	push	2172					; 0000087cH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28179:
	jmp	DWORD PTR _pmidiInPrepareHeader
_midiInPrepareHeader ENDP
_TEXT	ENDS
PUBLIC	_midiInReset
;	COMDAT _midiInReset
_TEXT	SEGMENT
_midiInReset PROC NEAR					; COMDAT

; 2173 : void NAKED midiInReset(void) {   INITWINMM __asm jmp dword ptr   pmidiInReset}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28182
	push	2173					; 0000087dH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28182:
	jmp	DWORD PTR _pmidiInReset
_midiInReset ENDP
_TEXT	ENDS
PUBLIC	_midiInStart
;	COMDAT _midiInStart
_TEXT	SEGMENT
_midiInStart PROC NEAR					; COMDAT

; 2174 : void NAKED midiInStart(void) {   INITWINMM __asm jmp dword ptr   pmidiInStart}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28185
	push	2174					; 0000087eH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28185:
	jmp	DWORD PTR _pmidiInStart
_midiInStart ENDP
_TEXT	ENDS
PUBLIC	_midiInStop
;	COMDAT _midiInStop
_TEXT	SEGMENT
_midiInStop PROC NEAR					; COMDAT

; 2175 : void NAKED midiInStop(void) {   INITWINMM __asm jmp dword ptr   pmidiInStop}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28188
	push	2175					; 0000087fH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28188:
	jmp	DWORD PTR _pmidiInStop
_midiInStop ENDP
_TEXT	ENDS
PUBLIC	_midiInUnprepareHeader
;	COMDAT _midiInUnprepareHeader
_TEXT	SEGMENT
_midiInUnprepareHeader PROC NEAR			; COMDAT

; 2176 : void NAKED midiInUnprepareHeader(void) {   INITWINMM __asm jmp dword ptr   pmidiInUnprepareHeader}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28191
	push	2176					; 00000880H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28191:
	jmp	DWORD PTR _pmidiInUnprepareHeader
_midiInUnprepareHeader ENDP
_TEXT	ENDS
PUBLIC	_midiOutCacheDrumPatches
;	COMDAT _midiOutCacheDrumPatches
_TEXT	SEGMENT
_midiOutCacheDrumPatches PROC NEAR			; COMDAT

; 2177 : void NAKED midiOutCacheDrumPatches(void) {   INITWINMM __asm jmp dword ptr   pmidiOutCacheDrumPatches}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28194
	push	2177					; 00000881H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28194:
	jmp	DWORD PTR _pmidiOutCacheDrumPatches
_midiOutCacheDrumPatches ENDP
_TEXT	ENDS
PUBLIC	_midiOutCachePatches
;	COMDAT _midiOutCachePatches
_TEXT	SEGMENT
_midiOutCachePatches PROC NEAR				; COMDAT

; 2178 : void NAKED midiOutCachePatches(void) {   INITWINMM __asm jmp dword ptr   pmidiOutCachePatches}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28197
	push	2178					; 00000882H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28197:
	jmp	DWORD PTR _pmidiOutCachePatches
_midiOutCachePatches ENDP
_TEXT	ENDS
PUBLIC	_midiOutClose
;	COMDAT _midiOutClose
_TEXT	SEGMENT
_midiOutClose PROC NEAR					; COMDAT

; 2179 : void NAKED midiOutClose(void) {   INITWINMM __asm jmp dword ptr   pmidiOutClose}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28200
	push	2179					; 00000883H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28200:
	jmp	DWORD PTR _pmidiOutClose
_midiOutClose ENDP
_TEXT	ENDS
PUBLIC	_midiOutGetDevCapsA
;	COMDAT _midiOutGetDevCapsA
_TEXT	SEGMENT
_midiOutGetDevCapsA PROC NEAR				; COMDAT

; 2180 : void NAKED midiOutGetDevCapsA(void) {   INITWINMM __asm jmp dword ptr   pmidiOutGetDevCapsA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28203
	push	2180					; 00000884H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28203:
	jmp	DWORD PTR _pmidiOutGetDevCapsA
_midiOutGetDevCapsA ENDP
_TEXT	ENDS
PUBLIC	_midiOutGetDevCapsW
;	COMDAT _midiOutGetDevCapsW
_TEXT	SEGMENT
_midiOutGetDevCapsW PROC NEAR				; COMDAT

; 2181 : void NAKED midiOutGetDevCapsW(void) {   INITWINMM __asm jmp dword ptr   pmidiOutGetDevCapsW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28206
	push	2181					; 00000885H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28206:
	jmp	DWORD PTR _pmidiOutGetDevCapsW
_midiOutGetDevCapsW ENDP
_TEXT	ENDS
PUBLIC	_midiOutGetErrorTextA
;	COMDAT _midiOutGetErrorTextA
_TEXT	SEGMENT
_midiOutGetErrorTextA PROC NEAR				; COMDAT

; 2182 : void NAKED midiOutGetErrorTextA(void) {   INITWINMM __asm jmp dword ptr   pmidiOutGetErrorTextA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28209
	push	2182					; 00000886H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28209:
	jmp	DWORD PTR _pmidiOutGetErrorTextA
_midiOutGetErrorTextA ENDP
_TEXT	ENDS
PUBLIC	_midiOutGetErrorTextW
;	COMDAT _midiOutGetErrorTextW
_TEXT	SEGMENT
_midiOutGetErrorTextW PROC NEAR				; COMDAT

; 2183 : void NAKED midiOutGetErrorTextW(void) {   INITWINMM __asm jmp dword ptr   pmidiOutGetErrorTextW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28212
	push	2183					; 00000887H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28212:
	jmp	DWORD PTR _pmidiOutGetErrorTextW
_midiOutGetErrorTextW ENDP
_TEXT	ENDS
PUBLIC	_midiOutGetID
;	COMDAT _midiOutGetID
_TEXT	SEGMENT
_midiOutGetID PROC NEAR					; COMDAT

; 2184 : void NAKED midiOutGetID(void) {   INITWINMM __asm jmp dword ptr   pmidiOutGetID}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28215
	push	2184					; 00000888H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28215:
	jmp	DWORD PTR _pmidiOutGetID
_midiOutGetID ENDP
_TEXT	ENDS
PUBLIC	_midiOutGetNumDevs
;	COMDAT _midiOutGetNumDevs
_TEXT	SEGMENT
_midiOutGetNumDevs PROC NEAR				; COMDAT

; 2185 : void NAKED midiOutGetNumDevs(void) {   INITWINMM __asm jmp dword ptr   pmidiOutGetNumDevs}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28218
	push	2185					; 00000889H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28218:
	jmp	DWORD PTR _pmidiOutGetNumDevs
_midiOutGetNumDevs ENDP
_TEXT	ENDS
PUBLIC	_midiOutGetVolume
;	COMDAT _midiOutGetVolume
_TEXT	SEGMENT
_midiOutGetVolume PROC NEAR				; COMDAT

; 2186 : void NAKED midiOutGetVolume(void) {   INITWINMM __asm jmp dword ptr   pmidiOutGetVolume}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28221
	push	2186					; 0000088aH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28221:
	jmp	DWORD PTR _pmidiOutGetVolume
_midiOutGetVolume ENDP
_TEXT	ENDS
PUBLIC	_midiOutLongMsg
;	COMDAT _midiOutLongMsg
_TEXT	SEGMENT
_midiOutLongMsg PROC NEAR				; COMDAT

; 2187 : void NAKED midiOutLongMsg(void) {   INITWINMM __asm jmp dword ptr   pmidiOutLongMsg}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28224
	push	2187					; 0000088bH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28224:
	jmp	DWORD PTR _pmidiOutLongMsg
_midiOutLongMsg ENDP
_TEXT	ENDS
PUBLIC	_midiOutMessage
;	COMDAT _midiOutMessage
_TEXT	SEGMENT
_midiOutMessage PROC NEAR				; COMDAT

; 2188 : void NAKED midiOutMessage(void) {   INITWINMM __asm jmp dword ptr   pmidiOutMessage}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28227
	push	2188					; 0000088cH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28227:
	jmp	DWORD PTR _pmidiOutMessage
_midiOutMessage ENDP
_TEXT	ENDS
PUBLIC	_midiOutOpen
;	COMDAT _midiOutOpen
_TEXT	SEGMENT
_midiOutOpen PROC NEAR					; COMDAT

; 2189 : void NAKED midiOutOpen(void) {   INITWINMM __asm jmp dword ptr   pmidiOutOpen}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28230
	push	2189					; 0000088dH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28230:
	jmp	DWORD PTR _pmidiOutOpen
_midiOutOpen ENDP
_TEXT	ENDS
PUBLIC	_midiOutPrepareHeader
;	COMDAT _midiOutPrepareHeader
_TEXT	SEGMENT
_midiOutPrepareHeader PROC NEAR				; COMDAT

; 2190 : void NAKED midiOutPrepareHeader(void) {   INITWINMM __asm jmp dword ptr   pmidiOutPrepareHeader}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28233
	push	2190					; 0000088eH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28233:
	jmp	DWORD PTR _pmidiOutPrepareHeader
_midiOutPrepareHeader ENDP
_TEXT	ENDS
PUBLIC	_midiOutReset
;	COMDAT _midiOutReset
_TEXT	SEGMENT
_midiOutReset PROC NEAR					; COMDAT

; 2191 : void NAKED midiOutReset(void) {   INITWINMM __asm jmp dword ptr   pmidiOutReset}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28236
	push	2191					; 0000088fH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28236:
	jmp	DWORD PTR _pmidiOutReset
_midiOutReset ENDP
_TEXT	ENDS
PUBLIC	_midiOutSetVolume
;	COMDAT _midiOutSetVolume
_TEXT	SEGMENT
_midiOutSetVolume PROC NEAR				; COMDAT

; 2192 : void NAKED midiOutSetVolume(void) {   INITWINMM __asm jmp dword ptr   pmidiOutSetVolume}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28239
	push	2192					; 00000890H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28239:
	jmp	DWORD PTR _pmidiOutSetVolume
_midiOutSetVolume ENDP
_TEXT	ENDS
PUBLIC	_midiOutShortMsg
;	COMDAT _midiOutShortMsg
_TEXT	SEGMENT
_midiOutShortMsg PROC NEAR				; COMDAT

; 2193 : void NAKED midiOutShortMsg(void) {   INITWINMM __asm jmp dword ptr   pmidiOutShortMsg}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28242
	push	2193					; 00000891H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28242:
	jmp	DWORD PTR _pmidiOutShortMsg
_midiOutShortMsg ENDP
_TEXT	ENDS
PUBLIC	_midiOutUnprepareHeader
;	COMDAT _midiOutUnprepareHeader
_TEXT	SEGMENT
_midiOutUnprepareHeader PROC NEAR			; COMDAT

; 2194 : void NAKED midiOutUnprepareHeader(void) {   INITWINMM __asm jmp dword ptr   pmidiOutUnprepareHeader}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28245
	push	2194					; 00000892H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28245:
	jmp	DWORD PTR _pmidiOutUnprepareHeader
_midiOutUnprepareHeader ENDP
_TEXT	ENDS
PUBLIC	_midiStreamClose
;	COMDAT _midiStreamClose
_TEXT	SEGMENT
_midiStreamClose PROC NEAR				; COMDAT

; 2195 : void NAKED midiStreamClose(void) {   INITWINMM __asm jmp dword ptr   pmidiStreamClose}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28248
	push	2195					; 00000893H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28248:
	jmp	DWORD PTR _pmidiStreamClose
_midiStreamClose ENDP
_TEXT	ENDS
PUBLIC	_midiStreamOpen
;	COMDAT _midiStreamOpen
_TEXT	SEGMENT
_midiStreamOpen PROC NEAR				; COMDAT

; 2196 : void NAKED midiStreamOpen(void) {   INITWINMM __asm jmp dword ptr   pmidiStreamOpen}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28251
	push	2196					; 00000894H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28251:
	jmp	DWORD PTR _pmidiStreamOpen
_midiStreamOpen ENDP
_TEXT	ENDS
PUBLIC	_midiStreamOut
;	COMDAT _midiStreamOut
_TEXT	SEGMENT
_midiStreamOut PROC NEAR				; COMDAT

; 2197 : void NAKED midiStreamOut(void) {   INITWINMM __asm jmp dword ptr   pmidiStreamOut}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28254
	push	2197					; 00000895H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28254:
	jmp	DWORD PTR _pmidiStreamOut
_midiStreamOut ENDP
_TEXT	ENDS
PUBLIC	_midiStreamPause
;	COMDAT _midiStreamPause
_TEXT	SEGMENT
_midiStreamPause PROC NEAR				; COMDAT

; 2198 : void NAKED midiStreamPause(void) {   INITWINMM __asm jmp dword ptr   pmidiStreamPause}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28257
	push	2198					; 00000896H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28257:
	jmp	DWORD PTR _pmidiStreamPause
_midiStreamPause ENDP
_TEXT	ENDS
PUBLIC	_midiStreamPosition
;	COMDAT _midiStreamPosition
_TEXT	SEGMENT
_midiStreamPosition PROC NEAR				; COMDAT

; 2199 : void NAKED midiStreamPosition(void) {   INITWINMM __asm jmp dword ptr   pmidiStreamPosition}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28260
	push	2199					; 00000897H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28260:
	jmp	DWORD PTR _pmidiStreamPosition
_midiStreamPosition ENDP
_TEXT	ENDS
PUBLIC	_midiStreamProperty
;	COMDAT _midiStreamProperty
_TEXT	SEGMENT
_midiStreamProperty PROC NEAR				; COMDAT

; 2200 : void NAKED midiStreamProperty(void) {   INITWINMM __asm jmp dword ptr   pmidiStreamProperty}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28263
	push	2200					; 00000898H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28263:
	jmp	DWORD PTR _pmidiStreamProperty
_midiStreamProperty ENDP
_TEXT	ENDS
PUBLIC	_midiStreamRestart
;	COMDAT _midiStreamRestart
_TEXT	SEGMENT
_midiStreamRestart PROC NEAR				; COMDAT

; 2201 : void NAKED midiStreamRestart(void) {   INITWINMM __asm jmp dword ptr   pmidiStreamRestart}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28266
	push	2201					; 00000899H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28266:
	jmp	DWORD PTR _pmidiStreamRestart
_midiStreamRestart ENDP
_TEXT	ENDS
PUBLIC	_midiStreamStop
;	COMDAT _midiStreamStop
_TEXT	SEGMENT
_midiStreamStop PROC NEAR				; COMDAT

; 2202 : void NAKED midiStreamStop(void) {   INITWINMM __asm jmp dword ptr   pmidiStreamStop}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28269
	push	2202					; 0000089aH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28269:
	jmp	DWORD PTR _pmidiStreamStop
_midiStreamStop ENDP
_TEXT	ENDS
PUBLIC	_mixerGetDevCapsA
;	COMDAT _mixerGetDevCapsA
_TEXT	SEGMENT
_mixerGetDevCapsA PROC NEAR				; COMDAT

; 2203 : void NAKED mixerGetDevCapsA(void) {   INITWINMM __asm jmp dword ptr   pmixerGetDevCapsA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28272
	push	2203					; 0000089bH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28272:
	jmp	DWORD PTR _pmixerGetDevCapsA
_mixerGetDevCapsA ENDP
_TEXT	ENDS
PUBLIC	_mixerGetDevCapsW
;	COMDAT _mixerGetDevCapsW
_TEXT	SEGMENT
_mixerGetDevCapsW PROC NEAR				; COMDAT

; 2204 : void NAKED mixerGetDevCapsW(void) {   INITWINMM __asm jmp dword ptr   pmixerGetDevCapsW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28275
	push	2204					; 0000089cH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28275:
	jmp	DWORD PTR _pmixerGetDevCapsW
_mixerGetDevCapsW ENDP
_TEXT	ENDS
PUBLIC	_mixerGetID
;	COMDAT _mixerGetID
_TEXT	SEGMENT
_mixerGetID PROC NEAR					; COMDAT

; 2205 : void NAKED mixerGetID(void) {   INITWINMM __asm jmp dword ptr   pmixerGetID}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28278
	push	2205					; 0000089dH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28278:
	jmp	DWORD PTR _pmixerGetID
_mixerGetID ENDP
_TEXT	ENDS
PUBLIC	_mixerGetNumDevs
;	COMDAT _mixerGetNumDevs
_TEXT	SEGMENT
_mixerGetNumDevs PROC NEAR				; COMDAT

; 2206 : void NAKED mixerGetNumDevs(void) {   INITWINMM __asm jmp dword ptr   pmixerGetNumDevs}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28281
	push	2206					; 0000089eH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28281:
	jmp	DWORD PTR _pmixerGetNumDevs
_mixerGetNumDevs ENDP
_TEXT	ENDS
PUBLIC	_mixerMessage
;	COMDAT _mixerMessage
_TEXT	SEGMENT
_mixerMessage PROC NEAR					; COMDAT

; 2207 : void NAKED mixerMessage(void) {   INITWINMM __asm jmp dword ptr   pmixerMessage}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28284
	push	2207					; 0000089fH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28284:
	jmp	DWORD PTR _pmixerMessage
_mixerMessage ENDP
_TEXT	ENDS
PUBLIC	_mmDrvInstall
;	COMDAT _mmDrvInstall
_TEXT	SEGMENT
_mmDrvInstall PROC NEAR					; COMDAT

; 2208 : void NAKED mmDrvInstall(void) {   INITWINMM __asm jmp dword ptr   pmmDrvInstall}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28287
	push	2208					; 000008a0H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28287:
	jmp	DWORD PTR _pmmDrvInstall
_mmDrvInstall ENDP
_TEXT	ENDS
PUBLIC	_mmGetCurrentTask
;	COMDAT _mmGetCurrentTask
_TEXT	SEGMENT
_mmGetCurrentTask PROC NEAR				; COMDAT

; 2209 : void NAKED mmGetCurrentTask(void) {   INITWINMM __asm jmp dword ptr   pmmGetCurrentTask}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28290
	push	2209					; 000008a1H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28290:
	jmp	DWORD PTR _pmmGetCurrentTask
_mmGetCurrentTask ENDP
_TEXT	ENDS
PUBLIC	_mmTaskBlock
;	COMDAT _mmTaskBlock
_TEXT	SEGMENT
_mmTaskBlock PROC NEAR					; COMDAT

; 2210 : void NAKED mmTaskBlock(void) {   INITWINMM __asm jmp dword ptr   pmmTaskBlock}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28293
	push	2210					; 000008a2H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28293:
	jmp	DWORD PTR _pmmTaskBlock
_mmTaskBlock ENDP
_TEXT	ENDS
PUBLIC	_mmTaskCreate
;	COMDAT _mmTaskCreate
_TEXT	SEGMENT
_mmTaskCreate PROC NEAR					; COMDAT

; 2211 : void NAKED mmTaskCreate(void) {   INITWINMM __asm jmp dword ptr   pmmTaskCreate}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28296
	push	2211					; 000008a3H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28296:
	jmp	DWORD PTR _pmmTaskCreate
_mmTaskCreate ENDP
_TEXT	ENDS
PUBLIC	_mmTaskSignal
;	COMDAT _mmTaskSignal
_TEXT	SEGMENT
_mmTaskSignal PROC NEAR					; COMDAT

; 2212 : void NAKED mmTaskSignal(void) {   INITWINMM __asm jmp dword ptr   pmmTaskSignal}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28299
	push	2212					; 000008a4H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28299:
	jmp	DWORD PTR _pmmTaskSignal
_mmTaskSignal ENDP
_TEXT	ENDS
PUBLIC	_mmTaskYield
;	COMDAT _mmTaskYield
_TEXT	SEGMENT
_mmTaskYield PROC NEAR					; COMDAT

; 2213 : void NAKED mmTaskYield(void) {   INITWINMM __asm jmp dword ptr   pmmTaskYield}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28302
	push	2213					; 000008a5H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28302:
	jmp	DWORD PTR _pmmTaskYield
_mmTaskYield ENDP
_TEXT	ENDS
PUBLIC	_mmioAdvance
;	COMDAT _mmioAdvance
_TEXT	SEGMENT
_mmioAdvance PROC NEAR					; COMDAT

; 2214 : void NAKED mmioAdvance(void) {   INITWINMM __asm jmp dword ptr   pmmioAdvance}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28305
	push	2214					; 000008a6H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28305:
	jmp	DWORD PTR _pmmioAdvance
_mmioAdvance ENDP
_TEXT	ENDS
PUBLIC	_mmioAscend
;	COMDAT _mmioAscend
_TEXT	SEGMENT
_mmioAscend PROC NEAR					; COMDAT

; 2215 : void NAKED mmioAscend(void) {   INITWINMM __asm jmp dword ptr   pmmioAscend}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28308
	push	2215					; 000008a7H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28308:
	jmp	DWORD PTR _pmmioAscend
_mmioAscend ENDP
_TEXT	ENDS
PUBLIC	_mmioClose
;	COMDAT _mmioClose
_TEXT	SEGMENT
_mmioClose PROC NEAR					; COMDAT

; 2216 : void NAKED mmioClose(void) {   INITWINMM __asm jmp dword ptr   pmmioClose}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28311
	push	2216					; 000008a8H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28311:
	jmp	DWORD PTR _pmmioClose
_mmioClose ENDP
_TEXT	ENDS
PUBLIC	_mmioCreateChunk
;	COMDAT _mmioCreateChunk
_TEXT	SEGMENT
_mmioCreateChunk PROC NEAR				; COMDAT

; 2217 : void NAKED mmioCreateChunk(void) {   INITWINMM __asm jmp dword ptr   pmmioCreateChunk}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28314
	push	2217					; 000008a9H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28314:
	jmp	DWORD PTR _pmmioCreateChunk
_mmioCreateChunk ENDP
_TEXT	ENDS
PUBLIC	_mmioDescend
;	COMDAT _mmioDescend
_TEXT	SEGMENT
_mmioDescend PROC NEAR					; COMDAT

; 2218 : void NAKED mmioDescend(void) {   INITWINMM __asm jmp dword ptr   pmmioDescend}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28317
	push	2218					; 000008aaH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28317:
	jmp	DWORD PTR _pmmioDescend
_mmioDescend ENDP
_TEXT	ENDS
PUBLIC	_mmioFlush
;	COMDAT _mmioFlush
_TEXT	SEGMENT
_mmioFlush PROC NEAR					; COMDAT

; 2219 : void NAKED mmioFlush(void) {   INITWINMM __asm jmp dword ptr   pmmioFlush}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28320
	push	2219					; 000008abH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28320:
	jmp	DWORD PTR _pmmioFlush
_mmioFlush ENDP
_TEXT	ENDS
PUBLIC	_mmioGetInfo
;	COMDAT _mmioGetInfo
_TEXT	SEGMENT
_mmioGetInfo PROC NEAR					; COMDAT

; 2220 : void NAKED mmioGetInfo(void) {   INITWINMM __asm jmp dword ptr   pmmioGetInfo}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28323
	push	2220					; 000008acH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28323:
	jmp	DWORD PTR _pmmioGetInfo
_mmioGetInfo ENDP
_TEXT	ENDS
PUBLIC	_mmioInstallIOProcA
;	COMDAT _mmioInstallIOProcA
_TEXT	SEGMENT
_mmioInstallIOProcA PROC NEAR				; COMDAT

; 2221 : void NAKED mmioInstallIOProcA(void) {   INITWINMM __asm jmp dword ptr   pmmioInstallIOProcA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28326
	push	2221					; 000008adH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28326:
	jmp	DWORD PTR _pmmioInstallIOProcA
_mmioInstallIOProcA ENDP
_TEXT	ENDS
PUBLIC	_mmioInstallIOProcW
;	COMDAT _mmioInstallIOProcW
_TEXT	SEGMENT
_mmioInstallIOProcW PROC NEAR				; COMDAT

; 2222 : void NAKED mmioInstallIOProcW(void) {   INITWINMM __asm jmp dword ptr   pmmioInstallIOProcW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28329
	push	2222					; 000008aeH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28329:
	jmp	DWORD PTR _pmmioInstallIOProcW
_mmioInstallIOProcW ENDP
_TEXT	ENDS
PUBLIC	_mmioOpenA
;	COMDAT _mmioOpenA
_TEXT	SEGMENT
_mmioOpenA PROC NEAR					; COMDAT

; 2223 : void NAKED mmioOpenA(void) {   INITWINMM __asm jmp dword ptr   pmmioOpenA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28332
	push	2223					; 000008afH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28332:
	jmp	DWORD PTR _pmmioOpenA
_mmioOpenA ENDP
_TEXT	ENDS
PUBLIC	_mmioOpenW
;	COMDAT _mmioOpenW
_TEXT	SEGMENT
_mmioOpenW PROC NEAR					; COMDAT

; 2224 : void NAKED mmioOpenW(void) {   INITWINMM __asm jmp dword ptr   pmmioOpenW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28335
	push	2224					; 000008b0H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28335:
	jmp	DWORD PTR _pmmioOpenW
_mmioOpenW ENDP
_TEXT	ENDS
PUBLIC	_mmioRead
;	COMDAT _mmioRead
_TEXT	SEGMENT
_mmioRead PROC NEAR					; COMDAT

; 2225 : void NAKED mmioRead(void) {  INITWINMM __asm jmp dword ptr   pmmioRead}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28338
	push	2225					; 000008b1H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28338:
	jmp	DWORD PTR _pmmioRead
_mmioRead ENDP
_TEXT	ENDS
PUBLIC	_mmioRenameA
;	COMDAT _mmioRenameA
_TEXT	SEGMENT
_mmioRenameA PROC NEAR					; COMDAT

; 2226 : void NAKED mmioRenameA(void) {   INITWINMM __asm jmp dword ptr   pmmioRenameA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28341
	push	2226					; 000008b2H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28341:
	jmp	DWORD PTR _pmmioRenameA
_mmioRenameA ENDP
_TEXT	ENDS
PUBLIC	_mmioRenameW
;	COMDAT _mmioRenameW
_TEXT	SEGMENT
_mmioRenameW PROC NEAR					; COMDAT

; 2227 : void NAKED mmioRenameW(void) {   INITWINMM __asm jmp dword ptr   pmmioRenameW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28344
	push	2227					; 000008b3H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28344:
	jmp	DWORD PTR _pmmioRenameW
_mmioRenameW ENDP
_TEXT	ENDS
PUBLIC	_mmioSeek
;	COMDAT _mmioSeek
_TEXT	SEGMENT
_mmioSeek PROC NEAR					; COMDAT

; 2228 : void NAKED mmioSeek(void) {   INITWINMM __asm jmp dword ptr   pmmioSeek}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28347
	push	2228					; 000008b4H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28347:
	jmp	DWORD PTR _pmmioSeek
_mmioSeek ENDP
_TEXT	ENDS
PUBLIC	_mmioSendMessage
;	COMDAT _mmioSendMessage
_TEXT	SEGMENT
_mmioSendMessage PROC NEAR				; COMDAT

; 2229 : void NAKED mmioSendMessage(void) {   INITWINMM __asm jmp dword ptr   pmmioSendMessage}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28350
	push	2229					; 000008b5H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28350:
	jmp	DWORD PTR _pmmioSendMessage
_mmioSendMessage ENDP
_TEXT	ENDS
PUBLIC	_mmioSetBuffer
;	COMDAT _mmioSetBuffer
_TEXT	SEGMENT
_mmioSetBuffer PROC NEAR				; COMDAT

; 2230 : void NAKED mmioSetBuffer(void) {   INITWINMM __asm jmp dword ptr   pmmioSetBuffer}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28353
	push	2230					; 000008b6H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28353:
	jmp	DWORD PTR _pmmioSetBuffer
_mmioSetBuffer ENDP
_TEXT	ENDS
PUBLIC	_mmioSetInfo
;	COMDAT _mmioSetInfo
_TEXT	SEGMENT
_mmioSetInfo PROC NEAR					; COMDAT

; 2231 : void NAKED mmioSetInfo(void) {   INITWINMM __asm jmp dword ptr   pmmioSetInfo}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28356
	push	2231					; 000008b7H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28356:
	jmp	DWORD PTR _pmmioSetInfo
_mmioSetInfo ENDP
_TEXT	ENDS
PUBLIC	_mmioStringToFOURCCA
;	COMDAT _mmioStringToFOURCCA
_TEXT	SEGMENT
_mmioStringToFOURCCA PROC NEAR				; COMDAT

; 2232 : void NAKED mmioStringToFOURCCA(void) {   INITWINMM __asm jmp dword ptr   pmmioStringToFOURCCA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28359
	push	2232					; 000008b8H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28359:
	jmp	DWORD PTR _pmmioStringToFOURCCA
_mmioStringToFOURCCA ENDP
_TEXT	ENDS
PUBLIC	_mmioStringToFOURCCW
;	COMDAT _mmioStringToFOURCCW
_TEXT	SEGMENT
_mmioStringToFOURCCW PROC NEAR				; COMDAT

; 2233 : void NAKED mmioStringToFOURCCW(void) {   INITWINMM __asm jmp dword ptr   pmmioStringToFOURCCW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28362
	push	2233					; 000008b9H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28362:
	jmp	DWORD PTR _pmmioStringToFOURCCW
_mmioStringToFOURCCW ENDP
_TEXT	ENDS
PUBLIC	_mmioWrite
;	COMDAT _mmioWrite
_TEXT	SEGMENT
_mmioWrite PROC NEAR					; COMDAT

; 2234 : void NAKED mmioWrite(void) {   INITWINMM __asm jmp dword ptr   pmmioWrite}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28365
	push	2234					; 000008baH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28365:
	jmp	DWORD PTR _pmmioWrite
_mmioWrite ENDP
_TEXT	ENDS
PUBLIC	_mmsystemGetVersion
;	COMDAT _mmsystemGetVersion
_TEXT	SEGMENT
_mmsystemGetVersion PROC NEAR				; COMDAT

; 2235 : void NAKED mmsystemGetVersion(void) {   INITWINMM __asm jmp dword ptr   pmmsystemGetVersion}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28368
	push	2235					; 000008bbH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28368:
	jmp	DWORD PTR _pmmsystemGetVersion
_mmsystemGetVersion ENDP
_TEXT	ENDS
PUBLIC	_mod32Message
;	COMDAT _mod32Message
_TEXT	SEGMENT
_mod32Message PROC NEAR					; COMDAT

; 2236 : void NAKED mod32Message(void) {   INITWINMM __asm jmp dword ptr   pmod32Message}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28371
	push	2236					; 000008bcH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28371:
	jmp	DWORD PTR _pmod32Message
_mod32Message ENDP
_TEXT	ENDS
PUBLIC	_mxd32Message
;	COMDAT _mxd32Message
_TEXT	SEGMENT
_mxd32Message PROC NEAR					; COMDAT

; 2237 : void NAKED mxd32Message(void) {   INITWINMM __asm jmp dword ptr   pmxd32Message}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28374
	push	2237					; 000008bdH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28374:
	jmp	DWORD PTR _pmxd32Message
_mxd32Message ENDP
_TEXT	ENDS
PUBLIC	_sndPlaySoundA
;	COMDAT _sndPlaySoundA
_TEXT	SEGMENT
_sndPlaySoundA PROC NEAR				; COMDAT

; 2238 : void NAKED sndPlaySoundA(void) {   INITWINMM __asm jmp dword ptr   psndPlaySoundA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28377
	push	2238					; 000008beH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28377:
	jmp	DWORD PTR _psndPlaySoundA
_sndPlaySoundA ENDP
_TEXT	ENDS
PUBLIC	_sndPlaySoundW
;	COMDAT _sndPlaySoundW
_TEXT	SEGMENT
_sndPlaySoundW PROC NEAR				; COMDAT

; 2239 : void NAKED sndPlaySoundW(void) {   INITWINMM __asm jmp dword ptr   psndPlaySoundW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28380
	push	2239					; 000008bfH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28380:
	jmp	DWORD PTR _psndPlaySoundW
_sndPlaySoundW ENDP
_TEXT	ENDS
PUBLIC	_tid32Message
;	COMDAT _tid32Message
_TEXT	SEGMENT
_tid32Message PROC NEAR					; COMDAT

; 2240 : void NAKED tid32Message(void) {   INITWINMM __asm jmp dword ptr   ptid32Message}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28383
	push	2240					; 000008c0H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28383:
	jmp	DWORD PTR _ptid32Message
_tid32Message ENDP
_TEXT	ENDS
PUBLIC	_timeGetDevCaps
;	COMDAT _timeGetDevCaps
_TEXT	SEGMENT
_timeGetDevCaps PROC NEAR				; COMDAT

; 2241 : void NAKED timeGetDevCaps(void) {   INITWINMM __asm jmp dword ptr   ptimeGetDevCaps}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28386
	push	2241					; 000008c1H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28386:
	jmp	DWORD PTR _ptimeGetDevCaps
_timeGetDevCaps ENDP
_TEXT	ENDS
PUBLIC	_timeGetSystemTime
;	COMDAT _timeGetSystemTime
_TEXT	SEGMENT
_timeGetSystemTime PROC NEAR				; COMDAT

; 2242 : void NAKED timeGetSystemTime(void) {   INITWINMM __asm jmp dword ptr   ptimeGetSystemTime}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28389
	push	2242					; 000008c2H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28389:
	jmp	DWORD PTR _ptimeGetSystemTime
_timeGetSystemTime ENDP
_TEXT	ENDS
PUBLIC	_timeKillEvent
;	COMDAT _timeKillEvent
_TEXT	SEGMENT
_timeKillEvent PROC NEAR				; COMDAT

; 2243 : void NAKED timeKillEvent(void) {   INITWINMM __asm jmp dword ptr   ptimeKillEvent}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28392
	push	2243					; 000008c3H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28392:
	jmp	DWORD PTR _ptimeKillEvent
_timeKillEvent ENDP
_TEXT	ENDS
PUBLIC	_timeSetEvent
;	COMDAT _timeSetEvent
_TEXT	SEGMENT
_timeSetEvent PROC NEAR					; COMDAT

; 2244 : void NAKED timeSetEvent(void) {   INITWINMM __asm jmp dword ptr   ptimeSetEvent}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28395
	push	2244					; 000008c4H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28395:
	jmp	DWORD PTR _ptimeSetEvent
_timeSetEvent ENDP
_TEXT	ENDS
PUBLIC	_waveInGetDevCapsA
;	COMDAT _waveInGetDevCapsA
_TEXT	SEGMENT
_waveInGetDevCapsA PROC NEAR				; COMDAT

; 2245 : void NAKED waveInGetDevCapsA(void) {   INITWINMM __asm jmp dword ptr   pwaveInGetDevCapsA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28398
	push	2245					; 000008c5H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28398:
	jmp	DWORD PTR _pwaveInGetDevCapsA
_waveInGetDevCapsA ENDP
_TEXT	ENDS
PUBLIC	_waveInGetDevCapsW
;	COMDAT _waveInGetDevCapsW
_TEXT	SEGMENT
_waveInGetDevCapsW PROC NEAR				; COMDAT

; 2246 : void NAKED waveInGetDevCapsW(void) {   INITWINMM __asm jmp dword ptr   pwaveInGetDevCapsW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28401
	push	2246					; 000008c6H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28401:
	jmp	DWORD PTR _pwaveInGetDevCapsW
_waveInGetDevCapsW ENDP
_TEXT	ENDS
PUBLIC	_waveInGetErrorTextA
;	COMDAT _waveInGetErrorTextA
_TEXT	SEGMENT
_waveInGetErrorTextA PROC NEAR				; COMDAT

; 2247 : void NAKED waveInGetErrorTextA(void) {   INITWINMM __asm jmp dword ptr   pwaveInGetErrorTextA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28404
	push	2247					; 000008c7H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28404:
	jmp	DWORD PTR _pwaveInGetErrorTextA
_waveInGetErrorTextA ENDP
_TEXT	ENDS
PUBLIC	_waveInGetErrorTextW
;	COMDAT _waveInGetErrorTextW
_TEXT	SEGMENT
_waveInGetErrorTextW PROC NEAR				; COMDAT

; 2248 : void NAKED waveInGetErrorTextW(void) {   INITWINMM __asm jmp dword ptr   pwaveInGetErrorTextW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28407
	push	2248					; 000008c8H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28407:
	jmp	DWORD PTR _pwaveInGetErrorTextW
_waveInGetErrorTextW ENDP
_TEXT	ENDS
PUBLIC	_waveInGetID
;	COMDAT _waveInGetID
_TEXT	SEGMENT
_waveInGetID PROC NEAR					; COMDAT

; 2249 : void NAKED waveInGetID(void) {   INITWINMM __asm jmp dword ptr   pwaveInGetID}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28410
	push	2249					; 000008c9H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28410:
	jmp	DWORD PTR _pwaveInGetID
_waveInGetID ENDP
_TEXT	ENDS
PUBLIC	_waveInGetNumDevs
;	COMDAT _waveInGetNumDevs
_TEXT	SEGMENT
_waveInGetNumDevs PROC NEAR				; COMDAT

; 2250 : void NAKED waveInGetNumDevs(void) {   INITWINMM __asm jmp dword ptr   pwaveInGetNumDevs}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28413
	push	2250					; 000008caH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28413:
	jmp	DWORD PTR _pwaveInGetNumDevs
_waveInGetNumDevs ENDP
_TEXT	ENDS
PUBLIC	_waveInMessage
;	COMDAT _waveInMessage
_TEXT	SEGMENT
_waveInMessage PROC NEAR				; COMDAT

; 2251 : void NAKED waveInMessage(void) {   INITWINMM __asm jmp dword ptr   pwaveInMessage}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28416
	push	2251					; 000008cbH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28416:
	jmp	DWORD PTR _pwaveInMessage
_waveInMessage ENDP
_TEXT	ENDS
PUBLIC	_waveOutBreakLoop
;	COMDAT _waveOutBreakLoop
_TEXT	SEGMENT
_waveOutBreakLoop PROC NEAR				; COMDAT

; 2252 : void NAKED waveOutBreakLoop(void) {   INITWINMM __asm jmp dword ptr   pwaveOutBreakLoop}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28419
	push	2252					; 000008ccH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28419:
	jmp	DWORD PTR _pwaveOutBreakLoop
_waveOutBreakLoop ENDP
_TEXT	ENDS
PUBLIC	_waveOutClose
;	COMDAT _waveOutClose
_TEXT	SEGMENT
_waveOutClose PROC NEAR					; COMDAT

; 2253 : void NAKED waveOutClose(void) {   INITWINMM __asm jmp dword ptr   pwaveOutClose}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28422
	push	2253					; 000008cdH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28422:
	jmp	DWORD PTR _pwaveOutClose
_waveOutClose ENDP
_TEXT	ENDS
PUBLIC	_waveOutGetDevCapsA
;	COMDAT _waveOutGetDevCapsA
_TEXT	SEGMENT
_waveOutGetDevCapsA PROC NEAR				; COMDAT

; 2254 : void NAKED waveOutGetDevCapsA(void) {   INITWINMM __asm jmp dword ptr   pwaveOutGetDevCapsA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28425
	push	2254					; 000008ceH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28425:
	jmp	DWORD PTR _pwaveOutGetDevCapsA
_waveOutGetDevCapsA ENDP
_TEXT	ENDS
PUBLIC	_waveOutGetDevCapsW
;	COMDAT _waveOutGetDevCapsW
_TEXT	SEGMENT
_waveOutGetDevCapsW PROC NEAR				; COMDAT

; 2255 : void NAKED waveOutGetDevCapsW(void) {   INITWINMM __asm jmp dword ptr   pwaveOutGetDevCapsW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28428
	push	2255					; 000008cfH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28428:
	jmp	DWORD PTR _pwaveOutGetDevCapsW
_waveOutGetDevCapsW ENDP
_TEXT	ENDS
PUBLIC	_waveOutGetErrorTextA
;	COMDAT _waveOutGetErrorTextA
_TEXT	SEGMENT
_waveOutGetErrorTextA PROC NEAR				; COMDAT

; 2256 : void NAKED waveOutGetErrorTextA(void) {   INITWINMM __asm jmp dword ptr   pwaveOutGetErrorTextA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28431
	push	2256					; 000008d0H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28431:
	jmp	DWORD PTR _pwaveOutGetErrorTextA
_waveOutGetErrorTextA ENDP
_TEXT	ENDS
PUBLIC	_waveOutGetErrorTextW
;	COMDAT _waveOutGetErrorTextW
_TEXT	SEGMENT
_waveOutGetErrorTextW PROC NEAR				; COMDAT

; 2257 : void NAKED waveOutGetErrorTextW(void) {   INITWINMM __asm jmp dword ptr   pwaveOutGetErrorTextW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28434
	push	2257					; 000008d1H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28434:
	jmp	DWORD PTR _pwaveOutGetErrorTextW
_waveOutGetErrorTextW ENDP
_TEXT	ENDS
PUBLIC	_waveOutGetID
;	COMDAT _waveOutGetID
_TEXT	SEGMENT
_waveOutGetID PROC NEAR					; COMDAT

; 2258 : void NAKED waveOutGetID(void) {   INITWINMM __asm jmp dword ptr   pwaveOutGetID}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28437
	push	2258					; 000008d2H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28437:
	jmp	DWORD PTR _pwaveOutGetID
_waveOutGetID ENDP
_TEXT	ENDS
PUBLIC	_waveOutGetNumDevs
;	COMDAT _waveOutGetNumDevs
_TEXT	SEGMENT
_waveOutGetNumDevs PROC NEAR				; COMDAT

; 2259 : void NAKED waveOutGetNumDevs(void) {   INITWINMM __asm jmp dword ptr pwaveOutGetNumDevs }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28440
	push	2259					; 000008d3H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28440:
	jmp	DWORD PTR _pwaveOutGetNumDevs
_waveOutGetNumDevs ENDP
_TEXT	ENDS
PUBLIC	_waveOutGetPitch
;	COMDAT _waveOutGetPitch
_TEXT	SEGMENT
_waveOutGetPitch PROC NEAR				; COMDAT

; 2260 : void NAKED waveOutGetPitch(void) {   INITWINMM __asm jmp dword ptr   pwaveOutGetPitch}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28443
	push	2260					; 000008d4H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28443:
	jmp	DWORD PTR _pwaveOutGetPitch
_waveOutGetPitch ENDP
_TEXT	ENDS
PUBLIC	_waveOutGetPlaybackRate
;	COMDAT _waveOutGetPlaybackRate
_TEXT	SEGMENT
_waveOutGetPlaybackRate PROC NEAR			; COMDAT

; 2261 : void NAKED waveOutGetPlaybackRate(void) {   INITWINMM __asm jmp dword ptr   pwaveOutGetPlaybackRate}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28446
	push	2261					; 000008d5H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28446:
	jmp	DWORD PTR _pwaveOutGetPlaybackRate
_waveOutGetPlaybackRate ENDP
_TEXT	ENDS
PUBLIC	_waveOutGetVolume
;	COMDAT _waveOutGetVolume
_TEXT	SEGMENT
_waveOutGetVolume PROC NEAR				; COMDAT

; 2262 : void NAKED waveOutGetVolume(void) {   INITWINMM __asm jmp dword ptr   pwaveOutGetVolume}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28449
	push	2262					; 000008d6H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28449:
	jmp	DWORD PTR _pwaveOutGetVolume
_waveOutGetVolume ENDP
_TEXT	ENDS
PUBLIC	_waveOutMessage
;	COMDAT _waveOutMessage
_TEXT	SEGMENT
_waveOutMessage PROC NEAR				; COMDAT

; 2263 : void NAKED waveOutMessage(void) {   INITWINMM __asm jmp dword ptr   pwaveOutMessage }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28452
	push	2263					; 000008d7H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28452:
	jmp	DWORD PTR _pwaveOutMessage
_waveOutMessage ENDP
_TEXT	ENDS
PUBLIC	_waveOutOpen
;	COMDAT _waveOutOpen
_TEXT	SEGMENT
_waveOutOpen PROC NEAR					; COMDAT

; 2264 : void NAKED waveOutOpen(void)    {   INITWINMM __asm jmp dword ptr   pwaveOutOpen }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28455
	push	2264					; 000008d8H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28455:
	jmp	DWORD PTR _pwaveOutOpen
_waveOutOpen ENDP
_TEXT	ENDS
PUBLIC	_waveOutPause
;	COMDAT _waveOutPause
_TEXT	SEGMENT
_waveOutPause PROC NEAR					; COMDAT

; 2265 : void NAKED waveOutPause(void) {   INITWINMM __asm jmp dword ptr   pwaveOutPause}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28458
	push	2265					; 000008d9H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28458:
	jmp	DWORD PTR _pwaveOutPause
_waveOutPause ENDP
_TEXT	ENDS
PUBLIC	_waveOutReset
;	COMDAT _waveOutReset
_TEXT	SEGMENT
_waveOutReset PROC NEAR					; COMDAT

; 2266 : void NAKED waveOutReset(void) {   INITWINMM __asm jmp dword ptr   pwaveOutReset }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28461
	push	2266					; 000008daH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28461:
	jmp	DWORD PTR _pwaveOutReset
_waveOutReset ENDP
_TEXT	ENDS
PUBLIC	_waveOutRestart
;	COMDAT _waveOutRestart
_TEXT	SEGMENT
_waveOutRestart PROC NEAR				; COMDAT

; 2267 : void NAKED waveOutRestart(void) {   INITWINMM __asm jmp dword ptr   pwaveOutRestart}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28464
	push	2267					; 000008dbH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28464:
	jmp	DWORD PTR _pwaveOutRestart
_waveOutRestart ENDP
_TEXT	ENDS
PUBLIC	_waveOutSetPitch
;	COMDAT _waveOutSetPitch
_TEXT	SEGMENT
_waveOutSetPitch PROC NEAR				; COMDAT

; 2268 : void NAKED waveOutSetPitch(void) {   INITWINMM __asm jmp dword ptr   pwaveOutSetPitch}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28467
	push	2268					; 000008dcH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28467:
	jmp	DWORD PTR _pwaveOutSetPitch
_waveOutSetPitch ENDP
_TEXT	ENDS
PUBLIC	_waveOutSetPlaybackRate
;	COMDAT _waveOutSetPlaybackRate
_TEXT	SEGMENT
_waveOutSetPlaybackRate PROC NEAR			; COMDAT

; 2269 : void NAKED waveOutSetPlaybackRate(void) {   INITWINMM __asm jmp dword ptr   pwaveOutSetPlaybackRate}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28470
	push	2269					; 000008ddH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28470:
	jmp	DWORD PTR _pwaveOutSetPlaybackRate
_waveOutSetPlaybackRate ENDP
_TEXT	ENDS
PUBLIC	_waveOutSetVolume
;	COMDAT _waveOutSetVolume
_TEXT	SEGMENT
_waveOutSetVolume PROC NEAR				; COMDAT

; 2270 : void NAKED waveOutSetVolume(void) {   INITWINMM __asm jmp dword ptr   pwaveOutSetVolume}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28473
	push	2270					; 000008deH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28473:
	jmp	DWORD PTR _pwaveOutSetVolume
_waveOutSetVolume ENDP
_TEXT	ENDS
PUBLIC	_waveOutWrite
;	COMDAT _waveOutWrite
_TEXT	SEGMENT
_waveOutWrite PROC NEAR					; COMDAT

; 2271 : void NAKED waveOutWrite(void) {   INITWINMM __asm jmp dword ptr   pwaveOutWrite}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28476
	push	2271					; 000008dfH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28476:
	jmp	DWORD PTR _pwaveOutWrite
_waveOutWrite ENDP
_TEXT	ENDS
PUBLIC	_wid32Message
;	COMDAT _wid32Message
_TEXT	SEGMENT
_wid32Message PROC NEAR					; COMDAT

; 2272 : void NAKED wid32Message(void) {   INITWINMM __asm jmp dword ptr   pwid32Message}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28479
	push	2272					; 000008e0H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28479:
	jmp	DWORD PTR _pwid32Message
_wid32Message ENDP
_TEXT	ENDS
PUBLIC	_winmmDbgOut
;	COMDAT _winmmDbgOut
_TEXT	SEGMENT
_winmmDbgOut PROC NEAR					; COMDAT

; 2273 : void NAKED winmmDbgOut(void) {   INITWINMM __asm jmp dword ptr   pwinmmDbgOut}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28482
	push	2273					; 000008e1H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28482:
	jmp	DWORD PTR _pwinmmDbgOut
_winmmDbgOut ENDP
_TEXT	ENDS
PUBLIC	_winmmSetDebugLevel
;	COMDAT _winmmSetDebugLevel
_TEXT	SEGMENT
_winmmSetDebugLevel PROC NEAR				; COMDAT

; 2274 : void NAKED winmmSetDebugLevel(void) {   INITWINMM __asm jmp dword ptr   pwinmmSetDebugLevel}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28485
	push	2274					; 000008e2H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28485:
	jmp	DWORD PTR _pwinmmSetDebugLevel
_winmmSetDebugLevel ENDP
_TEXT	ENDS
PUBLIC	_wod32Message
;	COMDAT _wod32Message
_TEXT	SEGMENT
_wod32Message PROC NEAR					; COMDAT

; 2275 : void NAKED wod32Message(void) {   INITWINMM __asm jmp dword ptr   pwod32Message}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28488
	push	2275					; 000008e3H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28488:
	jmp	DWORD PTR _pwod32Message
_wod32Message ENDP
_TEXT	ENDS
PUBLIC	_waveInGetPosition
;	COMDAT _waveInGetPosition
_TEXT	SEGMENT
_waveInGetPosition PROC NEAR				; COMDAT

; 2278 : void NAKED waveInGetPosition(void) {   INITWINMM __asm jmp dword ptr   pwaveInGetPosition}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28491
	push	2278					; 000008e6H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28491:
	jmp	DWORD PTR _pwaveInGetPosition
_waveInGetPosition ENDP
_TEXT	ENDS
PUBLIC	_timeBeginPeriod
;	COMDAT _timeBeginPeriod
_TEXT	SEGMENT
_timeBeginPeriod PROC NEAR				; COMDAT

; 2279 : void NAKED timeBeginPeriod(void) {   INITWINMM __asm jmp dword ptr   ptimeBeginPeriod}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28494
	push	2279					; 000008e7H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28494:
	jmp	DWORD PTR _ptimeBeginPeriod
_timeBeginPeriod ENDP
_TEXT	ENDS
PUBLIC	_timeEndPeriod
;	COMDAT _timeEndPeriod
_TEXT	SEGMENT
_timeEndPeriod PROC NEAR				; COMDAT

; 2280 : void NAKED timeEndPeriod(void) {   INITWINMM __asm jmp dword ptr   ptimeEndPeriod}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28497
	push	2280					; 000008e8H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28497:
	jmp	DWORD PTR _ptimeEndPeriod
_timeEndPeriod ENDP
_TEXT	ENDS
PUBLIC	_mixerSetControlDetails
;	COMDAT _mixerSetControlDetails
_TEXT	SEGMENT
_mixerSetControlDetails PROC NEAR			; COMDAT

; 2282 : void NAKED mixerSetControlDetails(void) {   INITWINMM __asm jmp dword ptr   pmixerSetControlDetails}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28500
	push	2282					; 000008eaH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28500:
	jmp	DWORD PTR _pmixerSetControlDetails
_mixerSetControlDetails ENDP
_TEXT	ENDS
PUBLIC	_mixerOpen
;	COMDAT _mixerOpen
_TEXT	SEGMENT
_mixerOpen PROC NEAR					; COMDAT

; 2283 : void NAKED mixerOpen(void) {   INITWINMM __asm jmp dword ptr   pmixerOpen}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28503
	push	2283					; 000008ebH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28503:
	jmp	DWORD PTR _pmixerOpen
_mixerOpen ENDP
_TEXT	ENDS
PUBLIC	_mixerClose
;	COMDAT _mixerClose
_TEXT	SEGMENT
_mixerClose PROC NEAR					; COMDAT

; 2284 : void NAKED mixerClose(void) {   INITWINMM __asm jmp dword ptr   pmixerClose}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28506
	push	2284					; 000008ecH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28506:
	jmp	DWORD PTR _pmixerClose
_mixerClose ENDP
_TEXT	ENDS
PUBLIC	_mixerGetLineInfoA
;	COMDAT _mixerGetLineInfoA
_TEXT	SEGMENT
_mixerGetLineInfoA PROC NEAR				; COMDAT

; 2285 : void NAKED mixerGetLineInfoA(void) {   INITWINMM __asm jmp dword ptr   pmixerGetLineInfoA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28509
	push	2285					; 000008edH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28509:
	jmp	DWORD PTR _pmixerGetLineInfoA
_mixerGetLineInfoA ENDP
_TEXT	ENDS
PUBLIC	_mixerGetLineInfoW
;	COMDAT _mixerGetLineInfoW
_TEXT	SEGMENT
_mixerGetLineInfoW PROC NEAR				; COMDAT

; 2286 : void NAKED mixerGetLineInfoW(void) {   INITWINMM __asm jmp dword ptr   pmixerGetLineInfoW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28512
	push	2286					; 000008eeH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28512:
	jmp	DWORD PTR _pmixerGetLineInfoW
_mixerGetLineInfoW ENDP
_TEXT	ENDS
PUBLIC	_mixerGetLineControlsA
;	COMDAT _mixerGetLineControlsA
_TEXT	SEGMENT
_mixerGetLineControlsA PROC NEAR			; COMDAT

; 2287 : void NAKED mixerGetLineControlsA(void) {   INITWINMM __asm jmp dword ptr   pmixerGetLineControlsA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28515
	push	2287					; 000008efH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28515:
	jmp	DWORD PTR _pmixerGetLineControlsA
_mixerGetLineControlsA ENDP
_TEXT	ENDS
PUBLIC	_mixerGetLineControlsW
;	COMDAT _mixerGetLineControlsW
_TEXT	SEGMENT
_mixerGetLineControlsW PROC NEAR			; COMDAT

; 2288 : void NAKED mixerGetLineControlsW(void) {   INITWINMM __asm jmp dword ptr   pmixerGetLineControlsW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28518
	push	2288					; 000008f0H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28518:
	jmp	DWORD PTR _pmixerGetLineControlsW
_mixerGetLineControlsW ENDP
_TEXT	ENDS
PUBLIC	_mixerGetControlDetailsA
;	COMDAT _mixerGetControlDetailsA
_TEXT	SEGMENT
_mixerGetControlDetailsA PROC NEAR			; COMDAT

; 2289 : void NAKED mixerGetControlDetailsA(void) {   INITWINMM __asm jmp dword ptr   pmixerGetControlDetailsA}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28521
	push	2289					; 000008f1H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28521:
	jmp	DWORD PTR _pmixerGetControlDetailsA
_mixerGetControlDetailsA ENDP
_TEXT	ENDS
PUBLIC	_mixerGetControlDetailsW
;	COMDAT _mixerGetControlDetailsW
_TEXT	SEGMENT
_mixerGetControlDetailsW PROC NEAR			; COMDAT

; 2290 : void NAKED mixerGetControlDetailsW(void) {   INITWINMM __asm jmp dword ptr   pmixerGetControlDetailsW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28524
	push	2290					; 000008f2H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28524:
	jmp	DWORD PTR _pmixerGetControlDetailsW
_mixerGetControlDetailsW ENDP
_TEXT	ENDS
PUBLIC	_waveOutGetPosition
;	COMDAT _waveOutGetPosition
_TEXT	SEGMENT
_waveOutGetPosition PROC NEAR				; COMDAT

; 2292 : void NAKED waveOutGetPosition(void) {   INITWINMM __asm jmp dword ptr   pwaveOutGetPosition}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28527
	push	2292					; 000008f4H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28527:
	jmp	DWORD PTR _pwaveOutGetPosition
_waveOutGetPosition ENDP
_TEXT	ENDS
PUBLIC	_waveOutPrepareHeader
;	COMDAT _waveOutPrepareHeader
_TEXT	SEGMENT
_waveOutPrepareHeader PROC NEAR				; COMDAT

; 2293 : void NAKED waveOutPrepareHeader(void) {   INITWINMM __asm jmp dword ptr   pwaveOutPrepareHeader}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28530
	push	2293					; 000008f5H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28530:
	jmp	DWORD PTR _pwaveOutPrepareHeader
_waveOutPrepareHeader ENDP
_TEXT	ENDS
PUBLIC	_waveOutUnprepareHeader
;	COMDAT _waveOutUnprepareHeader
_TEXT	SEGMENT
_waveOutUnprepareHeader PROC NEAR			; COMDAT

; 2294 : void NAKED waveOutUnprepareHeader(void) {   INITWINMM __asm jmp dword ptr   pwaveOutUnprepareHeader}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28533
	push	2294					; 000008f6H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28533:
	jmp	DWORD PTR _pwaveOutUnprepareHeader
_waveOutUnprepareHeader ENDP
_TEXT	ENDS
PUBLIC	_CloseDriver
;	COMDAT _CloseDriver
_TEXT	SEGMENT
_CloseDriver PROC NEAR					; COMDAT

; 2296 : void NAKED CloseDriver(void) { INITWINMM __asm jmp dword ptr pCloseDriver  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28536
	push	2296					; 000008f8H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28536:
	jmp	DWORD PTR _pCloseDriver
_CloseDriver ENDP
_TEXT	ENDS
PUBLIC	_DefDriverProc
;	COMDAT _DefDriverProc
_TEXT	SEGMENT
_DefDriverProc PROC NEAR				; COMDAT

; 2297 : void NAKED DefDriverProc(void) { INITWINMM __asm jmp dword ptr pDefDriverProc  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28539
	push	2297					; 000008f9H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28539:
	jmp	DWORD PTR _pDefDriverProc
_DefDriverProc ENDP
_TEXT	ENDS
PUBLIC	_DriverCallback
;	COMDAT _DriverCallback
_TEXT	SEGMENT
_DriverCallback PROC NEAR				; COMDAT

; 2298 : void NAKED DriverCallback(void) { INITWINMM __asm jmp dword ptr pDriverCallback  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28542
	push	2298					; 000008faH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28542:
	jmp	DWORD PTR _pDriverCallback
_DriverCallback ENDP
_TEXT	ENDS
PUBLIC	_DrvGetModuleHandle
;	COMDAT _DrvGetModuleHandle
_TEXT	SEGMENT
_DrvGetModuleHandle PROC NEAR				; COMDAT

; 2299 : void NAKED DrvGetModuleHandle(void) { INITWINMM __asm jmp dword ptr pDrvGetModuleHandle  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28545
	push	2299					; 000008fbH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28545:
	jmp	DWORD PTR _pDrvGetModuleHandle
_DrvGetModuleHandle ENDP
_TEXT	ENDS
PUBLIC	_GetDriverModuleHandle
;	COMDAT _GetDriverModuleHandle
_TEXT	SEGMENT
_GetDriverModuleHandle PROC NEAR			; COMDAT

; 2300 : void NAKED GetDriverModuleHandle(void) { INITWINMM __asm jmp dword ptr pGetDriverModuleHandle  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28548
	push	2300					; 000008fcH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28548:
	jmp	DWORD PTR _pGetDriverModuleHandle
_GetDriverModuleHandle ENDP
_TEXT	ENDS
PUBLIC	_MigrateAllDrivers
;	COMDAT _MigrateAllDrivers
_TEXT	SEGMENT
_MigrateAllDrivers PROC NEAR				; COMDAT

; 2301 : void NAKED MigrateAllDrivers(void) { INITWINMM __asm jmp dword ptr pMigrateAllDrivers  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28551
	push	2301					; 000008fdH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28551:
	jmp	DWORD PTR _pMigrateAllDrivers
_MigrateAllDrivers ENDP
_TEXT	ENDS
PUBLIC	_MigrateSoundEvents
;	COMDAT _MigrateSoundEvents
_TEXT	SEGMENT
_MigrateSoundEvents PROC NEAR				; COMDAT

; 2303 : void NAKED MigrateSoundEvents(void) { INITWINMM __asm jmp dword ptr pMigrateSoundEvents  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28554
	push	2303					; 000008ffH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28554:
	jmp	DWORD PTR _pMigrateSoundEvents
_MigrateSoundEvents ENDP
_TEXT	ENDS
PUBLIC	_NotifyCallbackData
;	COMDAT _NotifyCallbackData
_TEXT	SEGMENT
_NotifyCallbackData PROC NEAR				; COMDAT

; 2304 : void NAKED NotifyCallbackData(void) { INITWINMM __asm jmp dword ptr pNotifyCallbackData  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28557
	push	2304					; 00000900H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28557:
	jmp	DWORD PTR _pNotifyCallbackData
_NotifyCallbackData ENDP
_TEXT	ENDS
PUBLIC	_OpenDriver
;	COMDAT _OpenDriver
_TEXT	SEGMENT
_OpenDriver PROC NEAR					; COMDAT

; 2305 : void NAKED OpenDriver(void) { INITWINMM __asm jmp dword ptr pOpenDriver  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28560
	push	2305					; 00000901H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28560:
	jmp	DWORD PTR _pOpenDriver
_OpenDriver ENDP
_TEXT	ENDS
PUBLIC	_PlaySound
;	COMDAT _PlaySound
_TEXT	SEGMENT
_PlaySound PROC NEAR					; COMDAT

; 2306 : void NAKED PlaySound(void) { INITWINMM __asm jmp dword ptr pPlaySound  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28563
	push	2306					; 00000902H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28563:
	jmp	DWORD PTR _pPlaySound
_PlaySound ENDP
_TEXT	ENDS
PUBLIC	_PlaySoundA
;	COMDAT _PlaySoundA
_TEXT	SEGMENT
_PlaySoundA PROC NEAR					; COMDAT

; 2307 : void NAKED PlaySoundA(void) { INITWINMM __asm jmp dword ptr pPlaySoundA  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28566
	push	2307					; 00000903H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28566:
	jmp	DWORD PTR _pPlaySoundA
_PlaySoundA ENDP
_TEXT	ENDS
PUBLIC	_PlaySoundW
;	COMDAT _PlaySoundW
_TEXT	SEGMENT
_PlaySoundW PROC NEAR					; COMDAT

; 2308 : void NAKED PlaySoundW(void) { INITWINMM __asm jmp dword ptr pPlaySoundW  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28569
	push	2308					; 00000904H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28569:
	jmp	DWORD PTR _pPlaySoundW
_PlaySoundW ENDP
_TEXT	ENDS
PUBLIC	_SendDriverMessage
;	COMDAT _SendDriverMessage
_TEXT	SEGMENT
_SendDriverMessage PROC NEAR				; COMDAT

; 2309 : void NAKED SendDriverMessage(void) { INITWINMM __asm jmp dword ptr pSendDriverMessage  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28572
	push	2309					; 00000905H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28572:
	jmp	DWORD PTR _pSendDriverMessage
_SendDriverMessage ENDP
_TEXT	ENDS
PUBLIC	_WOW32DriverCallback
;	COMDAT _WOW32DriverCallback
_TEXT	SEGMENT
_WOW32DriverCallback PROC NEAR				; COMDAT

; 2310 : void NAKED WOW32DriverCallback(void) { INITWINMM __asm jmp dword ptr pWOW32DriverCallback  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28575
	push	2310					; 00000906H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28575:
	jmp	DWORD PTR _pWOW32DriverCallback
_WOW32DriverCallback ENDP
_TEXT	ENDS
PUBLIC	_WOW32ResolveMultiMediaHandle
;	COMDAT _WOW32ResolveMultiMediaHandle
_TEXT	SEGMENT
_WOW32ResolveMultiMediaHandle PROC NEAR			; COMDAT

; 2311 : void NAKED WOW32ResolveMultiMediaHandle(void) { INITWINMM __asm jmp dword ptr pWOW32ResolveMultiMediaHandle  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28578
	push	2311					; 00000907H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28578:
	jmp	DWORD PTR _pWOW32ResolveMultiMediaHandle
_WOW32ResolveMultiMediaHandle ENDP
_TEXT	ENDS
PUBLIC	_WOWAppExit
;	COMDAT _WOWAppExit
_TEXT	SEGMENT
_WOWAppExit PROC NEAR					; COMDAT

; 2312 : void NAKED WOWAppExit(void) { INITWINMM __asm jmp dword ptr pWOWAppExit  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28581
	push	2312					; 00000908H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28581:
	jmp	DWORD PTR _pWOWAppExit
_WOWAppExit ENDP
_TEXT	ENDS
PUBLIC	_WinmmLogoff
;	COMDAT _WinmmLogoff
_TEXT	SEGMENT
_WinmmLogoff PROC NEAR					; COMDAT

; 2313 : void NAKED WinmmLogoff(void) { INITWINMM __asm jmp dword ptr pWinmmLogoff  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28584
	push	2313					; 00000909H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28584:
	jmp	DWORD PTR _pWinmmLogoff
_WinmmLogoff ENDP
_TEXT	ENDS
PUBLIC	_WinmmLogon
;	COMDAT _WinmmLogon
_TEXT	SEGMENT
_WinmmLogon PROC NEAR					; COMDAT

; 2314 : void NAKED WinmmLogon(void) { INITWINMM __asm jmp dword ptr pWinmmLogon  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28587
	push	2314					; 0000090aH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28587:
	jmp	DWORD PTR _pWinmmLogon
_WinmmLogon ENDP
_TEXT	ENDS
PUBLIC	_aux32Message
;	COMDAT _aux32Message
_TEXT	SEGMENT
_aux32Message PROC NEAR					; COMDAT

; 2315 : void NAKED aux32Message(void) { INITWINMM __asm jmp dword ptr paux32Message  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28590
	push	2315					; 0000090bH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28590:
	jmp	DWORD PTR _paux32Message
_aux32Message ENDP
_TEXT	ENDS
PUBLIC	_auxGetDevCapsA
;	COMDAT _auxGetDevCapsA
_TEXT	SEGMENT
_auxGetDevCapsA PROC NEAR				; COMDAT

; 2316 : void NAKED auxGetDevCapsA(void) { INITWINMM __asm jmp dword ptr pauxGetDevCapsA  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28593
	push	2316					; 0000090cH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28593:
	jmp	DWORD PTR _pauxGetDevCapsA
_auxGetDevCapsA ENDP
_TEXT	ENDS
PUBLIC	_auxGetDevCapsW
;	COMDAT _auxGetDevCapsW
_TEXT	SEGMENT
_auxGetDevCapsW PROC NEAR				; COMDAT

; 2317 : void NAKED auxGetDevCapsW(void) { INITWINMM __asm jmp dword ptr pauxGetDevCapsW  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28596
	push	2317					; 0000090dH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28596:
	jmp	DWORD PTR _pauxGetDevCapsW
_auxGetDevCapsW ENDP
_TEXT	ENDS
PUBLIC	_auxGetNumDevs
;	COMDAT _auxGetNumDevs
_TEXT	SEGMENT
_auxGetNumDevs PROC NEAR				; COMDAT

; 2318 : void NAKED auxGetNumDevs(void) { INITWINMM __asm jmp dword ptr pauxGetNumDevs  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28599
	push	2318					; 0000090eH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28599:
	jmp	DWORD PTR _pauxGetNumDevs
_auxGetNumDevs ENDP
_TEXT	ENDS
PUBLIC	_auxGetVolume
;	COMDAT _auxGetVolume
_TEXT	SEGMENT
_auxGetVolume PROC NEAR					; COMDAT

; 2319 : void NAKED auxGetVolume(void) { INITWINMM __asm jmp dword ptr pauxGetVolume  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28602
	push	2319					; 0000090fH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28602:
	jmp	DWORD PTR _pauxGetVolume
_auxGetVolume ENDP
_TEXT	ENDS
PUBLIC	_auxOutMessage
;	COMDAT _auxOutMessage
_TEXT	SEGMENT
_auxOutMessage PROC NEAR				; COMDAT

; 2320 : void NAKED auxOutMessage(void) { INITWINMM __asm jmp dword ptr pauxOutMessage  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28605
	push	2320					; 00000910H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28605:
	jmp	DWORD PTR _pauxOutMessage
_auxOutMessage ENDP
_TEXT	ENDS
PUBLIC	_auxSetVolume
;	COMDAT _auxSetVolume
_TEXT	SEGMENT
_auxSetVolume PROC NEAR					; COMDAT

; 2321 : void NAKED auxSetVolume(void) { INITWINMM __asm jmp dword ptr pauxSetVolume  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28608
	push	2321					; 00000911H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28608:
	jmp	DWORD PTR _pauxSetVolume
_auxSetVolume ENDP
_TEXT	ENDS
PUBLIC	_joy32Message
;	COMDAT _joy32Message
_TEXT	SEGMENT
_joy32Message PROC NEAR					; COMDAT

; 2322 : void NAKED joy32Message(void) { INITWINMM __asm jmp dword ptr pjoy32Message  }

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28611
	push	2322					; 00000912H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28611:
	jmp	DWORD PTR _pjoy32Message
_joy32Message ENDP
_TEXT	ENDS
PUBLIC	_timeGetTime
;	COMDAT _timeGetTime
_TEXT	SEGMENT
_timeGetTime PROC NEAR					; COMDAT

; 2323 : void NAKED timeGetTime(void) {   INITWINMM __asm jmp dword ptr   ptimeGetTime}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28614
	push	2323					; 00000913H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28614:
	jmp	DWORD PTR _ptimeGetTime
_timeGetTime ENDP
_TEXT	ENDS
PUBLIC	_joyGetDevCapsW
;	COMDAT _joyGetDevCapsW
_TEXT	SEGMENT
_joyGetDevCapsW PROC NEAR				; COMDAT

; 2324 : void NAKED joyGetDevCapsW(void) {   INITWINMM __asm jmp dword ptr   pjoyGetDevCapsW}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28618
	push	2324					; 00000914H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28618:
	jmp	DWORD PTR _pjoyGetDevCapsW
_joyGetDevCapsW ENDP
_TEXT	ENDS
PUBLIC	_joyGetPos
;	COMDAT _joyGetPos
_TEXT	SEGMENT
_joyGetPos PROC NEAR					; COMDAT

; 2325 : void NAKED joyGetPos(void) {   INITWINMM __asm jmp dword ptr   pjoyGetPos}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28622
	push	2325					; 00000915H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28622:
	jmp	DWORD PTR _pjoyGetPos
_joyGetPos ENDP
_TEXT	ENDS
PUBLIC	_gfxAddGfx
;	COMDAT _gfxAddGfx
_TEXT	SEGMENT
_gfxAddGfx PROC NEAR					; COMDAT

; 2327 : void NAKED gfxAddGfx(void) {   INITWINMM __asm jmp dword ptr   pgfxAddGfx}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28625
	push	2327					; 00000917H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28625:
	jmp	DWORD PTR _pgfxAddGfx
_gfxAddGfx ENDP
_TEXT	ENDS
PUBLIC	_gfxBatchChange
;	COMDAT _gfxBatchChange
_TEXT	SEGMENT
_gfxBatchChange PROC NEAR				; COMDAT

; 2328 : void NAKED gfxBatchChange(void) {   INITWINMM __asm jmp dword ptr   pgfxBatchChange}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28628
	push	2328					; 00000918H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28628:
	jmp	DWORD PTR _pgfxBatchChange
_gfxBatchChange ENDP
_TEXT	ENDS
PUBLIC	_gfxCreateGfxFactoriesList
;	COMDAT _gfxCreateGfxFactoriesList
_TEXT	SEGMENT
_gfxCreateGfxFactoriesList PROC NEAR			; COMDAT

; 2329 : void NAKED gfxCreateGfxFactoriesList(void) {   INITWINMM __asm jmp dword ptr   pgfxCreateGfxFactoriesList}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28631
	push	2329					; 00000919H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28631:
	jmp	DWORD PTR _pgfxCreateGfxFactoriesList
_gfxCreateGfxFactoriesList ENDP
_TEXT	ENDS
PUBLIC	_gfxCreateZoneFactoriesList
;	COMDAT _gfxCreateZoneFactoriesList
_TEXT	SEGMENT
_gfxCreateZoneFactoriesList PROC NEAR			; COMDAT

; 2330 : void NAKED gfxCreateZoneFactoriesList(void) {   INITWINMM __asm jmp dword ptr   pgfxCreateZoneFactoriesList}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28634
	push	2330					; 0000091aH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28634:
	jmp	DWORD PTR _pgfxCreateZoneFactoriesList
_gfxCreateZoneFactoriesList ENDP
_TEXT	ENDS
PUBLIC	_gfxDestroyDeviceInterfaceList
;	COMDAT _gfxDestroyDeviceInterfaceList
_TEXT	SEGMENT
_gfxDestroyDeviceInterfaceList PROC NEAR		; COMDAT

; 2331 : void NAKED gfxDestroyDeviceInterfaceList(void) {   INITWINMM __asm jmp dword ptr   pgfxDestroyDeviceInterfaceList}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28637
	push	2331					; 0000091bH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28637:
	jmp	DWORD PTR _pgfxDestroyDeviceInterfaceList
_gfxDestroyDeviceInterfaceList ENDP
_TEXT	ENDS
PUBLIC	_gfxEnumerateGfxs
;	COMDAT _gfxEnumerateGfxs
_TEXT	SEGMENT
_gfxEnumerateGfxs PROC NEAR				; COMDAT

; 2332 : void NAKED gfxEnumerateGfxs(void) {   INITWINMM __asm jmp dword ptr   pgfxEnumerateGfxs}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28640
	push	2332					; 0000091cH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28640:
	jmp	DWORD PTR _pgfxEnumerateGfxs
_gfxEnumerateGfxs ENDP
_TEXT	ENDS
PUBLIC	__gfxLogoff
;	COMDAT __gfxLogoff
_TEXT	SEGMENT
__gfxLogoff PROC NEAR					; COMDAT

; 2333 : void NAKED _gfxLogoff(void) {   INITWINMM __asm jmp dword ptr   p_gfxLogoff}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28643
	push	2333					; 0000091dH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28643:
	jmp	DWORD PTR _p_gfxLogoff
__gfxLogoff ENDP
_TEXT	ENDS
PUBLIC	__gfxLogon
;	COMDAT __gfxLogon
_TEXT	SEGMENT
__gfxLogon PROC NEAR					; COMDAT

; 2334 : void NAKED _gfxLogon(void) {   INITWINMM __asm jmp dword ptr   p_gfxLogon}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28646
	push	2334					; 0000091eH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28646:
	jmp	DWORD PTR _p_gfxLogon
__gfxLogon ENDP
_TEXT	ENDS
PUBLIC	_gfxModifyGfx
;	COMDAT _gfxModifyGfx
_TEXT	SEGMENT
_gfxModifyGfx PROC NEAR					; COMDAT

; 2335 : void NAKED gfxModifyGfx(void) {   INITWINMM __asm jmp dword ptr   pgfxModifyGfx}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28649
	push	2335					; 0000091fH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28649:
	jmp	DWORD PTR _pgfxModifyGfx
_gfxModifyGfx ENDP
_TEXT	ENDS
PUBLIC	_gfxOpenGfx
;	COMDAT _gfxOpenGfx
_TEXT	SEGMENT
_gfxOpenGfx PROC NEAR					; COMDAT

; 2336 : void NAKED gfxOpenGfx(void) {   INITWINMM __asm jmp dword ptr   pgfxOpenGfx}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28652
	push	2336					; 00000920H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28652:
	jmp	DWORD PTR _pgfxOpenGfx
_gfxOpenGfx ENDP
_TEXT	ENDS
PUBLIC	_gfxRemoveGfx
;	COMDAT _gfxRemoveGfx
_TEXT	SEGMENT
_gfxRemoveGfx PROC NEAR					; COMDAT

; 2337 : void NAKED gfxRemoveGfx(void) {   INITWINMM __asm jmp dword ptr   pgfxRemoveGfx}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28655
	push	2337					; 00000921H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28655:
	jmp	DWORD PTR _pgfxRemoveGfx
_gfxRemoveGfx ENDP
_TEXT	ENDS
PUBLIC	_waveInAddBuffer
;	COMDAT _waveInAddBuffer
_TEXT	SEGMENT
_waveInAddBuffer PROC NEAR				; COMDAT

; 2340 : UINT NAKED waveInAddBuffer(HWAVEIN a, void* b, UINT c) {  INITWINMM __asm jmp dword ptr   pwaveInAddBuffer}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28663
	push	2340					; 00000924H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28663:
	jmp	DWORD PTR _pwaveInAddBuffer
_waveInAddBuffer ENDP
_TEXT	ENDS
PUBLIC	_waveInClose
;	COMDAT _waveInClose
_TEXT	SEGMENT
_waveInClose PROC NEAR					; COMDAT

; 2341 : UINT NAKED waveInClose(HWAVEIN a) { INITWINMM  __asm jmp dword ptr   pwaveInClose}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28667
	push	2341					; 00000925H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28667:
	jmp	DWORD PTR _pwaveInClose
_waveInClose ENDP
_TEXT	ENDS
PUBLIC	_waveInOpen
;	COMDAT _waveInOpen
_TEXT	SEGMENT
_waveInOpen PROC NEAR					; COMDAT

; 2342 : UINT NAKED waveInOpen(void* a, UINT b, void* c, DWORD d, DWORD e, DWORD f) { INITWINMM  __asm jmp dword ptr   pwaveInOpen}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28681
	push	2342					; 00000926H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28681:
	jmp	DWORD PTR _pwaveInOpen
_waveInOpen ENDP
_TEXT	ENDS
PUBLIC	_waveInPrepareHeader
;	COMDAT _waveInPrepareHeader
_TEXT	SEGMENT
_waveInPrepareHeader PROC NEAR				; COMDAT

; 2343 : UINT NAKED waveInPrepareHeader(HWAVEIN a, void* b, UINT c) { INITWINMM  __asm jmp dword ptr   pwaveInPrepareHeader}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28689
	push	2343					; 00000927H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28689:
	jmp	DWORD PTR _pwaveInPrepareHeader
_waveInPrepareHeader ENDP
_TEXT	ENDS
PUBLIC	_waveInStart
;	COMDAT _waveInStart
_TEXT	SEGMENT
_waveInStart PROC NEAR					; COMDAT

; 2344 : UINT NAKED waveInStart(HWAVEIN a ) { INITWINMM  __asm jmp dword ptr   pwaveInStart}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28693
	push	2344					; 00000928H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28693:
	jmp	DWORD PTR _pwaveInStart
_waveInStart ENDP
_TEXT	ENDS
PUBLIC	_waveInStop
;	COMDAT _waveInStop
_TEXT	SEGMENT
_waveInStop PROC NEAR					; COMDAT

; 2345 : UINT NAKED waveInStop(HWAVEIN a) { INITWINMM  __asm jmp dword ptr   pwaveInStop}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28697
	push	2345					; 00000929H
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28697:
	jmp	DWORD PTR _pwaveInStop
_waveInStop ENDP
_TEXT	ENDS
PUBLIC	_waveInUnprepareHeader
;	COMDAT _waveInUnprepareHeader
_TEXT	SEGMENT
_waveInUnprepareHeader PROC NEAR			; COMDAT

; 2346 : UINT NAKED waveInUnprepareHeader(HWAVEIN a, void* b, UINT c) { INITWINMM  __asm jmp dword ptr   pwaveInUnprepareHeader}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28705
	push	2346					; 0000092aH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28705:
	jmp	DWORD PTR _pwaveInUnprepareHeader
_waveInUnprepareHeader ENDP
_TEXT	ENDS
PUBLIC	_waveInReset
;	COMDAT _waveInReset
_TEXT	SEGMENT
_waveInReset PROC NEAR					; COMDAT

; 2347 : UINT NAKED waveInReset(HWAVEIN a) { INITWINMM  __asm jmp dword ptr   pwaveInReset}

	cmp	DWORD PTR _hWinmm, 0
	jne	SHORT $L28709
	push	2347					; 0000092bH
	call	_LoadWinmm
	add	esp, 4
	mov	eax, DWORD PTR _hWinmm
	push	eax
	mov	ecx, DWORD PTR _TlsIndex
	push	ecx
	call	DWORD PTR __imp__TlsSetValue@8
	call	_LoadJsChPostProc
	mov	DWORD PTR _hJschpostproc, eax
	call	_StartPropo
$L28709:
	jmp	DWORD PTR _pwaveInReset
_waveInReset ENDP
_TEXT	ENDS
END
